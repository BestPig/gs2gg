__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1613943958202, "_binascii": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins,\n    _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\nvar error = $B.make_class(\"error\", _b_.Exception.$factory)\nerror.__bases__ = [_b_.Exception]\n$B.set_func_names(error, \"binascii\")\n\nfunction decode(bytes, altchars, validate){\n    var output = [],\n        chr1, chr2, chr3,\n        enc1, enc2, enc3, enc4\n\n    var alphabet = make_alphabet(altchars)\n\n    var input = bytes.source\n\n    // If validate is set, check that all characters in input\n    // are in the alphabet\n    var _input = ''\n    var padding = 0\n    for(var i = 0, len = input.length; i < len; i++){\n        var car = String.fromCharCode(input[i])\n        var char_num = alphabet.indexOf(car)\n        if(char_num == -1){\n            if(validate){throw error.$factory(\"Non-base64 digit found: \" +\n                car)}\n        }else if(char_num == 64 && i < input.length - 2){\n            if(validate){throw error.$factory(\"Non-base64 digit found: \" +\n                car)}\n        }else if(char_num == 64 && i >= input.length - 2){\n            padding++\n            _input += car\n        }else{\n            _input += car\n        }\n    }\n    input = _input\n    if(_input.length == padding){return _b_.bytes.$factory([])}\n    if( _input.length % 4 > 0){throw error.$factory(\"Incorrect padding\")}\n\n    var i = 0\n    while(i < input.length){\n\n        enc1 = alphabet.indexOf(input.charAt(i++))\n        enc2 = alphabet.indexOf(input.charAt(i++))\n        enc3 = alphabet.indexOf(input.charAt(i++))\n        enc4 = alphabet.indexOf(input.charAt(i++))\n\n        chr1 = (enc1 << 2) | (enc2 >> 4)\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n        chr3 = ((enc3 & 3) << 6) | enc4\n\n        output.push(chr1)\n\n        if(enc3 != 64){output.push(chr2)}\n        if(enc4 != 64){output.push(chr3)}\n\n    }\n    // return Python bytes\n    return _b_.bytes.$factory(output, 'utf-8', 'strict')\n}\n\n\nvar hex2int = {},\n    hex = '0123456789abcdef'\nfor(var i = 0; i < hex.length; i++){\n    hex2int[hex[i]] = i\n    hex2int[hex[i].toUpperCase()] = i\n}\n\nfunction make_alphabet(altchars){\n    var alphabet = _keyStr\n    if(altchars !== undefined && altchars !== _b_.None){\n        // altchars is an instance of Python bytes\n        var source = altchars.source\n        alphabet = alphabet.substr(0,alphabet.length-3) +\n            _b_.chr(source[0]) + _b_.chr(source[1]) + '='\n    }\n    return alphabet\n}\n\nvar module = {\n    a2b_base64: function(){\n        var $ = $B.args(\"a2b_base64\", 1, {s: null}, ['s'],\n                arguments, {}, null, null)\n        return decode(_b_.str.encode($.s, 'ascii'))\n    },\n    a2b_hex: function(){\n        var $ = $B.args(\"a2b_hex\", 1, {s: null}, ['s'],\n                arguments, {}, null, null),\n            s = $.s\n        if(_b_.isinstance(s, _b_.bytes)){\n            s = _b_.bytes.decode(s, 'ascii')\n        }\n        if(typeof s !== \"string\"){\n            throw _b_.TypeError.$factory(\"argument should be bytes, \" +\n                \"buffer or ASCII string, not '\" + $B.class_name(s) + \"'\")\n        }\n    \n        var len = s.length\n        if(len % 2 == 1){\n            throw _b_.TypeError.$factory('Odd-length string')\n        }\n    \n        var res = []\n        for(var i = 0; i < len; i += 2){\n            res.push((hex2int[s.charAt(i)] << 4) + hex2int[s.charAt(i + 1)])\n        }\n        return _b_.bytes.$factory(res)\n    },\n    b2a_base64: function(){\n        var $ = $B.args(\"b2a_base64\", 1, {data: null}, ['data'],\n                arguments, {}, null, \"kw\")\n        var newline = false\n        if($.kw && $.kw.$string_dict.newline){\n            newline = $.kw.$string_dict.newline[0]\n        }\n\n        var string = $B.to_bytes($.data),\n            res = btoa(String.fromCharCode.apply(null, string))\n        if(newline){res += \"\\n\"}\n        return _b_.bytes.$factory(res, \"ascii\")\n    },\n    b2a_hex: function(obj){\n        var string = $B.to_bytes(obj),\n            res = []\n        function conv(c){\n            if(c > 9){\n                c = c + 'a'.charCodeAt(0) - 10\n            }else{\n                c = c + '0'.charCodeAt(0)\n            }\n            return c\n        }\n        string.forEach(function(char){\n            res.push(conv((char >> 4) & 0xf))\n            res.push(conv(char & 0xf))\n        })\n        return _b_.bytes.$factory(res, \"ascii\")\n    },\n    b2a_uu: function(obj){\n        var string = $B.to_bytes(obj)\n        var len = string.length,\n            res = String.fromCharCode((0x20 + len) & 0x3F)\n        while(string.length > 0){\n            var s = string.slice(0, 3)\n            while(s.length < 3){s.push(String.fromCharCode(0))}\n            var A = s[0],\n                B = s[1],\n                C = s[2]\n            var a = (A >> 2) & 0x3F,\n                b = ((A << 4) | ((B >> 4) & 0xF)) & 0x3F,\n                c = (((B << 2) | ((C >> 6) & 0x3)) & 0x3F),\n                d = C & 0x3F\n            res += String.fromCharCode(0x20 + a, 0x20 + b, 0x20 + c, 0x20 + d)\n            string = string.slice(3)\n        }\n        return _b_.bytes.$factory(res + \"\\n\", \"ascii\")\n    },\n    error: error\n}\n\nmodule.hexlify = module.b2a_hex\nmodule.unhexlify = module.a2b_hex\n\nreturn module\n}\n)(__BRYTHON__)"], "_sre_utils": [".js", "var $module=(function($B){\n\n    function unicode_iscased(cp){\n        // cp : Unicode code point\n        var letter = String.fromCodePoint(cp)\n        return (letter != letter.toLowerCase() ||\n            letter != letter.toUpperCase())\n    }\n\n    function ascii_iscased(cp){\n        if(cp > 255){return false}\n        return unicode_iscased(cp)\n    }\n\n    function unicode_tolower(cp){\n        var letter = String.fromCodePoint(cp),\n            lower = letter.toLowerCase()\n        return lower.charCodeAt(0)\n    }\n\n    function ascii_tolower(cp){\n        return unicode_tolower(cp)\n    }\n\nreturn {\n    unicode_iscased: unicode_iscased,\n    ascii_iscased: ascii_iscased,\n    unicode_tolower: unicode_tolower,\n    ascii_tolower: ascii_tolower\n}\n\n}\n\n)(__BRYTHON__)"], "_webworker": [".js", "// Web Worker implementation\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar brython_scripts = ['brython', 'brython_stdlib']\n\nvar wclass = $B.make_class(\"Worker\",\n    function(worker){\n        var res = worker\n        res.send = res.postMessage\n        return res\n    }\n)\nwclass.__mro__ = [$B.JSObj, _b_.object]\n\n$B.set_func_names(wclass, \"browser.worker\")\n\nvar _Worker = $B.make_class(\"Worker\", function(id, onmessage, onerror){\n    var $ = $B.args(\"__init__\", 3, {id: null, onmessage: null, onerror: null},\n            ['id', 'onmessage', 'onerror'], arguments,\n            {onmessage: _b_.None, onerror: _b_.None}, null, null),\n        id = $.id,\n        src = $B.webworkers[id]\n        if(src === undefined){\n            throw _b_.KeyError.$factory(id)\n        }\n        var script_id = \"worker\" + $B.UUID(),\n            js = __BRYTHON__.imported.javascript.py2js(src,\n                script_id),\n            header = 'var $locals_' + script_id +' = {}\\n';\n        brython_scripts.forEach(function(script){\n            var url = $B.brython_path + script + \".js?\" +\n                (new Date()).getTime()\n            header += 'importScripts(\"' + url + '\")\\n'\n        })\n        // restore brython_path\n        header += '__BRYTHON__.brython_path = \"' + $B.brython_path +\n            '\"\\n'\n        // restore path for imports (cf. issue #1305)\n        header += '__BRYTHON__.path = \"' + $B.path +'\".split(\",\")\\n'\n        // Call brython() to initialize internal Brython values\n        header += 'brython(1)\\n'\n        js = header + js\n        var blob = new Blob([js], {type: \"application/js\"}),\n            url = URL.createObjectURL(blob),\n            w = new Worker(url),\n            res = wclass.$factory(w)\n        return res\n})\n\nreturn {\n    Worker: _Worker\n}\n\n})(__BRYTHON__)\n"], "_io_classes": [".js", "var _b_ = __BRYTHON__.builtins\n\nfunction get_self(name, args){\n    return $B.args(name, 1, {self: null}, [\"self\"], args, {}, null, null).self\n}\n\nvar _IOBase = $B.make_class(\"_IOBase\")\n_IOBase.__mro__ = [_b_.object]\n\n_IOBase.close = function(){\n    get_self(\"close\", arguments).__closed = true\n}\n\n_IOBase.flush = function(){\n    get_self(\"flush\", arguments)\n    return _b_.None\n}\n\n// Base class for binary streams that support some kind of buffering.\nvar _BufferedIOBase = $B.make_class(\"_BufferedIOBase\")\n_BufferedIOBase.__mro__ = [_IOBase, _b_.object]\n\n// Base class for raw binary I/O.\nvar _RawIOBase = $B.make_class(\"_RawIOBase\")\n\n_RawIOBase.__mro__ = [_IOBase, _b_.object]\n\n_RawIOBase.read = function(){\n    var $ = $B.args(\"read\", 2, {self: null, size: null}, [\"self\", \"size\"],\n                    arguments, {size: -1}, null, null),\n        self = $.self,\n        size = $.size,\n        res\n    self.$pos = self.$pos || 0\n    if(size == -1){\n        if(self.$pos == 0){\n            res = self.$content\n        }else{\n            res = _b_.bytes.$factory(self.$content.source.slice(self.$pos))\n        }\n        self.$pos = self.$content.source.length - 1\n    }else{\n        res = _b_.bytes.$factory(self.$content.source.slice(self.$pos, size))\n        self.$pos += size\n    }\n    return res\n}\n\n_RawIOBase.readall = function(){\n    return _RawIOBase.read(get_self(\"readall\", arguments))\n}\n\n// Base class for text streams.\n_TextIOBase = $B.make_class(\"_TextIOBase\")\n_TextIOBase.__mro__ = [_IOBase, _b_.object]\n\nvar StringIO = $B.make_class(\"StringIO\",\n    function(){\n        var $ = $B.args(\"StringIO\", 2, {value: null, newline: null},\n                [\"value\", \"newline\"], arguments, {value: '', newline: \"\\n\"},\n                null, null)\n        return {\n            __class__: StringIO,\n            $counter: 0,\n            $string: $.value\n        }\n    }\n)\nStringIO.__mro__ = [$B.Reader, _b_.object]\n\nStringIO.getvalue = function(){\n    var $ = $B.args(\"getvalue\", 1, {self: null},\n            [\"self\"], arguments, {}, null, null)\n    return $.self.$string\n}\n\nStringIO.write = function(){\n    var $ = $B.args(\"write\", 2, {self: null, data: null},\n            [\"self\", \"data\"], arguments, {}, null, null)\n    $.self.$string += $.data\n    $.self.$counter += $.data.length\n    return _b_.None\n}\n$B.set_func_names(StringIO, \"_io\")\n\nvar BytesIO = $B.make_class(\"BytesIO\",\n    function(){\n        var $ = $B.args(\"BytesIO\", 1, {value: null},\n                [\"value\"], arguments, {value: _b_.bytes.$factory()},\n                null, null)\n        return {\n            __class__: BytesIO,\n            $binary: true,\n            $bytes: $.value,\n            $counter: 0\n        }\n    }\n)\nBytesIO.__mro__ = [$B.Reader, _b_.object]\n\nBytesIO.getbuffer = function(){\n    var self = get_self(\"getbuffer\", arguments)\n    return self.$bytes\n}\n\nBytesIO.getvalue = function(){\n    var self = get_self(\"getvalue\", arguments)\n    return self.$bytes\n}\n\nBytesIO.write = function(){\n    var $ = $B.args(\"write\", 2, {self: null, data: null},\n            [\"self\", \"data\"], arguments, {}, null, null)\n    $.self.$bytes.source = $.self.$bytes.source.concat(\n        $.data.source)\n    $.self.$counter += $.data.source.length\n    return _b_.None\n}\n$B.set_func_names(BytesIO, \"_io\")\n\nvar $module = (function($B){\n    return {\n        _BufferedIOBase: _BufferedIOBase,\n        _IOBase: _IOBase,\n        _RawIOBase: _RawIOBase,\n        _TextIOBase: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BytesIO: BytesIO,\n        FileIO: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        StringIO: StringIO,\n        BufferedReader: $B.BufferedReader,\n        BufferedWriter: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BufferedRWPair: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BufferedRandom: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        IncrementalNewlineDecoder: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        TextIOWrapper: $B.TextIOWrapper\n    }\n})(__BRYTHON__)\n$module._IOBase.__doc__ = \"_IOBase\""], "_multiprocessing": [".js", "// multiprocessing\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar Process = {\n    __class__:_b_.type,\n    __mro__: [_b_.object],\n    $infos:{\n        __name__:'Process'\n    },\n    $is_class: true\n}\n\nvar $convert_args=function(args) {\n    var _list=[]\n    for(var i=0, _len_i = args.length; i < _len_i; i++) {\n      var _a=args[i]\n      if(isinstance(_a, str)){_list.push(\"'\"+_a+\"'\")} else {_list.push(_a)}\n    }\n\n    return _list.join(',')\n}\n\nProcess.is_alive = function(self){return self.$alive}\n\nProcess.join = function(self, timeout){\n   // need to block until process is complete\n   // could probably use a addEventListener to execute all existing code\n   // after this join statement\n\n   self.$worker.addEventListener('message', function (e) {\n        var data=e.data\n        if (data.stdout != '') { // output stdout from process\n           $B.stdout.write(data.stdout)\n        }\n   }, false);\n}\n\nProcess.run = function(self){\n   //fix me\n}\n\nProcess.start = function(self){\n   self.$worker.postMessage({target: self.$target,\n                             args: $convert_args(self.$args),\n                          //   kwargs: self.$kwargs\n                           })\n   self.$worker.addEventListener('error', function(e) { throw e})\n   self.$alive=true\n}\n\nProcess.terminate = function(self){\n   self.$worker.terminate()\n   self.$alive=false\n}\n\n// variables\n//name\n//daemon\n//pid\n//exitcode\n\nProcess. $factory = function(){\n    //arguments group=None, target=None, name=None, args=(), kwargs=()\n\n    var $ns=$B.args('Process',0,{},[],arguments,{},null,'kw')\n    var kw=$ns['kw']\n\n    var target=_b_.dict.get($ns['kw'],'target',None)\n    var args=_b_.dict.get($ns['kw'],'args',tuple.$factory())\n\n    var worker = new Worker('/src/web_workers/multiprocessing.js')\n\n    var res = {\n        __class__:Process,\n        $worker: worker,\n        name: $ns['name'] || None,\n        $target: target+'',\n        $args: args,\n        //$kwargs: $ns['kw'],\n        $alive: false\n    }\n    return res\n}\n\n$B.set_func_names(Process, \"multiprocessing\")\n\nvar Pool = $B.make_class(\"Pool\")\n\nPool.__enter__ = function(self){}\nPool.__exit__ = function(self){}\n\nPool.__str__ = Pool.toString = Pool.__repr__=function(self){\n   return '<object Pool>'\n}\n\nPool.map = function(){\n\n   var $ns=$B.args('Pool.map', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func=$ns['func']\n   var fargs=$ns['fargs']\n\n   var _results=[]\n\n   fargs=iter(fargs)\n\n   var _pos=0\n   console.log(self.$processes)\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{arg=getattr(fargs, '__next__')()}\n       catch(err) {\n          if (err.__class__ !== _b_.StopIteration) throw err\n       }\n       console.log(arg)\n       _workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           _results[e.data.pos]=e.data.result\n           if (_results.length == args.length) return _results\n\n           try {\n               arg=getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration) throw err\n               this.finished=true\n           }\n       }, false);\n   }\n}\n\nPool.apply_async = function(){\n\n   var $ns=$B.$MakeArgs('apply_async', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func=$ns['func']\n   var fargs=$ns['fargs']\n\n   fargs=iter(fargs)\n\n   async_result = {}\n   async_result.get=function(timeout){\n                      console.log(results)\n                      console.log(fargs)\n                      return this.results}\n   async_result.results=[]\n\n   var _pos=0\n\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{arg=getattr(fargs, '__next__')()}\n       catch(err) {\n          if (err.__class__ !== _b_.StopIteration) throw err\n       }\n       //console.log(arg)\n       //_workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           async_result.results[e.data.pos]=e.data.result\n           //if (_results.length == args.length) return _results\n\n           try {\n               arg=getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration) throw err\n               this.finished=true\n           }\n       }, false);\n   }\n\n   console.log(\"return\", async_result)\n   return async_result\n}\n\nPool.$factory = function(){\n    console.log(\"pool\")\n    console.log(arguments)\n    var $ns=$B.args('Pool',1,\n        {processes:null},['processes'],arguments,{},'args','kw')\n    //var kw=$ns['kw']\n\n    var processes=$ns['processes']\n\n    if (processes == None) {\n       // look to see if we have stored cpu_count in local storage\n       // maybe we should create a brython config file with settings,etc..??\n\n       // if not there use a tool such as Core Estimator to calculate number of cpu's\n       // http://eligrey.com/blog/post/cpu-core-estimation-with-javascript\n    }\n\n    console.log(processes)\n    var res = {\n        __class__:Pool,\n        $processes:processes\n    }\n    return res\n}\n\n$B.set_func_names(Pool, \"multiprocessing\")\n\nreturn {Process:Process, Pool:Pool}\n\n})(__BRYTHON__)\n"], "builtins": [".js", "var $module = (function(){\n    var obj = {\n        __class__: __BRYTHON__.module,\n        __name__: 'builtins'\n    },\n        builtin_names = ['ArithmeticError', 'AssertionError', 'AttributeError',\n    'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError',\n    'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',\n    'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError',\n    'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception',\n    'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n    'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning',\n    'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError',\n    'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError',\n    'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError',\n    'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError',\n    'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError',\n    'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning',\n    'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n    'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n    'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n    'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_',\n    '__build_class__', '__debug__', '__doc__', '__import__', '__name__',\n    '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray',\n    'bytes','callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright',\n    'credits','delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec',\n    'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals',\n    'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance',\n    'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max',\n    'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print',\n    'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr',\n    'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type',\n    'vars', 'zip',\n    '__newobj__' // defined in py_objects.js ; required for pickle\n    ]\n    for(var i = 0, len = builtin_names.length; i < len; i++){\n        try{eval(\"obj['\" + builtin_names[i] + \"'] = __BRYTHON__.builtins.\" +\n            builtin_names[i])}\n        catch(err){if (__BRYTHON__.$debug) {console.log(err)}}\n    }\n    return obj\n})()\n"], "marshal": [".js", "var $module = (function($B){\n\nreturn  {\n    loads : function(){\n        var $ = $B.args('loads', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return $B.structuredclone2pyobj(JSON.parse($.obj))\n    },\n    load : function(){\n        var $ = $B.args('load', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return $module.loads(obj.$content);\n    },\n    dumps : function(){\n        var $ = $B.args('dumps', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return JSON.stringify($B.pyobj2structuredclone($.obj))\n    },\n}\n\n})(__BRYTHON__)\n"], "modulefinder": [".js", "var $module=(function($B){\n\nvar _b_=$B.builtins\nvar _mod = {}\n\n$ModuleFinderDict = {__class__:_b_.type,__name__:'ModuleFinder'}\n$ModuleFinderDict.__mro__ = [_b_.object]\n\n$ModuleFinderDict.run_script = function(self, pathname){\n    // pathname is the url of a Python script\n    var py_src = _b_.$open(pathname).read()\n    // transform into internal Brython tree structure\n    var root = $B.py2js(py_src)\n    // walk the tree to find occurences of imports\n    function walk(node){\n        var modules = []\n        var ctx = node.context\n        if(ctx && ctx.type=='node'){ctx = ctx.tree[0]}\n\n        if(ctx && ctx.type==\"import\"){\n            for(var i=0, _len_i = ctx.tree.length; i < _len_i;i++){\n                if(modules.indexOf(ctx.tree[i].name)==-1){\n                    modules.push(ctx.tree[i].name)\n                }\n            }\n        }else if(ctx && ctx.type==\"from\"){\n            if(modules.indexOf(ctx.module)==-1){\n                modules.push(ctx.module)\n            }\n        }\n        \n        for(var i=0, _len_i = node.children.length; i < _len_i;i++){\n            mods = walk(node.children[i])\n            for(var j=0, _len_j = mods.length; j < _len_j;j++){\n                if(modules.indexOf(mods[j])==-1){modules.push(mods[j])}\n            }\n        }\n        return modules\n    }\n    self.modules = walk(root)\n}\n\n_mod.ModuleFinder = function(){return {__class__:$ModuleFinderDict}\n}\n_mod.ModuleFinder.$dict = $ModuleFinderDict\n_mod.ModuleFinder.__class__ = $B.$factory\n$ModuleFinderDict.$factory = _mod.ModuleFinder\n\nreturn _mod\n})(__BRYTHON__)\n"], "_json": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nfunction simple(obj){\n    switch(typeof obj){\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return true\n    }\n    if(obj instanceof Number ||\n            Array.isArray(obj) ||\n            _b_.isinstance(obj, [_b_.list, _b_.tuple, _b_.dict])){\n        return true\n    }\n    return false\n}\n\nfunction to_json(obj, level){\n    var $defaults = {skipkeys:_b_.False, ensure_ascii:_b_.True,\n            check_circular:_b_.True, allow_nan:_b_.True, cls:_b_.None,\n            indent:_b_.None, separators:_b_.None, \"default\":_b_.None,\n            sort_keys:_b_.False},\n        $ = $B.args(\"to_json\", 2, {obj: null, level: null}, ['obj', 'level'],\n                    arguments, {level: 1}, null, \"kw\"),\n        kw = $.kw.$string_dict\n\n    for(key in $defaults){\n        if(kw[key] === undefined){\n            kw[key] = $defaults[key]\n        }else{\n            kw[key] = kw[key][0]\n        }\n    }\n\n    var indent = kw.indent,\n        ensure_ascii = kw.ensure_ascii,\n        separators = kw.separators === _b_.None ?\n             kw.indent === _b_.None ? [', ', ': '] : [',', ': '] :\n            kw.separators,\n        skipkeys = kw.skipkeys,\n        $$default = kw.default,\n        sort_keys = kw.sort_keys,\n        allow_nan = kw.allow_nan,\n        check_circular = kw.check_circular\n    var item_separator = separators[0],\n        key_separator = separators[1]\n    if(indent !== _b_.None){\n        var indent_str\n        if(typeof indent == \"string\"){\n            indent_str = indent\n        }else if(typeof indent == \"number\" && indent >= 1){\n            indent_str = \" \".repeat(indent)\n        }else{\n            throw _b_.ValueError.$factory(\"invalid indent: \" +\n                _b_.str.$factory(indent))\n        }\n    }\n    var kwarg = {$nat: \"kw\", kw: {}}\n    for(var key in kw){\n        kwarg.kw[key] = kw[key]\n    }\n    switch(typeof obj){\n        case 'string':\n            var res = JSON.stringify(obj)\n            if(ensure_ascii){\n                var escaped = ''\n                for(var i = 0, len = res.length; i < len; i++){\n                    var u = res.codePointAt(i)\n                    if(u > 127){\n                        u = u.toString(16)\n                        while(u.length < 4){\n                            u = \"0\" + u\n                        }\n                        escaped += '\\\\u' + u\n                    }else{\n                        escaped += res.charAt(i)\n                    }\n                }\n                return escaped\n            }\n            return res\n        case 'boolean':\n            return obj.toString()\n        case 'number':\n            if([Infinity, -Infinity].indexOf(obj) > -1 ||\n                    isNaN(obj)){\n                if(! allow_nan){\n                    throw _b_.ValueError.$factory(\n                        'Out of range float values are not JSON compliant')\n                }\n            }\n            return obj.toString()\n    }\n    if(_b_.isinstance(obj, _b_.list)){\n        var res = []\n        var sep = item_separator,\n            first = '[',\n            last = ']'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '[' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + ']'\n            level++\n        }\n        for(var i = 0, len = obj.length; i < len; i++){\n            res.push(to_json(obj[i], level, kwarg))\n        }\n        return first + res.join(sep) + last\n    }else if(obj instanceof Number){\n        return obj.valueOf()\n    }else if(obj === _b_.None){\n        return \"null\"\n    }else if(_b_.isinstance(obj, _b_.dict)){\n        var res = [],\n            items = $B.dict_to_list(obj)\n        if(sort_keys){\n            // Sort keys by alphabetical order\n            items.sort()\n        }\n        var sep = item_separator,\n            first = '{',\n            last = '}'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '{' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + '}'\n            level++\n        }\n        for(var i = 0, len = items.length; i < len; i++){\n            var item = items[i]\n            if(! simple(item[0])){\n                if(! skipkeys){\n                    throw _b_.TypeError.$factory(\"keys must be str, int, \" +\n                        \"float, bool or None, not \" + $B.class_name(obj))\n                }\n            }else{\n                // In the result, key must be a string\n                var key = _b_.str.$factory(item[0])\n                // Check circular reference\n                if(check_circular && $B.repr.enter(item[1])){\n                    throw _b_.ValueError.$factory(\"Circular reference detected\")\n                }\n                res.push(\n                    [to_json(key, level, kwarg), to_json(item[1], level, kwarg)].\n                    join(key_separator))\n                if(check_circular){\n                    $B.repr.leave(item[1])\n                }\n            }\n        }\n        return first + res.join(sep) + last\n    }\n    // For other types, use function default if provided\n    if($$default == _b_.None){\n        throw _b_.TypeError.$factory(\"Object of type \" + $B.class_name(obj) +\n            \" is not JSON serializable\")\n    }else{\n        return to_json($B.$call($$default)(obj), level, kwarg)\n    }\n}\n\nfunction from_json(s){\n    var $defaults = {cls: _b_.None, object_hook: _b_.None,\n            parse_float: _b_.None, parse_int: _b_.None,\n            parse_constant: _b_.None, object_pairs_hook: _b_.None},\n        $ = $B.args(\"from_json\", 1, {s: null}, ['s'], arguments, {},\n            null, \"kw\"),\n        kw = $.kw.$string_dict\n    if(Object.keys(kw).length == 0){\n        // default\n        return $B.structuredclone2pyobj(JSON.parse(s))\n    }\n    for(key in $defaults){\n        if(kw[key] === undefined){\n            kw[key] = $defaults[key]\n        }else{\n            kw[key] = kw[key][0]\n        }\n    }\n\n    function reviver(key, value){\n        if(typeof value == \"number\"){\n            if(Number.isInteger(value) && kw.parse_int !== _b_.None){\n                return $B.$call(kw.parse_int)(value.toString())\n            }else if(! Number.isInteger(value) && kw.parse_float !== _b_.None){\n                return $B.$call(kw.parse_float)(value.toString())\n            }else if((value === Infinity || value === -Infinity) &&\n                    kw.parse_constant !== _b_.None){\n                return $B.$call(kw.parse_constant)(value)\n            }else{\n                return value\n            }\n        }else if(isNaN(value) && kw.parse_constant !== _b_.None){\n            return $B.$call(kw.parse_constant)(value)\n        }else if(typeof value == \"object\" && !Array.isArray(value) &&\n                (kw.object_hook !== _b_.None ||\n                    kw.object_pairs_hook !== _b_.None)){\n            // Apply Python function object_hook to the Python dictionary\n            // built from the Javascript object \"value\"\n            var py_dict = $B.structuredclone2pyobj(value)\n            if(kw.object_pairs_hook === _b_.None){\n                var res = $B.$call(kw.object_hook)(py_dict)\n            }else{\n                var items = $B.dict_to_list(py_dict),\n                    res = $B.$call(kw.object_pairs_hook)(items)\n            }\n            // Transform the result of the Python function to a Javascript\n            // object\n            return $B.pyobj2structuredclone(res)\n        }else{\n            return value\n        }\n    }\n\n    return $B.structuredclone2pyobj(JSON.parse(s, reviver))\n}\n\nreturn {\n    dumps: function(){\n        return _b_.str.$factory(to_json.apply(null, arguments))\n    },\n    loads: from_json\n}\n\n})(__BRYTHON__)"], "long_int": [".js", "/*\nModule to manipulate long integers\n*/\n\nvar $module=(function($B){\n\neval($B.InjectBuiltins())\n\nvar $LongIntDict = {__class__:$B.$type,__name__:'LongInt'}\n\nfunction add_pos(v1, v2){\n    // Add two positive numbers\n    // v1, v2 : strings\n    // Return an instance of LongInt\n\n    var res = '', carry = 0, iself=v1.length, sv=0\n    for(var i=v2.length-1;i>=0;i--){\n        iself--\n        if(iself<0){sv=0}else{sv=parseInt(v1.charAt(iself))}\n        x = (carry+sv+parseInt(v2.charAt(i))).toString()\n        if(x.length==2){res=x.charAt(1)+res;carry=parseInt(x.charAt(0))}\n        else{res=x+res;carry=0}\n    }\n    while(iself>0){\n        iself--\n        x = (carry+parseInt(v1.charAt(iself))).toString()\n        if(x.length==2){res=x.charAt(1)+res;carry=parseInt(x.charAt(0))}\n        else{res=x+res;carry=0}\n    }\n    if(carry){res=carry+res}        \n    return {__class__:$LongIntDict, value:res, pos:true}\n}\n\nfunction check_shift(shift){\n    // Check the argument of >> and <<\n    if(!isinstance(shift, LongInt)){\n        throw TypeError(\"shift must be LongInt, not '\"+\n            $B.get_class(shift).__name__+\"'\")\n    }\n    if(!shift.pos){throw ValueError(\"negative shift count\")}\n}\n\nfunction clone(obj){\n    // Used for traces\n    var obj1 = {}\n    for(var attr in obj){obj1[attr]=obj[attr]}\n    return obj1\n}\n\nfunction comp_pos(v1, v2){\n    // Compare two positive numbers\n    if(v1.length>v2.length){return 1}\n    else if(v1.length<v2.length){return -1}\n    else{\n        if(v1>v2){return 1}\n        else if(v1<v2){return -1}\n    }\n    return 0\n}\n\nfunction divmod_pos(v1, v2){\n    // v1, v2 : strings, represent 2 positive integers A and B\n    // Return [a, b] where a and b are instances of LongInt\n    // a = A // B, b = A % B\n    var v1_init = v1, quotient, mod\n    if(comp_pos(v1, v2)==-1){ // a < b\n        quotient='0'\n        mod = LongInt(v1)\n    }else if(v2==v1){ // a = b\n        quotient = '1';\n        mod = LongInt('0')\n    }else{\n        var quotient = '', v1_init = v1\n        var left = v1.substr(0, v2.length)\n        if(v1<v2){left = v1.substr(0, v2.length+1)}\n        var right = v1.substr(left.length)\n        // mv2 maps integers i from 2 to 9 to i*v2, used as a cache to avoid\n        // having to compute i*v2 each time\n        var mv2 = {}\n        // Javascript \"safe integer\" with the 15 first digits in v2,\n        // used in the algorithm to test candidate values\n        var jsv2 = parseInt(v2.substr(0,15))\n\n        // Division algorithm\n        // At each step in the division, v1 is split into substrings\n        // \"left\" is the left part, with the same length as v2\n        // \"rest\" is the rest of v1 after \"left\"\n        // The algorithm finds the one-digit integer \"candidate\" such\n        // that 0 <= left - candidate*v2 < v2\n        // It stops when right is empty\n        while(true){\n            // Uses JS division to test an approximate result\n            var jsleft = parseInt(left.substr(0,15))\n            var candidate = Math.floor(jsleft/jsv2).toString()\n\n            // Check that candidate is the correct result\n            // Start by computing candidate*v2 : for this, use the table\n            // mv2, which stores the multiples of v2 already calculated\n            if(mv2[candidate]===undefined){\n                mv2[candidate] = mul_pos(v2, candidate).value\n            }\n            if(comp_pos(left, mv2[candidate])==-1){\n                // If left < candidate * v2, use candidate-1\n                candidate--\n                if(mv2[candidate]===undefined){\n                    mv2[candidate] = mul_pos(v2, candidate).value\n                }\n            }\n\n            // Add candidate to the quotient\n            quotient += candidate\n\n            // New value for left : left - v2*candidate\n            left = sub_pos(left, mv2[candidate]).value\n\n            // Stop if all digits in v1 have been used\n            if(right.length==0){break}\n\n            // Else, add next digit to left and remove it from right\n            left += right.charAt(0)\n            right = right.substr(1)\n        }\n        // Modulo is A - (A//B)*B\n        mod = sub_pos(v1, mul_pos(quotient, v2).value)\n    }\n    return [LongInt(quotient), mod]\n}\n\nfunction mul_pos(v1, v2){\n    // Multiply positive numbers v1 by v2\n    // Make v2 smaller than v1\n    if(v1.length<v2.length){var a=v1; v1=v2 ; v2=a}\n    if(v2=='0'){return LongInt('0')}\n    var cols = {}, i=v2.length, j\n    \n    // Built the object \"cols\", indexed by integers from 1 to nb1+nb2-2\n    // where nb1 and nb2 are the number of digits in v1 and v2.\n    // cols[n] is the sum of v1[i]*v2[j] for i+j = n\n    \n    while(i--){\n        var car = v2.charAt(i)\n        if(car==\"0\"){\n            j = v1.length\n            while(j--){\n                if(cols[i+j]===undefined){cols[i+j]=0}\n            }        \n        }else if(car==\"1\"){\n            j = v1.length\n            while(j--){\n                var z = parseInt(v1.charAt(j))\n                if(cols[i+j]===undefined){cols[i+j]=z}\n                else{cols[i+j] += z}\n            }\n        }else{\n            var x = parseInt(car), j = v1.length, y, z\n            while(j--){\n                y = x * parseInt(v1.charAt(j))\n                if(cols[i+j]===undefined){cols[i+j]=y}\n                else{cols[i+j] += y}\n            }\n        }\n    }\n\n    // Transform cols so that cols[x] is a one-digit integers\n    i = v1.length+v2.length-1\n    while(i--){\n        var col = cols[i].toString()\n        if(col.length>1){\n            // If the value in cols[i] has more than one digit, only keep the\n            // last one and report the others at the right index\n            // For instance if cols[i] = 123, keep 3 in cols[i], add 2 to\n            // cols[i-1] and 1 to cols[i-2]\n            cols[i] = parseInt(col.charAt(col.length-1))\n            j = col.length\n            while(j-->1){\n                var report = parseInt(col.charAt(j-1))\n                var pos = i-col.length+j\n                if(cols[pos]===undefined){cols[pos]=report}\n                else{cols[pos] += report}\n            }\n        }\n    }\n\n    // Find minimum index in cols\n    // The previous loop may have introduced negative indices\n    var imin\n    for(var attr in cols){\n        i = parseInt(attr)\n        if(imin===undefined){imin=i}\n        else if(i<imin){imin=i}\n    }\n\n    // Result is the concatenation of digits in cols\n    var res = ''\n    for(var i=imin;i<=v1.length+v2.length-2;i++){res+=cols[i].toString()}\n    return LongInt(res)\n}\n\nfunction sub_pos(v1, v2){\n    // Substraction of positive numbers with v1>=v2\n\n    var res = '', carry = 0, i1=v1.length, sv=0\n    \n    // For all digits in v2, starting by the rightmost, substract it from\n    // the matching digit in v1\n    // This is the equivalent of the manual operation :\n    //    12345678\n    //   -   98765\n    //\n    // We begin by the rightmost operation : 8-5 (3, no carry),\n    // then 7-6 (1, no carry)\n    // then 6-7 (9, carry 1) and so on\n    for(var i=v2.length-1;i>=0;i--){\n        i1--\n        sv = parseInt(v1.charAt(i1))\n        x = (sv-carry-parseInt(v2.charAt(i)))\n        if(x<0){res=(10+x)+res;carry=1}\n        else{res=x+res;carry=0}\n    }\n    \n    // If there are remaining digits in v1, substract the carry, if any\n    while(i1>0){\n        i1--\n        x = (parseInt(v1.charAt(i1))-carry)\n        if(x<0){res=(10+x)+res;carry=1}\n        else{res=x+res;carry=0}\n    }\n\n    // Remove leading zeros and return the result\n    while(res.charAt(0)=='0' && res.length>1){res=res.substr(1)}\n    return {__class__:$LongIntDict, value:res, pos:true}\n}\n\n// Special methods to implement operations on instances of LongInt\n\n$LongIntDict.__abs__ = function(self){\n    return {__class__:$LongIntDict, value: self.value, pos:true}\n}\n\n$LongIntDict.__add__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    // Addition of \"self\" and \"other\"\n    // If both have the same sign (+ or -) we add their absolute values\n    // If they have different sign we use the substraction of their\n    // absolute values\n    var res\n    if(self.pos&&other.pos){  // self > 0, other > 0\n        return add_pos(self.value, other.value)\n    }else if(!self.pos&&!other.pos){ // self < 0, other < 0\n        res = add_pos(self.value, other.value)\n        res.pos = false\n        return res\n    }else if(self.pos && !other.pos){ // self > 0, other < 0\n        switch (comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:0, pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                res.pos = false\n                break\n        }\n        return res\n    }else{ // self < 0, other > 0\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                res.pos = false\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:0, pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                break\n        }\n        return res\n    }\n}\n\n$LongIntDict.__and__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    // Bitwise \"and\" : build the binary representation of self and other\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    // apply \"and\" on zeros and ones\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = ''\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' && v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    // Return the LongInt instance represented by res in base 2\n    return LongInt(res, 2)\n}\n\n$LongIntDict.__divmod__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n\n    var dm = divmod_pos(self.value, other.value)\n    if(self.pos!==other.pos){\n        if(dm[0].value!='0'){dm[0].pos = false}\n        if(dm[1].value!='0'){\n            // If self and other have different signs and self is not a multiple\n            // of other, round to the previous integer\n            dm[0] = $LongIntDict.__sub__(dm[0], LongInt('1'))\n            dm[1] = $LongIntDict.__add__(dm[1], LongInt('1'))\n        }\n    }\n    return dm    \n}\n\n$LongIntDict.__eq__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    return self.value==other.value && self.pos==other.pos\n}\n\n$LongIntDict.__floordiv__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    return $LongIntDict.__divmod__(self, other)[0]\n}\n\n$LongIntDict.__ge__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    if(self.value.length>other.value.length){return true}\n    else if(self.value.length<other.value.length){return false}\n    else{return self.value >= other.value}\n}\n\n$LongIntDict.__gt__ = function(self, other){\n    return !$LongIntDict.__le__(self, other)\n}\n\n$LongIntDict.__index__ = function(self){\n    // Used by bin()\n    // returns a string with the binary value of self\n    // The algorithm computes the result of the floor division of self by 2\n    \n    // XXX to do : negative integers\n    \n    var res = '', pos=self.value.length,\n        temp = self.value, d\n    while(true){\n        d = divmod_pos(temp, '2')\n        res = d[1].value + res\n        temp = d[0].value\n        if(temp=='0'){break}\n    }\n    return res\n}\n\n$LongIntDict.__invert__ = function(self){\n    var bin = $LongIntDict.__index__(self)\n    var res = ''\n    for(var i=0;i<bin.length;i++){\n        res += bin.charAt(i)=='0' ? '1' : '0'\n    }\n    return LongInt(res, 2)\n}\n\n$LongIntDict.__le__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    if(self.value.length>other.value.length){return false}\n    else if(self.value.length<other.value.length){return true}\n    else{return self.value <= other.value}\n}\n\n$LongIntDict.__lt__ = function(self, other){\n    return !$LongIntDict.__ge__(self, other)\n}\n\n$LongIntDict.__lshift__ = function(self, shift){\n    check_shift(shift)\n    var res = self.value\n    while(true){\n        var x, carry=0, res1=''\n        for(var i=res.length-1;i>=0;i--){\n            x = (carry+parseInt(res.charAt(i))*2).toString()\n            if(x.length==2){res1=x.charAt(1)+res1;carry=parseInt(x.charAt(0))}\n            else{res1=x+res1;carry=0}\n        }\n        if(carry){res1=carry+res1}\n        res=res1\n        shift = sub_pos(shift.value, '1')\n        if(shift.value=='0'){break}\n    }\n    return {__class__:$LongIntDict, value:res, pos:self.pos}\n}\n\n$LongIntDict.__mod__ = function(self, other){\n    return $LongIntDict.__divmod__(self, other)[1]\n}\n\n$LongIntDict.__mro__ = [_b_.object]\n\n$LongIntDict.__mul__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    var res = mul_pos(self.value, other.value)\n    if(self.pos==other.pos){return res}\n    res.pos = false\n    return res\n}\n\n$LongIntDict.__neg__ = function(obj){\n    return {__class__:$LongIntDict, value:obj.value, pos:!obj.pos}\n}\n\n$LongIntDict.__or__ = function(self, other){\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = v1.substr(0, start)\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' || v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    return LongInt(res, 2)\n}\n\n\n$LongIntDict.__pow__ = function(self, power){\n    if (typeof power == \"number\") {\n        power=LongInt(_b_.str.$factory(power))\n    }else if(!isinstance(power, LongInt)){\n        var msg = \"power must be a LongDict, not '\"\n        throw TypeError(msg+$B.get_class(power).__name__+\"'\")\n    }\n    if(!power.pos){\n        if(self.value=='1'){return self}\n        // For all other integers, x**-n is 0\n        return LongInt('0')\n    }else if(power.value=='0'){\n        return LongInt('1')\n    }\n    var res = {__class__:$LongIntDict, value:self.value, pos:self.pos}\n    var pow = power.value\n    while(true){\n        pow = sub_pos(pow, '1').value\n        if(pow == '0'){break}\n        res = $LongIntDict.__mul__(res, self)\n    }\n    return res    \n}\n\n$LongIntDict.__rshift__ = function(self, shift){\n    check_shift(shift)\n    var res = self.value\n    while(true){\n        res = divmod_pos(res, '2')[0].value\n        if(res.value=='0'){break}\n        shift = sub_pos(shift.value, '1')\n        if(shift.value=='0'){break}\n    }\n    return {__class__:$LongIntDict, value:res, pos:self.pos}\n}\n\n$LongIntDict.__str__ = $LongIntDict.__repr__ = function(self){\n    var res = \"LongInt('\"\n    if(!self.pos){res += '-'}\n    return res+self.value+\"')\"\n}\n\n$LongIntDict.__sub__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    var res\n    if(self.pos && other.pos){\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:'0', pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                res.pos = false\n                break\n        }\n        return res\n    }else if(!self.pos && !other.pos){\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                res.pos = false\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:'0', pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                break\n        }\n        return res\n    }else if(self.pos && !other.pos){\n        return add_pos(self.value, other.value)\n    }else{\n        res = add_pos(self.value, other.value)\n        res.pos = false\n        return res\n    }\n}\n\n$LongIntDict.__xor__ = function(self, other){\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = v1.substr(0, start)\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' && v2.charAt(i)=='0'){res += '1'}\n        else if(v1.charAt(start+i)=='0' && v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    return LongInt(res, 2)\n}\n\n$LongIntDict.to_base = function(self, base){\n    // Returns the string representation of self in specified base\n    var res='', v=self.value\n    while(v>0){\n        var dm = divmod_pos(v, base.toString())\n        res = parseInt(dm[1].value).toString(base)+res\n        v = dm[0].value\n        if(v==0){break}\n    }\n    return res\n}\n\nfunction digits(base){\n    // Return an object where keys are all the digits valid in specified base\n    // and value is \"true\"\n    // Used to test if the string passed as first argument to LongInt is valid\n    var is_digits = {}\n    // Number from 0 to base, or from 0 to 9 if base > 10\n    for(var i=0;i<base;i++){\n        if(i==10){break}\n        is_digits[i]=true\n    }\n    if(base>10){\n        // Additional letters\n        // For instance in base 16, add \"abcdefABCDEF\" as keys\n        for(var i=0;i<base-10;i++){\n            is_digits[String.fromCharCode(65+i)]=true\n            is_digits[String.fromCharCode(97+i)]=true\n        }\n    }\n    return is_digits\n}\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53)-1;\nvar MIN_SAFE_INTEGER = -Number.MAX_SAFE_INTEGER;\n\nfunction isSafeInteger(n) {\n    return (typeof n === 'number' &&\n        Math.round(n) === n &&\n        Number.MIN_SAFE_INTEGER <= n &&\n        n <= Number.MAX_SAFE_INTEGER);\n}\n\nfunction LongInt(value, base){\n    if(arguments.length>2){\n        throw _b_.TypeError(\"LongInt takes at most 2 arguments (\"+\n            arguments.length+\" given)\")\n    }\n    // base defaults to 10\n    if(base===undefined){base = 10}\n    else if(!isinstance(base, int)){\n        throw TypeError(\"'\"+$B.get_class(base).__name__+\"' object cannot be interpreted as an integer\")\n    }\n    if(base<0 || base==1 || base>36){\n        throw ValueError(\"LongInt() base must be >= 2 and <= 36\")\n    }\n    if(isinstance(value, float)){\n        if(value>=0){value=Math.round(value.value)}\n        else{value=Math.ceil(value.value)}\n    }\n    if(typeof value=='number'){\n        if(isSafeInteger(value)){value = value.toString()}\n        else{throw ValueError(\"argument of long_int is not a safe integer\")}\n    }else if(typeof value!='string'){\n        throw ValueError(\"argument of long_int must be a string, not \"+\n            $B.get_class(value).__name__)\n    }\n    var has_prefix = false, pos = true, start = 0\n    // Strip leading and trailing whitespaces\n    while(value.charAt(0)==' ' && value.length){value = value.substr(1)}\n    while(value.charAt(value.length-1)==' ' && value.length){\n        value = value.substr(0, value.length-1)\n    }\n    // Check if string starts with + or -\n    if(value.charAt(0)=='+'){has_prefix=true}\n    else if(value.charAt(0)=='-'){has_prefix=true;pos=false}\n    if(has_prefix){\n        // Remove prefix\n        if(value.length==1){\n            // \"+\" or \"-\" alone are not valid arguments\n            throw ValueError('LongInt argument is not a valid number: \"'+value+'\"')\n        }else{value=value.substr(1)}\n    }\n    // Ignore leading zeros\n    while(start<value.length-1 && value.charAt(start)=='0'){start++}\n    value = value.substr(start)\n\n    // Check if all characters in value are valid in the base\n    var is_digits = digits(base), point = -1\n    for(var i=0;i<value.length;i++){\n        if(value.charAt(i)=='.' && point==-1){point=i}\n        else if(!is_digits[value.charAt(i)]){\n            throw ValueError('LongInt argument is not a valid number: \"'+value+'\"')\n        }\n    }\n    if(point!=-1){value=value.substr(0,point)}\n    if(base!=10){\n        // Conversion to base 10\n        var coef = '1', v10 = LongInt(0),\n            pos = value.length, digit_base10\n        while(pos--){\n            digit_base10 = parseInt(value.charAt(pos), base).toString()\n            digit_by_coef = mul_pos(coef, digit_base10).value\n            v10 = add_pos(v10.value, digit_by_coef)\n            coef = mul_pos(coef, base.toString()).value\n        }\n        return v10\n    }\n    return {__class__:$LongIntDict, value:value, pos:pos}\n}\n\nLongInt.__class__ = $B.$factory\nLongInt.$dict = $LongIntDict\n$LongIntDict.$factory = LongInt\n\nreturn {LongInt:LongInt}\n\n})(__BRYTHON__)\n"], "hashlib": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nvar $s = []\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\nvar $mod = {\n\n    __getattr__ : function(attr){\n        if(attr == 'new'){return hash.$factory}\n        return this[attr]\n    },\n    md5: function(obj){return hash.$factory('md5', obj)},\n    sha1: function(obj){return hash.$factory('sha1', obj)},\n    sha224: function(obj){return hash.$factory('sha224', obj)},\n    sha256: function(obj){return hash.$factory('sha256', obj)},\n    sha384: function(obj){return hash.$factory('sha384', obj)},\n    sha512: function(obj){return hash.$factory('sha512', obj)},\n\n    algorithms_guaranteed: ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    algorithms_available:  ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']\n}\n\n//todo: eventually move this function to a \"utility\" file or use ajax module?\nfunction $get_CryptoJS_lib(alg){\n    if($B.VFS !== undefined && $B.VFS.hashlib){\n        // use file in brython_stdlib.js\n        var lib = $B.VFS[\"crypto_js.rollups.\" + alg]\n        if (lib === undefined){\n            throw _b_.ImportError.$factory(\"can't import hashlib.\" + alg)\n        }\n        var res = lib[1]\n        try{\n            eval(res + \"; $B.CryptoJS = CryptoJS;\")\n            return\n        }catch(err){\n            throw Error(\"JS Eval Error\",\n                \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n        }\n    }\n\n    var module = {__name__: 'CryptoJS', $is_package: false}\n    var res = $B.$download_module(module, $B.brython_path + 'libs/crypto_js/rollups/' + alg + '.js');\n\n    try{\n        eval(res + \"; $B.CryptoJS = CryptoJS;\")\n    }catch(err){\n        throw Error(\"JS Eval Error\",\n            \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n    }\n}\n\nfunction bytes2WordArray(obj){\n    // Transform a bytes object into an instance of class WordArray\n    // defined in CryptoJS\n    if(!_b_.isinstance(obj, _b_.bytes)){\n        throw _b_.TypeError(\"expected bytes, got \" + $B.class_name(obj))\n    }\n\n    var words = []\n    for(var i = 0; i < obj.source.length; i += 4){\n        var word = obj.source.slice(i, i + 4)\n        while(word.length < 4){word.push(0)}\n        var w = word[3] + (word[2] << 8) + (word[1] << 16) + (word[0] << 24)\n        words.push(w)\n    }\n    return {words: words, sigBytes: obj.source.length}\n}\n\nvar hash = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n    $infos:{\n        __name__: 'hash'\n    }\n}\n\nhash.update = function(self, msg){\n    self.hash.update(bytes2WordArray(msg))\n}\n\nhash.copy = function(self){\n    return self.hash.clone()\n}\n\nhash.digest = function(self){\n    var obj = self.hash.clone().finalize().toString(),\n        res = []\n    for(var i = 0; i < obj.length; i += 2){\n        res.push(parseInt(obj.substr(i, 2), 16))\n    }\n    return _b_.bytes.$factory(res)\n}\n\nhash.hexdigest = function(self) {\n    return self.hash.clone().finalize().toString()\n}\n\nhash.$factory = function(alg, obj) {\n    var res = {\n        __class__: hash\n    }\n\n    switch(alg) {\n      case 'md5':\n      case 'sha1':\n      case 'sha224':\n      case 'sha256':\n      case 'sha384':\n      case 'sha512':\n        var ALG = alg.toUpperCase()\n        if($B.Crypto === undefined ||\n            $B.CryptoJS.algo[ALG] === undefined){$get_CryptoJS_lib(alg)}\n\n        res.hash = $B.CryptoJS.algo[ALG].create()\n        if(obj !== undefined){\n            res.hash.update(bytes2WordArray(obj))\n        }\n        break\n      default:\n        throw $B.builtins.AttributeError.$factory('Invalid hash algorithm: ' + alg)\n    }\n\n    return res\n}\n\nreturn $mod\n\n})(__BRYTHON__)\n"], "_warnings": [".js", "var $module = (function($B){\n\n_b_ = $B.builtins\n\nreturn  {\n    __doc__: \"_warnings provides basic warning filtering support.\\n \" +\n        \"It is a helper module to speed up interpreter start-up.\",\n\n    default_action: \"default\",\n\n    filters: [\n        ['ignore', _b_.None, _b_.DeprecationWarning, _b_.None, 0],\n        ['ignore', _b_.None, _b_.PendingDeprecationWarning, _b_.None, 0],\n        ['ignore', _b_.None, _b_.ImportWarning, _b_.None, 0],\n        ['ignore', _b_.None, _b_.BytesWarning, _b_.None, 0]].map(\n            function(x){return _b_.tuple.$factory(x)}),\n\n    once_registry: $B.empty_dict(),\n\n    warn: function(){},\n\n    warn_explicit: function(){}\n\n}\n\n})(__BRYTHON__)\n"], "_webcomponent": [".js", "// module for Web Components\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nfunction define(tag_name, cls){\n    var $ = $B.args(\"define\", 2, {tag_name: null, cls: null},\n            [\"tag_name\", \"cls\"], arguments, {}, null, null),\n        tag_name = $.tag_name,\n        cls = $.cls\n    if(typeof tag_name != \"string\"){\n        throw _b_.TypeError.$factory(\"first argument of define() \" +\n            \"must be a string, not '\" + $B.class_name(tag_name) + \"'\")\n    }else if(tag_name.indexOf(\"-\") == -1){\n        throw _b_.ValueError.$factory(\"custom tag name must \" +\n            \"contain a hyphen (-)\")\n    }\n    if(!_b_.isinstance(cls, _b_.type)){\n        throw _b_.TypeError.$factory(\"second argument of define() \" +\n            \"must be a class, not '\" + $B.class_name(tag_name) + \"'\")\n    }\n\n    // Create the Javascript class used for the component. It must have\n    // the same name as the Python class\n    var src = String.raw`var WebComponent = class extends HTMLElement {\n      constructor(){\n        // Always call super first in constructor\n        super()\n        if(cls.__init__){\n            try{\n                var _self = $B.DOMNode.$factory(this)\n                _self.__class__ = cls\n                $B.$call(cls.__init__)(_self)\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n      }\n        static get observedAttributes(){\n            if(cls.observedAttributes){\n                return cls.observedAttributes(cls)\n            }else{\n                return []\n            }\n        }\n    }\n    `\n    var name = cls.$infos.__name__\n    eval(src.replace(\"WebComponent\", name))\n    var webcomp = eval(name) // JS class for component\n    webcomp.$cls = cls\n\n    for(key in cls){\n        // Wrap other methods such as connectedCallback\n        if(typeof cls[key] == \"function\"){\n            webcomp.prototype[key] = (function(attr){\n                return function(){\n                    return $B.pyobj2jsobj(cls[attr]).call(null,\n                        $B.DOMNode.$factory(this), ...arguments)\n                }\n            })(key)\n        }\n    }\n\n    // Override __getattribute__ to handle DOMNode attributes such as\n    // attachShadow\n    cls.__getattribute__ = function(self, attr){\n        try{\n            return $B.DOMNode.__getattribute__(self, attr)\n        }catch(err){\n            if(err.__class__ === _b_.AttributeError){\n                var ga = $B.$getattr(cls, \"__getattribute__\")\n                return ga(self, attr)\n            }else{\n                throw err\n            }\n        }\n    }\n\n    // define WebComp as the class to use for the specified tag name\n    customElements.define(tag_name, webcomp)\n}\n\nfunction get(name){\n    var ce = customElements.get(name)\n    if(ce && ce.$cls){return ce.$cls}\n    return _b_.None\n}\n\nreturn {\n    define: define,\n    get: get\n}\n\n})(__BRYTHON__)"], "_zlib_utils": [".js", "\nfunction rfind(buf, seq){\n    var buflen = buf.length,\n        len = seq.length\n    for(var i = buflen - len; i >= 0; i--){\n        var chunk = buf.slice(i, i + len),\n            found = true\n        for(var j = 0; j < len; j++){\n            if(chunk[j] != seq[j]){\n                found = false\n                break\n            }\n        }\n        if(found){return i}\n    }\n    return -1\n}\n\n\nvar c;\nvar crcTable = [];\nfor(var n =0; n < 256; n++){\n    c = n;\n    for(var k =0; k < 8; k++){\n        c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    crcTable[n] = c;\n}\n\nvar $module = (function($B){\n\n    return {\n        crc32: function(str) {\n            var crc = 0 ^ (-1);\n        \n            for (var i = 0; i < str.length; i++ ) {\n                crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];\n            }\n        \n            return (crc ^ (-1)) >>> 0;\n        },\n\n        lz_generator: function(text, size, min_len){\n            /*\n            Returns a list of items based on the LZ algorithm, using the\n            specified window size and a minimum match length.\n            The items are a tuple (length, distance) if a match has been\n            found, and a byte otherwise.\n            */\n            // 'text' is an instance of Python 'bytes' class, the actual\n            // bytes are in text.source\n            text = text.source\n            if(min_len === undefined){\n                min_len = 3\n            }\n            var pos = 0, // position in text\n                items = [] // returned items\n            while(pos < text.length){\n                sequence = text.slice(pos, pos + min_len)\n                if(sequence.length < 3){\n                    for(var i = pos; i < text.length; i++){\n                        items.push(text[i])\n                    }\n                    break\n                }\n                // Search the sequence in the 'size' previous bytes\n                buf = text.slice(pos - size, pos)\n                buf_pos = rfind(buf, sequence)\n                if(buf_pos > -1){\n                    // Match of length 3 found; search a longer one\n                    var len = 1\n                    while(len < 259 &&\n                            buf_pos + len < buf.length &&\n                            pos + len < text.length &&\n                            text[pos + len] == buf[buf_pos + len]){\n                        len += 1\n                    }\n                    match = text.slice(pos, pos + len)\n                    // \"Lazy matching\": search longer match starting at next\n                    // position\n                    longer_match = false\n                    if(pos + len < text.length - 2){\n                        match2 = text.slice(pos + 1, pos + len + 2)\n                        longer_buf_pos = rfind(buf, match2)\n                        if(longer_buf_pos > -1){\n                            // found longer match : emit current byte as\n                            // literal and move 1 byte forward\n                            longer_match = true\n                            char = text[pos]\n                            items.push(char)\n                            pos += 1\n                        }\n                    }\n                    if(! longer_match){\n                        distance = buf.length - buf_pos\n                        items.push($B.fast_tuple([len, distance]))\n                        if(pos + len == text.length){\n                            break\n                        }else{\n                            pos += len\n                            items.push(text[pos])\n                            pos += 1\n                        }\n                    }\n                }else{\n                    char = text[pos]\n                    items.push(char)\n                    pos += 1\n                }\n            }\n            return items\n        }\n    }\n})(__BRYTHON__)"], "math": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins,\n    $s = [],\n    i\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar float_check = function(x) {\n    if(x.__class__ === $B.long_int){return parseInt(x.value)}\n    return _b_.float.$factory(x)\n}\n\nfunction check_int(x){\n    if(! _b_.isinstance(x, int)){\n        throw _b_.TypeError.$factory(\"'\" + $B.class_name(x) +\n            \"' object cannot be interpreted as an integer\")\n    }\n}\n\nfunction check_int_or_round_float(x){\n    return (x instanceof Number && x == Math.floor(x)) ||\n            _b_.isinstance(x, int)\n}\n\nvar isWholeNumber = function(x){return (x * 10) % 10 == 0}\n\nvar isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}\n\nvar isLargeNumber = function(x) {return x > Math.pow(2, 32)}\n\n// Big number Library from jsfromhell.com\n// This library helps with producing \"correct\" results from\n// mathematic operations\n\n//+ Jonas Raoni Soares Silva\n//@ http://jsfromhell.com/classes/bignumber [rev. #4]\n\n\nvar BigNumber = function(n, p, r){\n    var o = this, i\n    if(n instanceof BigNumber){\n        for(i in {precision: 0, roundType: 0, _s: 0, _f: 0}){o[i] = n[i]}\n        o._d = n._d.slice()\n        return\n    }\n    o.precision = isNaN(p = Math.abs(p)) ? BigNumber.defaultPrecision : p\n    o.roundType = isNaN(r = Math.abs(r)) ? BigNumber.defaultRoundType : r\n    o._s = (n += \"\").charAt(0) == \"-\"\n    o._f = ((n = n.replace(/[^\\d.]/g, \"\").split(\".\", 2))[0] =\n        n[0].replace(/^0+/, \"\") || \"0\").length\n    for(i = (n = o._d = (n.join(\"\") || \"0\").split(\"\")).length; i;\n        n[--i] = +n[i]){}\n    o.round()\n}\nwith({$: BigNumber, o: BigNumber.prototype}){\n    $.ROUND_HALF_EVEN = ($.ROUND_HALF_DOWN = ($.ROUND_HALF_UP =\n        ($.ROUND_FLOOR = ($.ROUND_CEIL = ($.ROUND_DOWN = ($.ROUND_UP = 0) + 1) +\n            1) + 1) + 1) + 1) + 1\n    $.defaultPrecision = 40\n    $.defaultRoundType = $.ROUND_HALF_UP\n    o.add = function(n){\n        if(this._s != (n = new BigNumber(n))._s){\n            return n._s ^= 1, this.subtract(n)\n        }\n        var o = new BigNumber(this),\n            a = o._d,\n            b = n._d,\n            la = o._f,\n            lb = n._f,\n            n = Math.max(la, lb),\n            i,\n            r\n        la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) :\n            o._zeroes(a, -lb, 1))\n        i = (la = a.length) == (lb = b.length) ? a.length :\n            ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length\n        for(r = 0; i; r = (a[--i] = a[i] + b[i] + r) / 10 >>> 0, a[i] %= 10){}\n        return r && ++n && a.unshift(r), o._f = n, o.round()\n    };\n    o.subtract = function(n){\n        if(this._s != (n = new BigNumber(n))._s)\n            return n._s ^= 1, this.add(n);\n        var o = new BigNumber(this),\n            c = o.abs().compare(n.abs()) + 1,\n            a = c ? o : n,\n            b = c ? n : o,\n            la = a._f,\n            lb = b._f,\n            d = la,\n            i,\n            j;\n        a = a._d, b = b._d, la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));\n        for(i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; i;){\n            if(a[--i] < b[i]){\n                for(j = i; j && !a[--j]; a[j] = 9);\n                --a[j], a[i] += 10;\n            }\n            b[i] = a[i] - b[i];\n        }\n        return c || (o._s ^= 1), o._f = d, o._d = b, o.round();\n    };\n    o.multiply = function(n){\n        var o = new BigNumber(this), r = o._d.length >= (n = new BigNumber(n))._d.length, a = (r ? o : n)._d,\n        b = (r ? n : o)._d, la = a.length, lb = b.length, x = new BigNumber, i, j, s;\n        for(i = lb; i; r && s.unshift(r), x.set(x.add(new BigNumber(s.join(\"\")))))\n            for(s = (new Array(lb - --i)).join(\"0\").split(\"\"), r = 0, j = la; j; r += a[--j] * b[i], s.unshift(r % 10), r = (r / 10) >>> 0);\n        return o._s = o._s != n._s, o._f = ((r = la + lb - o._f - n._f) >= (j = (o._d = x._d).length) ? this._zeroes(o._d, r - j + 1, 1).length : j) - r, o.round();\n    };\n    o.divide = function(n){\n        if((n = new BigNumber(n)) == \"0\")\n            throw new Error(\"Division by 0\");\n        else if(this == \"0\")\n            return new BigNumber;\n        var o = new BigNumber(this), a = o._d, b = n._d, la = a.length - o._f,\n        lb = b.length - n._f, r = new BigNumber, i = 0, j, s, l, f = 1, c = 0, e = 0;\n        r._s = o._s != n._s, r.precision = Math.max(o.precision, n.precision),\n        r._f = +r._d.pop(), la != lb && o._zeroes(la > lb ? b : a, Math.abs(la - lb));\n        n._f = b.length, b = n, b._s = false, b = b.round();\n        for(n = new BigNumber; a[0] == \"0\"; a.shift());\n        out:\n        do{\n            for(l = c = 0, n == \"0\" && (n._d = [], n._f = 0); i < a.length && n.compare(b) == -1; ++i){\n                (l = i + 1 == a.length, (!f && ++c > 1 || (e = l && n == \"0\" && a[i] == \"0\")))\n                && (r._f == r._d.length && ++r._f, r._d.push(0));\n                (a[i] == \"0\" && n == \"0\") || (n._d.push(a[i]), ++n._f);\n                if(e)\n                    break out;\n                if((l && n.compare(b) == -1 && (r._f == r._d.length && ++r._f, 1)) || (l = 0))\n                    while(r._d.push(0), n._d.push(0), ++n._f, n.compare(b) == -1);\n            }\n            if(f = 0, n.compare(b) == -1 && !(l = 0))\n                while(l ? r._d.push(0) : l = 1, n._d.push(0), ++n._f, n.compare(b) == -1);\n            for(s = new BigNumber, j = 0; n.compare(y = s.add(b)) + 1 && ++j; s.set(y));\n            n.set(n.subtract(s)), !l && r._f == r._d.length && ++r._f, r._d.push(j);\n        }\n        while((i < a.length || n != \"0\") && (r._d.length - r._f) <= r.precision);\n        return r.round();\n    };\n    o.mod = function(n){\n        return this.subtract(this.divide(n).intPart().multiply(n));\n    };\n    o.pow = function(n){\n        var o = new BigNumber(this), i;\n        if((n = (new BigNumber(n)).intPart()) == 0) return o.set(1);\n        for(i = Math.abs(n); --i; o.set(o.multiply(this)));\n        return n < 0 ? o.set((new BigNumber(1)).divide(o)) : o;\n    };\n    o.set = function(n){\n        return this.constructor(n), this;\n    };\n    o.compare = function(n){\n        var a = this, la = this._f, b = new BigNumber(n), lb = b._f, r = [-1, 1], i, l;\n        if(a._s != b._s)\n            return a._s ? -1 : 1;\n        if(la != lb)\n            return r[(la > lb) ^ a._s];\n        for(la = (a = a._d).length, lb = (b = b._d).length, i = -1, l = Math.min(la, lb); ++i < l;)\n            if(a[i] != b[i])\n                return r[(a[i] > b[i]) ^ a._s];\n        return la != lb ? r[(la > lb) ^ a._s] : 0;\n    };\n    o.negate = function(){\n        var n = new BigNumber(this); return n._s ^= 1, n;\n    };\n    o.abs = function(){\n        var n = new BigNumber(this); return n._s = 0, n;\n    };\n    o.intPart = function(){\n        return new BigNumber((this._s ? \"-\" : \"\") + (this._d.slice(0, this._f).join(\"\") || \"0\"));\n    };\n    o.valueOf = o.toString = function(){\n        var o = this;\n        return (o._s ? \"-\" : \"\") + (o._d.slice(0, o._f).join(\"\") || \"0\") + (o._f != o._d.length ? \".\" + o._d.slice(o._f).join(\"\") : \"\");\n    };\n    o._zeroes = function(n, l, t){\n        var s = [\"push\", \"unshift\"][t || 0];\n        for(++l; --l;  n[s](0));\n        return n;\n    };\n    o.round = function(){\n        if(\"_rounding\" in this) return this;\n        var $ = BigNumber, r = this.roundType, b = this._d, d, p, n, x;\n        for(this._rounding = true; this._f > 1 && !b[0]; --this._f, b.shift());\n        for(d = this._f, p = this.precision + d, n = b[p]; b.length > d && !b[b.length -1]; b.pop());\n        x = (this._s ? \"-\" : \"\") + (p - d ? \"0.\" + this._zeroes([], p - d - 1).join(\"\") : \"\") + 1;\n        if(b.length > p){\n            n && (r == $.DOWN ? false : r == $.UP ? true : r == $.CEIL ? !this._s\n            : r == $.FLOOR ? this._s : r == $.HALF_UP ? n >= 5 : r == $.HALF_DOWN ? n > 5\n            : r == $.HALF_EVEN ? n >= 5 && b[p - 1] & 1 : false) && this.add(x);\n            b.splice(p, b.length - p);\n        }\n        return delete this._rounding, this;\n    };\n}\n\nvar isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}\n\nvar _mod = {\n    __getattr__: function(attr){\n        $B.check_nb_args('__getattr__ ', 1, arguments)\n        $B.check_no_kw('__getattr__ ', attr)\n\n        var res = this[attr]\n        if(res === undefined){\n            throw _b_.AttributeError.$factory(\n                'module math has no attribute ' + attr)\n        }\n        return res\n    },\n    acos: function(x){\n        $B.check_nb_args('acos', 1, arguments)\n        $B.check_no_kw('acos', x)\n        return float.$factory(Math.acos(float_check(x)))\n    },\n    acosh: function(x){\n        $B.check_nb_args('acosh', 1, arguments)\n        $B.check_no_kw('acosh', x)\n\n        if(_b_.$isinf(x)){return float.$factory('inf')}\n        var y = float_check(x)\n        return float.$factory(Math.log(y + Math.sqrt(y * y - 1)))\n    },\n    asin: function(x){\n        $B.check_nb_args('asin', 1, arguments)\n        $B.check_no_kw('asin', x)\n        return float.$factory(Math.asin(float_check(x)))\n    },\n    asinh: function(x){\n        $B.check_nb_args('asinh', 1, arguments)\n        $B.check_no_kw('asinh', x)\n\n        if(_b_.$isninf(x)){return float.$factory('-inf')}\n        if(_b_.$isinf(x)){return float.$factory('inf')}\n        var y = float_check(x)\n        return float.$factory(Math.log(y + Math.sqrt(y * y + 1)))\n    },\n    atan: function(x){\n        $B.check_nb_args('atan', 1, arguments)\n        $B.check_no_kw('atan', x)\n\n        if(_b_.$isninf(x)){return float.$factory(-Math.PI / 2)}\n        if(_b_.$isinf(x)){return float.$factory(Math.PI / 2)}\n        return float.$factory(Math.atan(float_check(x)))\n    },\n    atan2: function(y, x){\n        $B.check_nb_args('atan2', 2, arguments)\n        $B.check_no_kw('atan2', y, x)\n\n        return float.$factory(Math.atan2(float_check(y), float_check(x)))\n    },\n    atanh: function(x){\n        $B.check_nb_args('atanh', 1, arguments)\n        $B.check_no_kw('atanh', x)\n\n       var y = float_check(x)\n       if(y == 0){return 0}\n       return float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));\n    },\n    ceil: function(x){\n        $B.check_nb_args('ceil', 1, arguments)\n        $B.check_no_kw('ceil', x)\n\n       try{return getattr(x, '__ceil__')()}catch(err){}\n\n       if(_b_.$isninf(x)){return float.$factory('-inf')}\n       if(_b_.$isinf(x)){return float.$factory('inf')}\n       if(isNaN(x)){return float.$factory('nan')}\n\n       var y = float_check(x)\n       if(! isNaN(parseFloat(y)) && isFinite(y)){\n           return int.$factory(Math.ceil(y))\n       }\n\n       throw _b_.ValueError.$factory(\n           'object is not a number and does not contain __ceil__')\n    },\n    comb: function(n, k){\n        $B.check_nb_args('comb', 2, arguments)\n        $B.check_no_kw('comb', n, k)\n\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (k! * (n - k)!)\n        var fn = _mod.factorial(n),\n            fk = _mod.factorial(k),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, $B.mul(fk, fn_k))\n    },\n    copysign: function(x, y){\n        $B.check_nb_args('copysign', 2, arguments)\n        $B.check_no_kw('copysign', x,y)\n\n        var x1 = Math.abs(float_check(x))\n        var y1 = float_check(y)\n        var sign = Math.sign(y1)\n        sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1\n        return float.$factory(x1 * sign)\n    },\n    cos : function(x){\n        $B.check_nb_args('cos ', 1, arguments)\n        $B.check_no_kw('cos ', x)\n        return float.$factory(Math.cos(float_check(x)))\n    },\n    cosh: function(x){\n        $B.check_nb_args('cosh', 1, arguments)\n        $B.check_no_kw('cosh', x)\n\n        if(_b_.$isinf(x)) {return float.$factory('inf')}\n        var y = float_check(x)\n        if(Math.cosh !== undefined){return float.$factory(Math.cosh(y))}\n        return float.$factory((Math.pow(Math.E, y) +\n            Math.pow(Math.E, -y)) / 2)\n    },\n    degrees: function(x){\n        $B.check_nb_args('degrees', 1, arguments)\n        $B.check_no_kw('degrees', x)\n        return float.$factory(float_check(x) * 180 / Math.PI)\n    },\n    dist: function(p, q){\n        $B.check_nb_args('dist', 2, arguments)\n        $B.check_no_kw('dist', p, q)\n        var itp = _b_.iter(p),\n            itq = _b_.iter(q),\n            res = 0\n        while(true){\n            try{\n                var next_p = _b_.next(itp)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    // check that the other iterator is also exhausted\n                    try{\n                        var next_q = _b_.next(itq)\n                        throw _b_.ValueError.$factory(\"both points must have \" +\n                            \"the same number of dimensions\")\n                    }catch(err){\n                        if(err.__class__ === _b_.StopIteration){\n                            if(typeof res == \"number\" || res instanceof Number){\n                                return Math.sqrt(res)\n                            }else{\n                                return Math.sqrt(parseInt(res.value))\n                            }\n                        }\n                        throw err\n                    }\n                }\n                throw err\n            }\n            try{\n                var next_q = _b_.next(itq),\n                    diff = $B.sub(next_p, next_q)\n                res = $B.add(res, $B.mul(diff, diff))\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    throw _b_.ValueError.$factory(\"both points must have \" +\n                        \"the same number of dimensions\")\n                }\n                throw err\n            }\n        }\n    },\n    e: float.$factory(Math.E),\n    erf: function(x){\n        $B.check_nb_args('erf', 1, arguments)\n        $B.check_no_kw('erf', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return ans}\n        return -ans\n    },\n    erfc: function(x){\n\n        $B.check_nb_args('erfc', 1, arguments)\n        $B.check_no_kw('erfc', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return 1 - ans}\n        return 1 + ans\n    },\n    exp: function(x){\n        $B.check_nb_args('exp', 1, arguments)\n        $B.check_no_kw('exp', x)\n\n         if(_b_.$isninf(x)){return float.$factory(0)}\n         if(_b_.$isinf(x)){return float.$factory('inf')}\n         var _r = Math.exp(float_check(x))\n         if(_b_.$isinf(_r)){throw OverflowError(\"math range error\")}\n         return float.$factory(_r)\n    },\n    expm1: function(x){\n        $B.check_nb_args('expm1', 1, arguments)\n        $B.check_no_kw('expm1', x)\n\n         if(_b_.$isninf(x)){return float.$factory(0)}\n         if(_b_.$isinf(x)){return float.$factory('inf')}\n         var _r = Math.expm1(float_check(x))\n         if(_b_.$isinf(_r)){throw OverflowError(\"math range error\")}\n         return float.$factory(_r)\n    },\n    //fabs: function(x){ return x>0?float.$factory(x):float.$factory(-x)},\n    fabs: function(x){\n        $B.check_nb_args('fabs', 1, arguments)\n        $B.check_no_kw('fabs', x)\n        return _b_.$fabs(x) // located in py_float.js\n    },\n    factorial: function(x){\n        $B.check_nb_args('factorial', 1, arguments)\n        $B.check_no_kw('factorial', x)\n\n         //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n         if(! check_int_or_round_float(x)){\n             throw _b_.ValueError.$factory(\"factorial() only accepts integral values\")\n         }else if($B.rich_comp(\"__lt__\", x, 0)){\n             throw _b_.ValueError.$factory(\"factorial() not defined for negative values\")\n         }\n         var r = 1\n         for(var i = 2; i <= x; i++){\n             r = $B.mul(r, i)\n         }\n         return r\n    },\n    floor: function(x){\n        $B.check_nb_args('floor', 1, arguments)\n        $B.check_no_kw('floor', x)\n        return Math.floor(float_check(x))\n    },\n    fmod: function(x,y){\n        $B.check_nb_args('fmod', 2, arguments)\n        $B.check_no_kw('fmod', x,y)\n        return float.$factory(float_check(x) % float_check(y))\n    },\n    frexp: function(x){\n        $B.check_nb_args('frexp', 1, arguments)\n        $B.check_no_kw('frexp', x)\n\n        var _l = _b_.$frexp(x)\n        return _b_.tuple.$factory([float.$factory(_l[0]), _l[1]])\n    },\n    fsum: function(x){\n        $B.check_nb_args('fsum', 1, arguments)\n        $B.check_no_kw('fsum', x)\n\n        /* Translation into Javascript of the function msum in an Active\n           State Cookbook recipe : https://code.activestate.com/recipes/393090/\n           by Raymond Hettinger\n        */\n        var partials = [],\n            res = new Number(),\n            _it = _b_.iter(x)\n        while(true){\n            try{\n                var x = _b_.next(_it),\n                    i = 0\n                for(var j = 0, len = partials.length; j < len; j++){\n                    var y = partials[j]\n                    if(Math.abs(x) < Math.abs(y)){\n                        var z = x\n                        x = y\n                        y = z\n                    }\n                    var hi = x + y,\n                        lo = y - (hi - x)\n                    if(lo){\n                        partials[i] = lo\n                        i++\n                    }\n                    x = hi\n                }\n                partials = partials.slice(0, i).concat([x])\n            }catch(err){\n                if(_b_.isinstance(err, _b_.StopIteration)){break}\n                throw err\n            }\n        }\n        var res = new Number(0)\n        for(var i = 0; i < partials.length; i++){\n            res += new Number(partials[i])\n        }\n        return new Number(res)\n    },\n    gamma: function(x){\n        $B.check_nb_args('gamma', 1, arguments)\n        $B.check_no_kw('gamma', x)\n\n        if(_b_.isinstance(x, int)){\n            if(i < 1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            var res = 1\n            for(var i = 1; i < x; i++){res *= i}\n            return new Number(res)\n        }\n        // Adapted from https://en.wikipedia.org/wiki/Lanczos_approximation\n        var p = [676.5203681218851,\n            -1259.1392167224028,\n            771.32342877765313,\n            -176.61502916214059,\n            12.507343278686905,\n            -0.13857109526572012,\n            9.9843695780195716e-6,\n            1.5056327351493116e-7\n            ]\n\n        var EPSILON = 1e-07\n        function drop_imag(z){\n            if(Math.abs(z.imag) <= EPSILON){\n                z = z.real\n            }\n            return z\n        }\n        var z = x\n        if(z < 0.5){\n            var y = Math.PI / (Math.sin(Math.PI * z) * _mod.gamma(1-z)) // Reflection formula\n        }else{\n            z -= 1\n            var x = 0.99999999999980993,\n                i = 0\n            for(var i = 0, len = p.length; i < len; i++){\n                var pval = p[i]\n                x += pval / (z + i + 1)\n            }\n            var t = z + p.length - 0.5,\n                sq = Math.sqrt(2 * Math.PI),\n                y = sq * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x\n        }\n        return drop_imag(y)\n    },\n    gcd: function(){\n        var $ = $B.args(\"gcd\", 2, {a: null, b: null}, ['a', 'b'],\n                arguments, {}, null, null),\n            a = $B.PyNumber_Index($.a),\n            b = $B.PyNumber_Index($.b)\n        if(a == 0 && b == 0){return 0}\n        // https://stackoverflow.com/questions/17445231/js-how-to-find-the-greatest-common-divisor\n        a = _b_.abs(a)\n        b = _b_.abs(b)\n        if($B.rich_comp(\"__gt__\", b, a)){\n            var temp = a\n            a = b\n            b = temp\n        }\n        while(true){\n            if(b == 0){\n                return a\n            }\n            a = $B.rich_op(\"mod\", a, b)\n            if(a == 0){\n                return b\n            }\n            b = $B.rich_op(\"mod\", b, a)\n        }\n    },\n    hypot: function(x, y){\n        var $ = $B.args(\"hypot\", 2, {x: null, y:null}, ['x', 'y'],\n                    arguments, {}, \"args\", null),\n            args = [x, y].concat($.args),\n            res = 0\n        for (var i = 0, len = args.length; i < len; i++){\n            if(_b_.$isinf(args[i])){\n                return float.$factory('inf')\n            }\n            float_check(args[i])\n            res += args[i] * args[i]\n        }\n        return float.$factory(Math.sqrt(res))\n    },\n    inf: float.$factory('inf'),\n    isclose: function(){\n        var $ns = $B.args(\"isclose\",\n                          4,\n                          {a: null, b: null, rel_tol: null, abs_tol: null},\n                          ['a', 'b', 'rel_tol', 'abs_tol'],\n                          arguments,\n                          {rel_tol: 1e-09, abs_tol: 0.0},\n                          null,\n                          null)\n        var a = $ns['a'],\n            b = $ns['b'],\n            rel_tol = $ns['rel_tol'],\n            abs_tol = $ns['abs_tol']\n        if(rel_tol < 0.0 || abs_tol < 0.0){\n            throw ValueError('tolerances must be non-negative')\n        }\n        if(a == b){return True}\n        if(_b_.$isinf(a) || _b_.$isinf(b)){return false}\n        var diff = _b_.$fabs(b - a)\n        var result = (\n            (diff <= _b_.$fabs(rel_tol * b)) ||\n                (diff <= _b_.$fabs(rel_tol * a))\n            ) || (diff <= _b_.$fabs(abs_tol)\n        )\n        return result\n    },\n    isfinite: function(x){\n        $B.check_nb_args('isfinite', 1, arguments)\n        $B.check_no_kw('isfinite', x)\n        return isFinite(float_check(x))\n    },\n    isinf: function(x){\n        $B.check_nb_args('isinf', 1, arguments)\n        $B.check_no_kw('isinf', x)\n        return _b_.$isinf(float_check(x))\n    },\n    isnan: function(x){\n        $B.check_nb_args('isnan', 1, arguments)\n        $B.check_no_kw('isnan', x)\n        return isNaN(float_check(x))\n    },\n    isqrt: function(x){\n        $B.check_nb_args('isqrt', 1, arguments)\n        $B.check_no_kw('isqrt', x)\n\n        x = $B.PyNumber_Index(x)\n        if($B.rich_comp(\"__lt__\", x, 0)){\n            throw _b_.ValueError.$factory(\n                \"isqrt() argument must be nonnegative\")\n        }\n        if(typeof x == \"number\"){\n            return Math.floor(Math.sqrt(x))\n        }else{ // big integer\n            var v = parseInt(x.value),\n                candidate = Math.floor(Math.sqrt(v)),\n                c1\n            // Use successive approximations : sqr = (sqr + (x / sqr)) / 2\n            // Limit to 100 iterations\n            for(var i = 0; i < 100; i++){\n                c1 = $B.floordiv($B.add(candidate,\n                    $B.floordiv(x, candidate)), 2)\n                if(c1 === candidate || c1.value === candidate.value){\n                    break\n                }\n                candidate = c1\n            }\n            if($B.rich_comp(\"__gt__\", $B.mul(candidate, candidate), x)){\n                // Result might be greater by 1\n                candidate = $B.sub(candidate, 1)\n            }\n            return candidate\n        }\n    },\n    ldexp: function(x, i){\n        $B.check_nb_args('ldexp', 2, arguments)\n        $B.check_no_kw('ldexp', x, i)\n        return _b_.$ldexp(x, i)   //located in py_float.js\n    },\n    lgamma: function(x){\n        $B.check_nb_args('lgamma', 1, arguments)\n        $B.check_no_kw('lgamma', x)\n\n        return new Number(Math.log(Math.abs(_mod.gamma(x))))\n    },\n    log: function(x, base){\n        var $ = $B.args(\"log\", 2, {x: null, base: null}, ['x', 'base'],\n            arguments, {base: _b_.None}, null, null),\n            x = $.x,\n            base = $.base\n\n         var x1 = float_check(x)\n         if(base === _b_.None){return float.$factory(Math.log(x1))}\n         return float.$factory(Math.log(x1) / Math.log(float_check(base)))\n    },\n    log1p: function(x){\n        $B.check_nb_args('log1p', 1, arguments)\n        $B.check_no_kw('log1p', x)\n        return float.$factory(Math.log1p(float_check(x)))\n    },\n    log2: function(x){\n        $B.check_nb_args('log2', 1, arguments)\n        $B.check_no_kw('log2', x)\n\n        if(isNaN(x)){return float.$factory('nan')}\n        if(_b_.$isninf(x)) {throw ValueError('')}\n        var x1 = float_check(x)\n        if(x1 < 0.0){throw ValueError('')}\n        return float.$factory(Math.log(x1) / Math.LN2)\n    },\n    log10: function(x){\n        $B.check_nb_args('log10', 1, arguments)\n        $B.check_no_kw('log10', x)\n\n        return float.$factory(Math.log10(float_check(x)))\n    },\n    modf: function(x){\n        $B.check_nb_args('modf', 1, arguments)\n        $B.check_no_kw('modf', x)\n\n       if(_b_.$isninf(x)){\n           return _b_.tuple.$factory([0.0, float.$factory('-inf')])\n       }\n       if(_b_.$isinf(x)){\n           return _b_.tuple.$factory([0.0, float.$factory('inf')])\n       }\n       if(isNaN(x)){\n           return _b_.tuple.$factory([float.$factory('nan'),\n               float.$factory('nan')])\n       }\n\n       var x1 = float_check(x)\n       if(x1 > 0){\n          var i = float.$factory(x1 - Math.floor(x1))\n          return _b_.tuple.$factory([i, float.$factory(x1 - i)])\n       }\n\n       var x2 = Math.ceil(x1)\n       var i = float.$factory(x1 - x2)\n       return _b_.tuple.$factory([i, float.$factory(x2)])\n    },\n    nan: float.$factory('nan'),\n    perm: function(n, k){\n        var $ = $B.args(\"perm\", 2, {n: null, k: null}, ['n', 'k'],\n                        arguments, {k: _b_.None}, null, null),\n            n = $.n,\n            k = $.k\n\n        if(k === _b_.None){\n            check_int(n)\n            return _mod.factorial(n)\n        }\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (n - k)!\n        var fn = _mod.factorial(n),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, fn_k)\n    },\n    pi : float.$factory(Math.PI),\n    pow: function(x, y){\n        $B.check_nb_args('pow', 2, arguments)\n        $B.check_no_kw('pow', x,y)\n\n        var x1 = float_check(x)\n        var y1 = float_check(y)\n        if(y1 == 0){return float.$factory(1)}\n        if(x1 == 0 && y1 < 0){throw _b_.ValueError('')}\n\n        if(isNaN(y1)){\n            if(x1 == 1){return float.$factory(1)}\n            return float.$factory('nan')\n        }\n        if(x1 == 0){return float.$factory(0)}\n\n        if(_b_.$isninf(y)){\n            if(x1 == 1 || x1 == -1){return float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return float.$factory('inf')}\n            return float.$factory(0)\n        }\n        if(_b_.$isinf(y)){\n            if(x1 == 1 || x1 == -1){return float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return float.$factory(0)}\n            return float.$factory('inf')\n        }\n\n        if(isNaN(x1)){return float.$factory('nan')}\n        if(_b_.$isninf(x)){\n            if(y1 > 0 && isOdd(y1)){return float.$factory('-inf')}\n            if(y1 > 0){return float.$factory('inf')}  // this is even or a float\n            if(y1 < 0){return float.$factory(0)}\n            return float.$factory(1)\n        }\n\n        if(_b_.$isinf(x)){\n            if(y1 > 0){return float.$factory('inf')}\n            if(y1 < 0){return float.$factory(0)}\n            return float.$factory(1)\n        }\n\n        var r\n        if(isLargeNumber(x1) || isLargeNumber(y1)){\n           var x = new BigNumber(x1),\n               y = new BigNumber(y1)\n           r = x.pow(y)\n        }else{\n           r = Math.pow(x1,y1)\n        }\n\n        if(isNaN(r)){return float.$factory('nan')}\n        if(_b_.$isninf(r)){return float.$factory('-inf')}\n        if(_b_.$isinf(r)){return float.$factory('inf')}\n\n        return r\n    },\n    prod: function(){\n        var $ = $B.args(\"prod\", 1, {iterable:null, start:null},\n                        [\"iterable\", \"start\"], arguments, {start: 1}, \"*\",\n                        null),\n            iterable = $.iterable,\n            start = $.start\n        var res = start,\n            it = _b_.iter(iterable),\n            x\n        while(true){\n            try{\n                x = _b_.next(it)\n                if(x == 0){\n                    return 0\n                }\n                res = $B.mul(res, x)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    return res\n                }\n                throw err\n            }\n        }\n    },\n    radians: function(x){\n        $B.check_nb_args('radians', 1, arguments)\n        $B.check_no_kw('radians', x)\n\n        return float.$factory(float_check(x) * Math.PI / 180)\n    },\n    sin : function(x){\n        $B.check_nb_args('sin ', 1, arguments)\n        $B.check_no_kw('sin ', x)\n        return float.$factory(Math.sin(float_check(x)))},\n    sinh: function(x) {\n        $B.check_nb_args('sinh', 1, arguments)\n        $B.check_no_kw('sinh', x)\n\n        var y = float_check(x)\n        if(Math.sinh !== undefined){return float.$factory(Math.sinh(y))}\n        return float.$factory(\n            (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)\n    },\n    sqrt: function(x){\n        $B.check_nb_args('sqrt ', 1, arguments)\n        $B.check_no_kw('sqrt ', x)\n\n      var y = float_check(x)\n      if(y < 0){throw ValueError(\"math range error\")}\n      if(_b_.$isinf(y)){return float.$factory('inf')}\n      var _r = Math.sqrt(y)\n      if(_b_.$isinf(_r)){throw OverflowError(\"math range error\")}\n      return float.$factory(_r)\n    },\n    tan: function(x) {\n        $B.check_nb_args('tan', 1, arguments)\n        $B.check_no_kw('tan', x)\n\n        var y = float_check(x)\n        return float.$factory(Math.tan(y))\n    },\n    tanh: function(x) {\n        $B.check_nb_args('tanh', 1, arguments)\n        $B.check_no_kw('tanh', x)\n\n        var y = float_check(x)\n        if(Math.tanh !== undefined){return float.$factory(Math.tanh(y))}\n        return float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/\n             (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))\n    },\n    trunc: function(x) {\n        $B.check_nb_args('trunc', 1, arguments)\n        $B.check_no_kw('trunc', x)\n\n       try{return getattr(x, '__trunc__')()}catch(err){}\n       var x1 = float_check(x)\n       if(!isNaN(parseFloat(x1)) && isFinite(x1)){\n          if(Math.trunc !== undefined){return int.$factory(Math.trunc(x1))}\n          if(x1 > 0){return int.$factory(Math.floor(x1))}\n          return int.$factory(Math.ceil(x1))  // x1 < 0\n       }\n       throw _b_.ValueError.$factory(\n           'object is not a number and does not contain __trunc__')\n    }\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr] === 'function'){\n        _mod[$attr].__repr__ = (function(func){\n            return function(){return '<built-in function ' + func + '>'}\n        })($attr)\n        _mod[$attr].__str__ = (function(func){\n            return function(){return '<built-in function ' + func + '>'}\n        })($attr)\n    }\n}\n\nreturn _mod\n\n})(__BRYTHON__)\n"], "_base64": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins,\n    _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\nfunction make_alphabet(altchars){\n    var alphabet = _keyStr\n    if(altchars !== undefined && altchars !== _b_.None){\n        // altchars is an instance of Python bytes\n        var source = altchars.source\n        alphabet = alphabet.substr(0,alphabet.length-3) +\n            _b_.chr(source[0]) + _b_.chr(source[1]) + '='\n    }\n    return alphabet\n}\n\nvar Base64 = {\n    error: function(){return 'binascii_error'},\n\n    encode: function(bytes, altchars){\n\n        var input = bytes.source,\n            output = \"\",\n            chr1, chr2, chr3, enc1, enc2, enc3, enc4\n        var i = 0\n\n        var alphabet = make_alphabet(altchars)\n\n        while(i < input.length){\n\n            chr1 = input[i++]\n            chr2 = input[i++]\n            chr3 = input[i++]\n\n            enc1 = chr1 >> 2\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6)\n            enc4 = chr3 & 63\n\n            if(isNaN(chr2)){\n                enc3 = enc4 = 64\n            }else if(isNaN(chr3)){\n                enc4 = 64\n            }\n\n            output = output + alphabet.charAt(enc1) +\n                alphabet.charAt(enc2) +\n                alphabet.charAt(enc3) +\n                alphabet.charAt(enc4)\n\n        }\n        return _b_.bytes.$factory(output, 'utf-8', 'strict')\n    },\n\n\n    decode: function(bytes, altchars, validate){\n        var output = [],\n            chr1, chr2, chr3,\n            enc1, enc2, enc3, enc4\n\n        var alphabet = make_alphabet(altchars)\n\n        var input = bytes.source\n\n        // If validate is set, check that all characters in input\n        // are in the alphabet\n        var _input = ''\n        var padding = 0\n        for(var i = 0, len = input.length; i < len; i++){\n            var car = String.fromCharCode(input[i])\n            var char_num = alphabet.indexOf(car)\n            if(char_num == -1){\n                if(validate){throw Base64.error(\"Non-base64 digit found: \" +\n                    car)}\n            }else if(char_num == 64 && i < input.length - 2){\n                if(validate){throw Base64.error(\"Non-base64 digit found: \" +\n                    car)}\n            }else if(char_num == 64 && i >= input.length - 2){\n                padding++\n                _input += car\n            }else{\n                _input += car\n            }\n        }\n        input = _input\n        if(_input.length == padding){return _b_.bytes.$factory([])}\n        if( _input.length % 4 > 0){throw Base64.error(\"Incorrect padding\")}\n\n        var i = 0\n        while(i < input.length){\n\n            enc1 = alphabet.indexOf(input.charAt(i++))\n            enc2 = alphabet.indexOf(input.charAt(i++))\n            enc3 = alphabet.indexOf(input.charAt(i++))\n            enc4 = alphabet.indexOf(input.charAt(i++))\n\n            chr1 = (enc1 << 2) | (enc2 >> 4)\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n            chr3 = ((enc3 & 3) << 6) | enc4\n\n            output.push(chr1)\n\n            if(enc3 != 64){output.push(chr2)}\n            if(enc4 != 64){output.push(chr3)}\n\n        }\n        // return Python bytes\n        return _b_.bytes.$factory(output, 'utf-8', 'strict')\n\n    },\n\n    _utf8_encode: function(string) {\n        string = string.replace(/\\r\\n/g, \"\\n\")\n        var utftext = \"\";\n\n        for(var n = 0; n < string.length; n++){\n\n            var c = string.charCodeAt(n)\n\n            if(c < 128){\n                utftext += String.fromCharCode(c)\n            }else if((c > 127) && (c < 2048)){\n                utftext += String.fromCharCode((c >> 6) | 192)\n                utftext += String.fromCharCode((c & 63) | 128)\n            }else{\n                utftext += String.fromCharCode((c >> 12) | 224)\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128)\n                utftext += String.fromCharCode((c & 63) | 128)\n            }\n\n        }\n\n        return utftext\n    },\n\n    _utf8_decode: function(utftext) {\n        var string = \"\",\n            i = 0,\n            c = c1 = c2 = 0\n\n        while(i < utftext.length){\n\n            c = utftext.charCodeAt(i)\n\n            if(c < 128){\n                string += String.fromCharCode(c)\n                i++\n            }else if((c > 191) && (c < 224)){\n                c2 = utftext.charCodeAt(i + 1)\n                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63))\n                i += 2\n            }else{\n                c2 = utftext.charCodeAt(i + 1)\n                c3 = utftext.charCodeAt(i + 2)\n                string += String.fromCharCode(\n                    ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63))\n                i += 3\n            }\n\n        }\n\n        return string\n    }\n\n}\n\nreturn {Base64:Base64}\n}\n\n)(__BRYTHON__)"], "posix": [".js", "/*\nThis module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.\n*/\n\nvar $B = __BRYTHON__,\n    _b_ = $B.builtins\n\nfunction _randint(a, b){\n    return parseInt(Math.random() * (b - a + 1) + a)\n}\n\nvar stat_result = $B.make_class(\"stat_result\",\n    function(filename){\n        // Use $B.files, created by \"python -m brython --make_file_system\"\n        if($B.files && $B.files.hasOwnProperty(filename)){\n            var f = $B.files[filename],\n                res = {\n                    __class__: stat_result,\n                    st_atime: new Date().getTime(),\n                    st_ctime: f.ctime,\n                    st_mtime: f.mtime,\n                    st_uid: -1,\n                    st_gid: -1,\n                    st_ino: -1,\n                    st_mode: 0,\n                    st_size: 1\n                };\n            [\"atime\", \"mtime\", \"ctime\"].\n                forEach(function(item){\n                    res[\"st_\" + item + \"_ns\"] = res[\"st_\" + item] *\n                        1000000\n                });\n        }else{\n            var res = {\n                __class__: stat_result,\n                st_atime: new Date(),\n                st_uid: -1,\n                st_gid: -1,\n                st_ino: -1,\n                st_mode: 0,\n                st_size: 1\n            };\n            [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"].\n                forEach(function(item){\n                    res[\"st_\" + item] = res.st_atime\n                });\n        }\n        return res\n    }\n)\n$B.set_func_names(stat_result, \"posix\")\n\nvar $module = {\n    F_OK: 0,\n    O_APPEND: 8,\n    O_BINARY: 32768,\n    O_CREAT: 256,\n    O_EXCL: 1024,\n    O_NOINHERIT: 128,\n    O_RANDOM: 16,\n    O_RDONLY: 0,\n    O_RDWR: 2,\n    O_SEQUENTIAL: 32,\n    O_SHORT_LIVED: 4096,\n    O_TEMPORARY: 64,\n    O_TEXT: 16384,\n    O_TRUNC: 512,\n    O_WRONLY: 1,\n    P_DETACH: 4,\n    P_NOWAIT: 1,\n    P_NOWAITO: 3,\n    P_OVERLAY: 2,\n    P_WAIT: 0,\n    R_OK: 4,\n    TMP_MAX: 32767,\n    W_OK: 2,\n    X_OK: 1,\n    _have_functions: ['MS_WINDOWS'],\n    environ: _b_.dict.$factory(\n        [['PYTHONPATH', $B.brython_path],\n         ['PYTHONUSERBASE', ' ']]),\n    error: _b_.OSError,\n    fspath: function(path){\n        return path\n    },\n    getcwd: function(){return $B.brython_path},\n    getpid: function(){return 0},\n    lstat: function(){return stat_result.$factory()},\n    open: function(path, flags){return _b_.open(path, flags)},\n    stat: function(filename){return stat_result.$factory(filename)},\n    stat_result: function(filename){return stat_result.$factory(filename)},\n    urandom: function(n){\n        var randbytes = []\n        for(var i = 0; i < n; i++){\n            randbytes.push(_randint(0, 255))\n        }\n        return _b_.bytes.$factory(randbytes)\n    },\n    WTERMSIG: function(){return 0},\n    WNOHANG: function(){return _b_.tuple.$factory([0, 0])}\n};\n\n[\"WCOREDUMP\", \"WIFCONTINUED\", \"WIFSTOPPED\", \"WIFSIGNALED\", \"WIFEXITED\"].forEach(function(funcname){\n        $module[funcname] = function(){return false}\n    });\n\n[\"WEXITSTATUS\", \"WSTOPSIG\", \"WTERMSIG\"].\n    forEach(function(funcname){\n        $module[funcname] = function(){return _b_.None}\n    });\n\n[\"_exit\", \"_getdiskusage\", \"_getfileinformation\", \"_getfinalpathname\",\n    \"_getfullpathname\", \"_isdir\", \"abort\", \"access\", \"chdir\", \"chmod\",\n    \"close\", \"closerange\", \"device_encoding\", \"dup\", \"dup2\",\n    \"execv\", \"execve\", \"fsat\", \"fsync\", \"get_terminal_size\", \"getcwdb\",\n    \"getlogin\", \"getppid\", \"isatty\", \"kill\", \"link\", \"listdir\", \"lseek\",\n    \"mkdir\", \"pipe\", \"putenv\", \"read\", \"readlink\", \"remove\", \"rename\",\n    \"replace\", \"rmdir\", \"spawnv\", \"spawnve\", \"startfile\", \"stat_float_times\",\n    \"statvfs_result\", \"strerror\", \"symlink\", \"system\", \"terminal_size\",\n    \"times\", \"times_result\", \"umask\", \"uname_result\", \"unlink\", \"utime\",\n    \"waitpid\", \"write\"].forEach(function(funcname){\n        $module[funcname] = function(){\n            throw _b_.NotImplementedError.$factory(\"posix.\" + funcname +\n                \" is not implemented\")\n        }\n    });\n"], "_string": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nfunction parts(format_string){\n    var result = [],\n        _parts = $B.split_format(format_string) // defined in py_string.js\n    for(var i = 0; i < _parts.length; i+= 2){\n        result.push({pre: _parts[i], fmt: _parts[i + 1]})\n    }\n    return result\n}\n\nfunction Tuple(){\n    var args = []\n    for(var i=0, len=arguments.length; i < len; i++){\n        args.push(arguments[i])\n    }\n    return _b_.tuple.$factory(args)\n}\n\nreturn{\n\n    formatter_field_name_split: function(fieldname){\n        // Split the argument as a field name\n        var parsed = $B.parse_format(fieldname),\n            first = parsed.name,\n            rest = []\n        if(first.match(/\\d+/)){first = parseInt(first)}\n        parsed.name_ext.forEach(function(ext){\n            if(ext.startsWith(\"[\")){\n                var item = ext.substr(1, ext.length - 2)\n                if(item.match(/\\d+/)){\n                    rest.push(Tuple(false, parseInt(item)))\n                }else{\n                    rest.push(Tuple(false, item))\n                }\n            }else{\n                rest.push(Tuple(true, ext.substr(1)))\n            }\n        })\n        return Tuple(first, _b_.iter(rest))\n    },\n    formatter_parser: function(format_string){\n        // Parse the argument as a format string\n\n        if(! _b_.isinstance(format_string, _b_.str)){\n            throw _b_.ValueError.$factory(\"Invalid format string type: \" +\n                $B.class_name(format_string))\n        }\n\n        var result  = []\n        parts(format_string).forEach(function(item){\n            var pre = item.pre === undefined ? \"\" : item.pre,\n                fmt = item.fmt\n            if(fmt === undefined){\n               result.push(Tuple(pre, _b_.None, _b_.None, _b_.None))\n            }else if(fmt.string == ''){\n               result.push(Tuple(pre, '', '', _b_.None))\n            }else{\n               result.push(Tuple(pre,\n                   fmt.raw_name + fmt.name_ext.join(\"\"),\n                   fmt.raw_spec,\n                   fmt.conv || _b_.None))\n           }\n        })\n        return result\n    }\n}\n})(__BRYTHON__)"], "_posixsubprocess": [".js", "var $module=(function($B){\n\n    return {\n       cloexec_pipe: function() {}   // fixme\n    }\n})(__BRYTHON__)\n"], "unicodedata": [".js", "// Implementation of unicodedata\n\nvar $module = (function($B){\n\n    var _b_ = $B.builtins\n\n    // Load unicode table if not already loaded\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt\", false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\"Warning - could not \" +\n                        \"load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n\n    function _info(chr){\n        var ord = chr.codePointAt(0),\n            hex = ord.toString(16).toUpperCase()\n        while(hex.length < 4){hex = \"0\" + hex}\n        var re = new RegExp(\"^\" + hex +\";(.+?);(.*?);(.*?);(.*?);(.*?);(.*);(.*);(.*)$\",\n                \"m\"),\n            search = re.exec($B.unicodedb)\n        if(search === null){\n            return null\n        }else{\n            return {\n                name: search[1],\n                category: search[2],\n                combining: search[3],\n                bidirectional: search[4],\n                decomposition: search[5],\n                decimal: search[6],\n                digit: search[7],\n                numeric: search[8]\n            }\n        }\n    }\n\n    function bidirectional(chr){\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr, hex)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.bidirectional\n    }\n\n    function category(chr){\n        // Returns the general category assigned to the character chr as\n        // string.\n        if($B.is_unicode_cn(chr.codePointAt(0))){ // in unicode_data.js\n            return \"Cn\"\n        }\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.category\n    }\n\n    function combining(chr){\n        // Returns the general category assigned to the character chr as\n        // string.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.combining)\n    }\n\n    function decimal(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.decimal)\n    }\n\n    function decomposition(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.decomposition\n    }\n\n    function digit(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.digit)\n    }\n\n    function lookup(name){\n        // Look up character by name. If a character with the given name is\n        // found, return the corresponding character. If not found, KeyError\n        // is raised.\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            name + \";(.*)$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            throw _b_.KeyError.$factory(\"undefined character name '\" +\n                name + \"'\")\n        }\n        var res = parseInt(search[1], 16)\n        return _b_.chr(res)\n    }\n\n    function name(chr, _default){\n        // Returns the name assigned to the character chr as a string. If no\n        // name is defined, default is returned, or, if not given, ValueError\n        // is raised.\n        var search = _info(chr)\n        if(search === null){\n            if(_default){return _default}\n            throw _b_.KeyError.$factory(\"undefined character name '\" +\n                chr + \"'\")\n        }\n        return search.name\n    }\n\n    function _norm(form, chr){\n        var search = _info(chr)\n        if(search === null){\n            throw _b_.KeyError.$factory(chr)\n        }\n        switch(form){\n            case \"NFC\":\n                return chr\n            case \"NFD\":\n                var decomp = decomposition(chr),\n                    parts = decomp.split(\" \"),\n                    res = \"\"\n                if(parts[0].startsWith(\"<\")){\n                    return chr\n                }\n                parts.forEach(function(part){\n                    if(! part.startsWith(\"<\")){\n                        res += _b_.chr(parseInt(part, 16))\n                    }\n                })\n                return res\n            case \"NFKC\":\n                var decomp = decomposition(chr),\n                    parts = decomp.split(\" \")\n                if(parts[0] == \"<compat>\"){\n                    var res = \"\"\n                    parts.slice(1).forEach(function(part){\n                        res += _b_.chr(parseInt(part, 16))\n                    })\n                    return res\n                }\n                return chr\n            case \"NFKD\":\n                var decomp = decomposition(chr),\n                    parts = decomp.split(\" \")\n                if(parts[0] == \"<compat>\"){\n                    var res = \"\"\n                    parts.slice(1).forEach(function(part){\n                        res += _b_.chr(parseInt(part, 16))\n                    })\n                    return res\n                }\n                return chr\n\n            default:\n                throw _b_.ValueError.$factory(\"invalid normalization form\")\n        }\n    }\n\n    function normalize(form, unistr){\n        var res = \"\"\n        for(var i = 0, len = unistr.length; i < len; i++){\n            res += _norm(form, unistr.charAt(i))\n        }\n        return res\n    }\n\n    function numeric(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            if(_default){return _default}\n            throw _b_.KeyError.$factory(chr)\n        }\n        return new Number(eval(search.numeric))\n    }\n\n    var module = {\n        bidirectional: bidirectional,\n        category: category,\n        combining: combining,\n        decimal: decimal,\n        decomposition: decomposition,\n        digit: digit,\n        lookup: lookup,\n        name: name,\n        normalize: normalize,\n        numeric: numeric,\n        unidata_version: \"11.0.0\"\n    }\n    module.ucd_3_2_0 = {}\n    for(var key in module){\n        if(key == \"unidata_version\"){\n            module.ucd_3_2_0[key] = '3.2.0'\n        }else{\n            module.ucd_3_2_0[key] = module[key] // approximation...\n        }\n    }\n    return module\n\n})(__BRYTHON__)"], "_locale": [".js", "var am = {\n    \"C\": \"AM\",\n    \"aa\": \"saaku\",\n    \"ab\": \"AM\",\n    \"ae\": \"AM\",\n    \"af\": \"vm.\",\n    \"ak\": \"AN\",\n    \"am\": \"\\u1325\\u12cb\\u1275\",\n    \"an\": \"AM\",\n    \"ar\": \"\\u0635\",\n    \"as\": \"\\u09f0\\u09be\\u09a4\\u09bf\\u09aa\\u09c1\",\n    \"av\": \"AM\",\n    \"ay\": \"AM\",\n    \"az\": \"AM\",\n    \"ba\": \"\",\n    \"be\": \"\",\n    \"bg\": \"\",\n    \"bh\": \"AM\",\n    \"bi\": \"AM\",\n    \"bm\": \"AM\",\n    \"bn\": \"AM\",\n    \"bo\": \"\\u0f66\\u0f94\\u0f0b\\u0f51\\u0fb2\\u0f7c\",\n    \"br\": \"A.M.\",\n    \"bs\": \"prijepodne\",\n    \"ca\": \"a. m.\",\n    \"ce\": \"AM\",\n    \"ch\": \"AM\",\n    \"co\": \"\",\n    \"cr\": \"AM\",\n    \"cs\": \"dop.\",\n    \"cu\": \"\\u0414\\u041f\",\n    \"cv\": \"AM\",\n    \"cy\": \"yb\",\n    \"da\": \"\",\n    \"de\": \"\",\n    \"dv\": \"\\u0789\\u0786\",\n    \"dz\": \"\\u0f66\\u0f94\\u0f0b\\u0f46\\u0f0b\",\n    \"ee\": \"\\u014bdi\",\n    \"el\": \"\\u03c0\\u03bc\",\n    \"en\": \"AM\",\n    \"eo\": \"atm\",\n    \"es\": \"\",\n    \"et\": \"AM\",\n    \"eu\": \"AM\",\n    \"fa\": \"\\u0642.\\u0638\",\n    \"ff\": \"\",\n    \"fi\": \"ap.\",\n    \"fj\": \"AM\",\n    \"fo\": \"um fyr.\",\n    \"fr\": \"\",\n    \"fy\": \"AM\",\n    \"ga\": \"r.n.\",\n    \"gd\": \"m\",\n    \"gl\": \"a.m.\",\n    \"gn\": \"a.m.\",\n    \"gu\": \"\\u0aaa\\u0ac2\\u0ab0\\u0acd\\u0ab5\\u00a0\\u0aae\\u0aa7\\u0acd\\u0aaf\\u0abe\\u0ab9\\u0acd\\u0aa8\",\n    \"gv\": \"a.m.\",\n    \"ha\": \"AM\",\n    \"he\": \"AM\",\n    \"hi\": \"\\u092a\\u0942\\u0930\\u094d\\u0935\\u093e\\u0939\\u094d\\u0928\",\n    \"ho\": \"AM\",\n    \"hr\": \"\",\n    \"ht\": \"AM\",\n    \"hu\": \"de.\",\n    \"hy\": \"\",\n    \"hz\": \"AM\",\n    \"ia\": \"a.m.\",\n    \"id\": \"AM\",\n    \"ie\": \"AM\",\n    \"ig\": \"A.M.\",\n    \"ii\": \"\\ua0b5\\ua1aa\\ua20c\\ua210\",\n    \"ik\": \"AM\",\n    \"io\": \"AM\",\n    \"is\": \"f.h.\",\n    \"it\": \"\",\n    \"iu\": \"AM\",\n    \"ja\": \"\\u5348\\u524d\",\n    \"jv\": \"\",\n    \"ka\": \"AM\",\n    \"kg\": \"AM\",\n    \"ki\": \"Kiroko\",\n    \"kj\": \"AM\",\n    \"kk\": \"AM\",\n    \"kl\": \"\",\n    \"km\": \"\\u1796\\u17d2\\u179a\\u17b9\\u1780\",\n    \"kn\": \"\\u0caa\\u0cc2\\u0cb0\\u0ccd\\u0cb5\\u0cbe\\u0cb9\\u0ccd\\u0ca8\",\n    \"ko\": \"\\uc624\\uc804\",\n    \"kr\": \"AM\",\n    \"ks\": \"AM\",\n    \"ku\": \"\\u067e.\\u0646\",\n    \"kv\": \"AM\",\n    \"kw\": \"a.m.\",\n    \"ky\": \"\",\n    \"la\": \"\",\n    \"lb\": \"\",\n    \"lg\": \"AM\",\n    \"li\": \"AM\",\n    \"ln\": \"nt\\u0254\\u0301ng\\u0254\\u0301\",\n    \"lo\": \"\\u0e81\\u0ec8\\u0ead\\u0e99\\u0e97\\u0ec8\\u0ebd\\u0e87\",\n    \"lt\": \"prie\\u0161piet\",\n    \"lu\": \"Dinda\",\n    \"lv\": \"priek\\u0161p.\",\n    \"mg\": \"AM\",\n    \"mh\": \"AM\",\n    \"mi\": \"a.m.\",\n    \"mk\": \"\\u043f\\u0440\\u0435\\u0442\\u043f\\u043b.\",\n    \"ml\": \"AM\",\n    \"mn\": \"??\",\n    \"mo\": \"AM\",\n    \"mr\": \"\\u092e.\\u092a\\u0942.\",\n    \"ms\": \"PG\",\n    \"mt\": \"AM\",\n    \"my\": \"\\u1014\\u1036\\u1014\\u1000\\u103a\",\n    \"na\": \"AM\",\n    \"nb\": \"a.m.\",\n    \"nd\": \"AM\",\n    \"ne\": \"\\u092a\\u0942\\u0930\\u094d\\u0935\\u093e\\u0939\\u094d\\u0928\",\n    \"ng\": \"AM\",\n    \"nl\": \"\",\n    \"nn\": \"f.m.\",\n    \"no\": \"a.m.\",\n    \"nr\": \"AM\",\n    \"nv\": \"AM\",\n    \"ny\": \"AM\",\n    \"oc\": \"AM\",\n    \"oj\": \"AM\",\n    \"om\": \"WD\",\n    \"or\": \"AM\",\n    \"os\": \"AM\",\n    \"pa\": \"\\u0a38\\u0a35\\u0a47\\u0a30\",\n    \"pi\": \"AM\",\n    \"pl\": \"AM\",\n    \"ps\": \"\\u063a.\\u0645.\",\n    \"pt\": \"\",\n    \"qu\": \"a.m.\",\n    \"rc\": \"AM\",\n    \"rm\": \"AM\",\n    \"rn\": \"Z.MU.\",\n    \"ro\": \"a.m.\",\n    \"ru\": \"\",\n    \"rw\": \"AM\",\n    \"sa\": \"\\u092e\\u0927\\u094d\\u092f\\u093e\\u0928\\u092a\\u0942\\u0930\\u094d\\u0935\",\n    \"sc\": \"AM\",\n    \"sd\": \"AM\",\n    \"se\": \"i.b.\",\n    \"sg\": \"ND\",\n    \"sh\": \"AM\",\n    \"si\": \"\\u0db4\\u0dd9.\\u0dc0.\",\n    \"sk\": \"AM\",\n    \"sl\": \"dop.\",\n    \"sm\": \"AM\",\n    \"sn\": \"AM\",\n    \"so\": \"sn.\",\n    \"sq\": \"e paradites\",\n    \"sr\": \"pre podne\",\n    \"ss\": \"AM\",\n    \"st\": \"AM\",\n    \"su\": \"AM\",\n    \"sv\": \"\",\n    \"sw\": \"AM\",\n    \"ta\": \"\\u0b95\\u0bbe\\u0bb2\\u0bc8\",\n    \"te\": \"\\u0c2a\\u0c42\\u0c30\\u0c4d\\u0c35\\u0c3e\\u0c39\\u0c4d\\u0c28\",\n    \"tg\": \"\",\n    \"th\": \"AM\",\n    \"ti\": \"\\u1295\\u1309\\u1206 \\u1230\\u12d3\\u1270\",\n    \"tk\": \"\",\n    \"tl\": \"AM\",\n    \"tn\": \"AM\",\n    \"to\": \"AM\",\n    \"tr\": \"\\u00d6\\u00d6\",\n    \"ts\": \"AM\",\n    \"tt\": \"\",\n    \"tw\": \"AM\",\n    \"ty\": \"AM\",\n    \"ug\": \"\\u0686?\\u0634\\u062a\\u0649\\u0646 \\u0628?\\u0631?\\u0646\",\n    \"uk\": \"AM\",\n    \"ur\": \"AM\",\n    \"uz\": \"TO\",\n    \"ve\": \"AM\",\n    \"vi\": \"SA\",\n    \"vo\": \"AM\",\n    \"wa\": \"AM\",\n    \"wo\": \"\",\n    \"xh\": \"AM\",\n    \"yi\": \"\\ua0b5\\ua1aa\\ua20c\\ua210\",\n    \"yo\": \"\\u00c0\\u00e1r?`\",\n    \"za\": \"AM\",\n    \"zh\": \"\\u4e0a\\u5348\",\n    \"zu\": \"AM\"\n}\nvar pm = {\n    \"C\": \"PM\",\n    \"aa\": \"carra\",\n    \"ab\": \"PM\",\n    \"ae\": \"PM\",\n    \"af\": \"nm.\",\n    \"ak\": \"EW\",\n    \"am\": \"\\u12a8\\u1230\\u12d3\\u1275\",\n    \"an\": \"PM\",\n    \"ar\": \"\\u0645\",\n    \"as\": \"\\u0986\\u09ac\\u09c7\\u09b2\\u09bf\",\n    \"av\": \"PM\",\n    \"ay\": \"PM\",\n    \"az\": \"PM\",\n    \"ba\": \"\",\n    \"be\": \"\",\n    \"bg\": \"\",\n    \"bh\": \"PM\",\n    \"bi\": \"PM\",\n    \"bm\": \"PM\",\n    \"bn\": \"PM\",\n    \"bo\": \"\\u0f55\\u0fb1\\u0f72\\u0f0b\\u0f51\\u0fb2\\u0f7c\",\n    \"br\": \"G.M.\",\n    \"bs\": \"popodne\",\n    \"ca\": \"p. m.\",\n    \"ce\": \"PM\",\n    \"ch\": \"PM\",\n    \"co\": \"\",\n    \"cr\": \"PM\",\n    \"cs\": \"odp.\",\n    \"cu\": \"\\u041f\\u041f\",\n    \"cv\": \"PM\",\n    \"cy\": \"yh\",\n    \"da\": \"\",\n    \"de\": \"\",\n    \"dv\": \"\\u0789\\u078a\",\n    \"dz\": \"\\u0f55\\u0fb1\\u0f72\\u0f0b\\u0f46\\u0f0b\",\n    \"ee\": \"\\u0263etr\\u0254\",\n    \"el\": \"\\u03bc\\u03bc\",\n    \"en\": \"PM\",\n    \"eo\": \"ptm\",\n    \"es\": \"\",\n    \"et\": \"PM\",\n    \"eu\": \"PM\",\n    \"fa\": \"\\u0628.\\u0638\",\n    \"ff\": \"\",\n    \"fi\": \"ip.\",\n    \"fj\": \"PM\",\n    \"fo\": \"um sein.\",\n    \"fr\": \"\",\n    \"fy\": \"PM\",\n    \"ga\": \"i.n.\",\n    \"gd\": \"f\",\n    \"gl\": \"p.m.\",\n    \"gn\": \"p.m.\",\n    \"gu\": \"\\u0a89\\u0aa4\\u0acd\\u0aa4\\u0ab0\\u00a0\\u0aae\\u0aa7\\u0acd\\u0aaf\\u0abe\\u0ab9\\u0acd\\u0aa8\",\n    \"gv\": \"p.m.\",\n    \"ha\": \"PM\",\n    \"he\": \"PM\",\n    \"hi\": \"\\u0905\\u092a\\u0930\\u093e\\u0939\\u094d\\u0928\",\n    \"ho\": \"PM\",\n    \"hr\": \"\",\n    \"ht\": \"PM\",\n    \"hu\": \"du.\",\n    \"hy\": \"\",\n    \"hz\": \"PM\",\n    \"ia\": \"p.m.\",\n    \"id\": \"PM\",\n    \"ie\": \"PM\",\n    \"ig\": \"P.M.\",\n    \"ii\": \"\\ua0b5\\ua1aa\\ua20c\\ua248\",\n    \"ik\": \"PM\",\n    \"io\": \"PM\",\n    \"is\": \"e.h.\",\n    \"it\": \"\",\n    \"iu\": \"PM\",\n    \"ja\": \"\\u5348\\u5f8c\",\n    \"jv\": \"\",\n    \"ka\": \"PM\",\n    \"kg\": \"PM\",\n    \"ki\": \"Hwa\\u0129-in\\u0129\",\n    \"kj\": \"PM\",\n    \"kk\": \"PM\",\n    \"kl\": \"\",\n    \"km\": \"\\u179b\\u17d2\\u1784\\u17b6\\u1785\",\n    \"kn\": \"\\u0c85\\u0caa\\u0cb0\\u0cbe\\u0cb9\\u0ccd\\u0ca8\",\n    \"ko\": \"\\uc624\\ud6c4\",\n    \"kr\": \"PM\",\n    \"ks\": \"PM\",\n    \"ku\": \"\\u062f.\\u0646\",\n    \"kv\": \"PM\",\n    \"kw\": \"p.m.\",\n    \"ky\": \"\",\n    \"la\": \"\",\n    \"lb\": \"\",\n    \"lg\": \"PM\",\n    \"li\": \"PM\",\n    \"ln\": \"mp\\u00f3kwa\",\n    \"lo\": \"\\u0eab\\u0ebc\\u0eb1\\u0e87\\u0e97\\u0ec8\\u0ebd\\u0e87\",\n    \"lt\": \"popiet\",\n    \"lu\": \"Dilolo\",\n    \"lv\": \"p\\u0113cp.\",\n    \"mg\": \"PM\",\n    \"mh\": \"PM\",\n    \"mi\": \"p.m.\",\n    \"mk\": \"\\u043f\\u043e\\u043f\\u043b.\",\n    \"ml\": \"PM\",\n    \"mn\": \"?\\u0425\",\n    \"mo\": \"PM\",\n    \"mr\": \"\\u092e.\\u0928\\u0902.\",\n    \"ms\": \"PTG\",\n    \"mt\": \"PM\",\n    \"my\": \"\\u100a\\u1014\\u1031\",\n    \"na\": \"PM\",\n    \"nb\": \"p.m.\",\n    \"nd\": \"PM\",\n    \"ne\": \"\\u0905\\u092a\\u0930\\u093e\\u0939\\u094d\\u0928\",\n    \"ng\": \"PM\",\n    \"nl\": \"\",\n    \"nn\": \"e.m.\",\n    \"no\": \"p.m.\",\n    \"nr\": \"PM\",\n    \"nv\": \"PM\",\n    \"ny\": \"PM\",\n    \"oc\": \"PM\",\n    \"oj\": \"PM\",\n    \"om\": \"WB\",\n    \"or\": \"PM\",\n    \"os\": \"PM\",\n    \"pa\": \"\\u0a36\\u0a3e\\u0a2e\",\n    \"pi\": \"PM\",\n    \"pl\": \"PM\",\n    \"ps\": \"\\u063a.\\u0648.\",\n    \"pt\": \"\",\n    \"qu\": \"p.m.\",\n    \"rc\": \"PM\",\n    \"rm\": \"PM\",\n    \"rn\": \"Z.MW.\",\n    \"ro\": \"p.m.\",\n    \"ru\": \"\",\n    \"rw\": \"PM\",\n    \"sa\": \"\\u092e\\u0927\\u094d\\u092f\\u093e\\u0928\\u092a\\u091a\\u094d\\u092f\\u093e\\u0924\",\n    \"sc\": \"PM\",\n    \"sd\": \"PM\",\n    \"se\": \"e.b.\",\n    \"sg\": \"LK\",\n    \"sh\": \"PM\",\n    \"si\": \"\\u0db4.\\u0dc0.\",\n    \"sk\": \"PM\",\n    \"sl\": \"pop.\",\n    \"sm\": \"PM\",\n    \"sn\": \"PM\",\n    \"so\": \"gn.\",\n    \"sq\": \"e pasdites\",\n    \"sr\": \"po podne\",\n    \"ss\": \"PM\",\n    \"st\": \"PM\",\n    \"su\": \"PM\",\n    \"sv\": \"\",\n    \"sw\": \"PM\",\n    \"ta\": \"\\u0bae\\u0bbe\\u0bb2\\u0bc8\",\n    \"te\": \"\\u0c05\\u0c2a\\u0c30\\u0c3e\\u0c39\\u0c4d\\u0c28\",\n    \"tg\": \"\",\n    \"th\": \"PM\",\n    \"ti\": \"\\u12f5\\u1215\\u122d \\u1230\\u12d3\\u1275\",\n    \"tk\": \"\",\n    \"tl\": \"PM\",\n    \"tn\": \"PM\",\n    \"to\": \"PM\",\n    \"tr\": \"\\u00d6S\",\n    \"ts\": \"PM\",\n    \"tt\": \"\",\n    \"tw\": \"PM\",\n    \"ty\": \"PM\",\n    \"ug\": \"\\u0686?\\u0634\\u062a\\u0649\\u0646 \\u0643?\\u064a\\u0649\\u0646\",\n    \"uk\": \"PM\",\n    \"ur\": \"PM\",\n    \"uz\": \"TK\",\n    \"ve\": \"PM\",\n    \"vi\": \"CH\",\n    \"vo\": \"PM\",\n    \"wa\": \"PM\",\n    \"wo\": \"\",\n    \"xh\": \"PM\",\n    \"yi\": \"\\ua0b5\\ua1aa\\ua20c\\ua248\",\n    \"yo\": \"?`s\\u00e1n\",\n    \"za\": \"PM\",\n    \"zh\": \"\\u4e0b\\u5348\",\n    \"zu\": \"PM\"\n}\n\nvar X_format = {\n    \"%H:%M:%S\": [\n        \"C\",\n        \"ab\",\n        \"ae\",\n        \"af\",\n        \"an\",\n        \"av\",\n        \"ay\",\n        \"az\",\n        \"ba\",\n        \"be\",\n        \"bg\",\n        \"bh\",\n        \"bi\",\n        \"bm\",\n        \"bo\",\n        \"br\",\n        \"bs\",\n        \"ca\",\n        \"ce\",\n        \"ch\",\n        \"co\",\n        \"cr\",\n        \"cs\",\n        \"cu\",\n        \"cv\",\n        \"cy\",\n        \"da\",\n        \"de\",\n        \"dv\",\n        \"eo\",\n        \"es\",\n        \"et\",\n        \"eu\",\n        \"ff\",\n        \"fj\",\n        \"fo\",\n        \"fr\",\n        \"fy\",\n        \"ga\",\n        \"gd\",\n        \"gl\",\n        \"gn\",\n        \"gu\",\n        \"gv\",\n        \"ha\",\n        \"he\",\n        \"hi\",\n        \"ho\",\n        \"hr\",\n        \"ht\",\n        \"hu\",\n        \"hy\",\n        \"hz\",\n        \"ia\",\n        \"ie\",\n        \"ig\",\n        \"ik\",\n        \"io\",\n        \"is\",\n        \"it\",\n        \"ja\",\n        \"ka\",\n        \"kg\",\n        \"ki\",\n        \"kj\",\n        \"kk\",\n        \"kl\",\n        \"km\",\n        \"kn\",\n        \"kv\",\n        \"kw\",\n        \"ky\",\n        \"la\",\n        \"lb\",\n        \"lg\",\n        \"li\",\n        \"ln\",\n        \"lo\",\n        \"lt\",\n        \"lu\",\n        \"lv\",\n        \"mg\",\n        \"mh\",\n        \"mk\",\n        \"mn\",\n        \"mo\",\n        \"mr\",\n        \"mt\",\n        \"my\",\n        \"na\",\n        \"nb\",\n        \"nd\",\n        \"ng\",\n        \"nl\",\n        \"nn\",\n        \"no\",\n        \"nr\",\n        \"nv\",\n        \"ny\",\n        \"oj\",\n        \"or\",\n        \"os\",\n        \"pi\",\n        \"pl\",\n        \"ps\",\n        \"pt\",\n        \"rc\",\n        \"rm\",\n        \"rn\",\n        \"ro\",\n        \"ru\",\n        \"rw\",\n        \"sa\",\n        \"sc\",\n        \"se\",\n        \"sg\",\n        \"sh\",\n        \"sk\",\n        \"sl\",\n        \"sm\",\n        \"sn\",\n        \"sr\",\n        \"ss\",\n        \"st\",\n        \"su\",\n        \"sv\",\n        \"sw\",\n        \"ta\",\n        \"te\",\n        \"tg\",\n        \"th\",\n        \"tk\",\n        \"tl\",\n        \"tn\",\n        \"tr\",\n        \"ts\",\n        \"tt\",\n        \"tw\",\n        \"ty\",\n        \"ug\",\n        \"uk\",\n        \"uz\",\n        \"ve\",\n        \"vo\",\n        \"wa\",\n        \"wo\",\n        \"xh\",\n        \"yo\",\n        \"za\",\n        \"zh\",\n        \"zu\"\n    ],\n    \"%i:%M:%S %p\": [\n        \"aa\",\n        \"ak\",\n        \"am\",\n        \"bn\",\n        \"el\",\n        \"en\",\n        \"iu\",\n        \"kr\",\n        \"ks\",\n        \"mi\",\n        \"ml\",\n        \"ms\",\n        \"ne\",\n        \"om\",\n        \"sd\",\n        \"so\",\n        \"sq\",\n        \"ti\",\n        \"to\",\n        \"ur\",\n        \"vi\"\n    ],\n    \"%I:%M:%S %p\": [\n        \"ar\",\n        \"fa\",\n        \"ku\",\n        \"qu\"\n    ],\n    \"%p %i:%M:%S\": [\n        \"as\",\n        \"ii\",\n        \"ko\",\n        \"yi\"\n    ],\n    \"\\u0f46\\u0f74\\u0f0b\\u0f5a\\u0f7c\\u0f51\\u0f0b%i:%M:%S %p\": [\n        \"dz\"\n    ],\n    \"%p ga %i:%M:%S\": [\n        \"ee\"\n    ],\n    \"%H.%M.%S\": [\n        \"fi\",\n        \"id\",\n        \"jv\",\n        \"oc\",\n        \"si\"\n    ],\n    \"%p %I:%M:%S\": [\n        \"pa\"\n    ]\n}\nvar x_format = {\n    \"%m/%d/%y\": [\n        \"C\"\n    ],\n    \"%d/%m/%Y\": [\n        \"aa\",\n        \"am\",\n        \"bm\",\n        \"bn\",\n        \"ca\",\n        \"co\",\n        \"cy\",\n        \"el\",\n        \"es\",\n        \"ff\",\n        \"fr\",\n        \"ga\",\n        \"gd\",\n        \"gl\",\n        \"gn\",\n        \"gv\",\n        \"ha\",\n        \"he\",\n        \"id\",\n        \"ig\",\n        \"it\",\n        \"iu\",\n        \"jv\",\n        \"ki\",\n        \"kr\",\n        \"kw\",\n        \"la\",\n        \"lg\",\n        \"ln\",\n        \"lo\",\n        \"lu\",\n        \"mi\",\n        \"ml\",\n        \"ms\",\n        \"mt\",\n        \"nd\",\n        \"oc\",\n        \"om\",\n        \"pt\",\n        \"qu\",\n        \"rn\",\n        \"sd\",\n        \"sg\",\n        \"so\",\n        \"sw\",\n        \"ti\",\n        \"to\",\n        \"uk\",\n        \"ur\",\n        \"uz\",\n        \"vi\",\n        \"wo\",\n        \"yo\"\n    ],\n    \"%m/%d/%Y\": [\n        \"ab\",\n        \"ae\",\n        \"an\",\n        \"av\",\n        \"ay\",\n        \"bh\",\n        \"bi\",\n        \"ch\",\n        \"cr\",\n        \"cv\",\n        \"ee\",\n        \"en\",\n        \"fj\",\n        \"ho\",\n        \"ht\",\n        \"hz\",\n        \"ie\",\n        \"ik\",\n        \"io\",\n        \"kg\",\n        \"kj\",\n        \"ks\",\n        \"kv\",\n        \"li\",\n        \"mh\",\n        \"mo\",\n        \"na\",\n        \"ne\",\n        \"ng\",\n        \"nv\",\n        \"ny\",\n        \"oj\",\n        \"pi\",\n        \"rc\",\n        \"sc\",\n        \"sh\",\n        \"sm\",\n        \"su\",\n        \"tl\",\n        \"tw\",\n        \"ty\",\n        \"wa\",\n        \"za\",\n        \"zu\"\n    ],\n    \"%Y-%m-%d\": [\n        \"af\",\n        \"br\",\n        \"ce\",\n        \"dz\",\n        \"eo\",\n        \"ko\",\n        \"lt\",\n        \"mg\",\n        \"nr\",\n        \"rw\",\n        \"se\",\n        \"si\",\n        \"sn\",\n        \"ss\",\n        \"st\",\n        \"sv\",\n        \"tn\",\n        \"ts\",\n        \"ug\",\n        \"ve\",\n        \"vo\",\n        \"xh\"\n    ],\n    \"%Y/%m/%d\": [\n        \"ak\",\n        \"bo\",\n        \"eu\",\n        \"ia\",\n        \"ii\",\n        \"ja\",\n        \"ku\",\n        \"yi\",\n        \"zh\"\n    ],\n    \"null\": [\n        \"ar\",\n        \"fa\",\n        \"ps\",\n        \"th\"\n    ],\n    \"%d-%m-%Y\": [\n        \"as\",\n        \"da\",\n        \"fy\",\n        \"hi\",\n        \"kl\",\n        \"mr\",\n        \"my\",\n        \"nl\",\n        \"rm\",\n        \"sa\",\n        \"ta\"\n    ],\n    \"%d.%m.%Y\": [\n        \"az\",\n        \"cs\",\n        \"de\",\n        \"et\",\n        \"fi\",\n        \"fo\",\n        \"hy\",\n        \"is\",\n        \"ka\",\n        \"kk\",\n        \"lv\",\n        \"mk\",\n        \"nb\",\n        \"nn\",\n        \"no\",\n        \"os\",\n        \"pl\",\n        \"ro\",\n        \"ru\",\n        \"sq\",\n        \"tg\",\n        \"tr\",\n        \"tt\"\n    ],\n    \"%d.%m.%y\": [\n        \"ba\",\n        \"be\",\n        \"lb\"\n    ],\n    \"%d.%m.%Y \\u0433.\": [\n        \"bg\"\n    ],\n    \"%d.%m.%Y.\": [\n        \"bs\",\n        \"hr\",\n        \"sr\"\n    ],\n    \"%Y.%m.%d\": [\n        \"cu\",\n        \"mn\"\n    ],\n    \"%d/%m/%y\": [\n        \"dv\",\n        \"km\"\n    ],\n    \"%d-%m-%y\": [\n        \"gu\",\n        \"kn\",\n        \"or\",\n        \"pa\",\n        \"te\"\n    ],\n    \"%Y. %m. %d.\": [\n        \"hu\"\n    ],\n    \"%d-%b %y\": [\n        \"ky\"\n    ],\n    \"%d. %m. %Y\": [\n        \"sk\",\n        \"sl\"\n    ],\n    \"%d.%m.%y \\u00fd.\": [\n        \"tk\"\n    ]\n}\n\n\nvar $module=(function($B){\n    var _b_ = $B.builtins\n    return {\n        CHAR_MAX: 127,\n        LC_ALL: 6,\n        LC_COLLATE: 3,\n        LC_CTYPE: 0,\n        LC_MESSAGES: 5,\n        LC_MONETARY: 4,\n        LC_NUMERIC: 1,\n        LC_TIME: 2,\n        Error: _b_.ValueError,\n\n        _date_format: function(spec, hour){\n            var t,\n                locale = __BRYTHON__.locale.substr(0, 2)\n\n            if(spec == \"p\"){\n                var res = hours < 12 ? am[locale] : pm[locale]\n                if(res === undefined){\n                    throw _b_.ValueError.$factory(\"no format \" + spec + \" for locale \" +\n                        locale)\n                }\n                return res\n            }\n            else if(spec == \"x\"){\n                t = x_format\n            }else if(spec == \"X\"){\n                t = X_format\n            }else{\n                throw _b_.ValueError.$factory(\"invalid format\", spec)\n            }\n            for(var key in t){\n                if(t[key].indexOf(locale) > -1){\n                    return key\n                }\n            }\n            throw _b_.ValueError.$factory(\"no format \" + spec + \" for locale \" +\n                locale)\n        },\n\n        localeconv: function(){\n            var conv = {'grouping': [127],\n                    'currency_symbol': '',\n                    'n_sign_posn': 127,\n                    'p_cs_precedes': 127,\n                    'n_cs_precedes': 127,\n                    'mon_grouping': [],\n                    'n_sep_by_space': 127,\n                    'decimal_point': '.',\n                    'negative_sign': '',\n                    'positive_sign': '',\n                    'p_sep_by_space': 127,\n                    'int_curr_symbol': '',\n                    'p_sign_posn': 127,\n                    'thousands_sep': '',\n                    'mon_thousands_sep': '',\n                    'frac_digits': 127,\n                    'mon_decimal_point': '',\n                    'int_frac_digits': 127\n             }\n             var res = $B.empty_dict()\n             for(var key in conv){\n                 res.$string_dict[key] = [conv, res.$order++]\n             }\n             return res\n         },\n\n        setlocale : function(){\n            var $ = $B.args(\"setlocale\", 2, {category: null, locale: null},\n                [\"category\", \"locale\"], arguments, {locale: _b_.None},\n                null, null)\n            /// XXX category is currently ignored\n            if($.locale == \"\"){\n                // use browser language setting, if it is set\n                var LANG = ($B.language || \"\").substr(0, 2)\n                if(am.hasOwnProperty(LANG)){\n                    $B.locale = LANG\n                    return LANG\n                }else{\n                    console.log(\"Unknown locale: \" + LANG)\n                }\n            }else if($.locale === _b_.None){\n                // return current locale\n                return $B.locale\n            }else{\n                // Only use 2 first characters\n                try{$.locale.substr(0, 2)}\n                catch(err){\n                    throw $module.Error.$factory(\"Invalid locale: \" + $.locale)\n                }\n                if(am.hasOwnProperty($.locale.substr(0, 2))){\n                    $B.locale = $.locale\n                    return $.locale\n                }else{\n                    throw $module.Error.$factory(\"Unknown locale: \" + $.locale)\n                }\n            }\n        }\n    }\n})(__BRYTHON__)\n"], "dis": [".js", "var $module=(function($B){\n\nvar dict = $B.builtins.dict\nvar mod = {\n    dis:function(src){\n        $B.$py_module_path['__main__'] = $B.brython_path\n        return __BRYTHON__.py2js(src,'__main__','__main__',\n            $B.builtins_scope).to_js()\n    },\n    OPTIMIZED: 1,\n    NEWLOCALS: 2,\n    VARARGS: 4,\n    VARKEYWORDS: 8,\n    NESTED: 16,\n    GENERATOR: 32,\n    NOFREE: 64,\n    COROUTINE: 128,\n    ITERABLE_COROUTINE: 256,\n    ASYNC_GENERATOR: 512,\n    COMPILER_FLAG_NAMES: $B.builtins.dict.$factory()\n}\nmod.COMPILER_FLAG_NAMES = dict.$factory([\n     [1, \"OPTIMIZED\"],\n     [2, \"NEWLOCALS\"],\n     [4, \"VARARGS\"],\n     [8, \"VARKEYWORDS\"],\n    [16, \"NESTED\"],\n    [32, \"GENERATOR\"],\n    [64, \"NOFREE\"],\n   [128, \"COROUTINE\"],\n   [256, \"ITERABLE_COROUTINE\"],\n   [512, \"ASYNC_GENERATOR\"]\n])\n\nreturn mod\n\n})(__BRYTHON__)"], "_strptime": [".js", "var _b_ = __BRYTHON__.builtins\n\nvar $module = (function($B){\n    return {\n        _strptime_datetime: function(cls, s, fmt){\n            var pos_s = 0,\n                pos_fmt = 0,\n                dt = {}\n            function error(){\n                throw Error(\"no match \" + pos_s + \" \" + s.charAt(pos_s) + \" \"+\n                    pos_fmt + \" \" + fmt.charAt(pos_fmt))\n            }\n\n            var locale = __BRYTHON__.locale,\n                shortdays = [],\n                longdays = [],\n                conv_func = locale == \"C\" ?\n                    function(d){return d.toDateString()} :\n                    function(d, options){\n                        return d.toLocaleDateString(locale, options)\n                    }\n\n            for(var day = 16; day < 23; day++){\n                var d = new Date(Date.UTC(2012, 11, day, 3, 0, 0))\n                shortdays.push(conv_func(d, {weekday: 'short'}))\n                longdays.push(conv_func(d, {weekday: 'long'}))\n            }\n\n            var shortmonths = [],\n                longmonths = []\n\n            for(var month = 0; month < 12; month++){\n                var d = new Date(Date.UTC(2012, month, 1, 3, 0, 0))\n                shortmonths.push(conv_func(d, {month: 'short'}))\n                longmonths.push(conv_func(d, {month: 'long'}))\n            }\n\n            var shortdays_re = new RegExp(shortdays.join(\"|\").replace(\".\", \"\\\\.\")),\n                longdays_re = new RegExp(longdays.join(\"|\")),\n                shortmonths_re = new RegExp(shortmonths.join(\"|\").replace(\".\", \"\\\\.\")),\n                longmonths_re = new RegExp(longmonths.join(\"|\"))\n\n            var regexps = {\n                d: [\"day\", new RegExp(\"0[1-9]|[123][0-9]\")],\n                f: [\"microsecond\", new RegExp(\"(\\\\d{1,6})\")],\n                H: [\"hour\", new RegExp(\"[01][0-9]|2[0-3]|\\\\d\")],\n                I: [\"hour\", new RegExp(\"0[0-9]|1[0-2]\")],\n                m: [\"month\", new RegExp(\"0[1-9]|1[012]\")],\n                M: [\"minute\", new RegExp(\"[0-5][0-9]\")],\n                S: [\"second\", new RegExp(\"([1-5]\\\\d)|(0?\\\\d)\")],\n                y: [\"year\", new RegExp(\"0{0,2}\\\\d{2}\")],\n                Y: [\"year\", new RegExp(\"\\\\d{4}\")],\n                z: [\"tzinfo\", new RegExp(\"Z\")]\n            }\n\n            while(pos_fmt < fmt.length){\n                var car = fmt.charAt(pos_fmt)\n                if(car == \"%\"){\n                    var spec = fmt.charAt(pos_fmt + 1),\n                        regexp = regexps[spec]\n                    if(regexp !== undefined){\n                        var re = regexp[1],\n                            attr = regexp[0],\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            if(dt[attr] !== undefined){\n                                throw Error(attr + \" is defined more than once\")\n                            }else{\n                                dt[attr] = parseInt(res[0])\n                                if(attr == \"microsecond\"){\n                                    while(dt[attr] < 100000){\n                                        dt[attr] *= 10\n                                    }\n                                }else if(attr == \"tzinfo\"){\n                                    // Only value supported for the moment : Z\n                                    // (UTC)\n                                    var dt_module = $B.imported[cls.__module__]\n                                    dt.tzinfo = dt_module.timezone.utc\n                                }\n                                pos_fmt += 2\n                                pos_s += res[0].length\n                            }\n                        }\n                    }else if(spec == \"a\" || spec == \"A\"){\n                        // Locale's abbreviated (a) or full (A) weekday name\n                        var attr = \"weekday\",\n                            re = spec == \"a\" ? shortdays_re : longdays_re,\n                            t = spec == \"a\" ? shortdays : longdays\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        if(dt.weekday !== undefined){\n                            throw Error(attr + \" is defined more than once\")\n                        }else{\n                            dt.weekday = ix\n                        }\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"b\" || spec == \"B\"){\n                        // Locales's abbreviated (b) or full (B) month\n                        var attr = \"month\",\n                            re = spec == \"b\" ? shortmonths_re : longmonths_re,\n                            t = spec == \"b\" ? shortmonths : longmonths,\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        if(dt.month !== undefined){\n                            throw Error(attr + \" is defined more than once\")\n                        }else{\n                            dt.month = ix + 1\n                        }\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"c\"){\n                        // Locale's appropriate date and time representation\n                        var fmt1 = fmt.substr(0, pos_fmt - 1) + _locale_c_format() +\n                            fmt.substr(pos_fmt + 2)\n                        fmt = fmt1\n                    }else if(spec == \"%\"){\n                        if(s.charAt(pos_s) == \"%\"){\n                            pos_fmt++\n                            pos_s++\n                        }else{\n                            error()\n                        }\n                    }else{\n                        pos_fmt++\n                    }\n                }else{\n                    if(car == s.charAt(pos_s)){\n                        pos_fmt++\n                        pos_s++\n                    }else{\n                        error()\n                    }\n                }\n            }\n            return $B.$call(cls)(dt.year, dt.month, dt.day,\n                dt.hour || 0, dt.minute || 0, dt.second || 0,\n                dt.microsecond || 0, dt.tzinfo || _b_.None)\n        }\n    }\n})(__BRYTHON__)\n"], "array": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins,\n    $s = [],\n    i\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\nvar typecodes = {\n    'b': Int8Array,    // signed char, 1 byte\n    'B': Uint8Array,   // unsigned char, 1\n    'u': null,         // Py_UNICODE Unicode character, 2 (deprecated)\n    'h': Int16Array,   // signed short, 2\n    'H': Uint16Array,  // unsigned short, 2\n    'i': Int16Array,   //  signed int, 2\n    'I': Uint16Array,  // unsigned int, 2\n    'l': Int32Array,   // signed long, 4\n    'L': Uint32Array,  // unsigned long, 4\n    'q': null,         // signed long, 8 (not implemented)\n    'Q': null,         // unsigned long, 8 (not implemented)\n    'f': Float32Array, // float, 4\n    'd': Float64Array  // double float, 8\n}\n\nvar array = $B.make_class(\"array\",\n    function(){\n        var missing = {},\n            $ = $B.args(\"array\", 2, {typecode: null, initializer: null},\n                [\"typecode\", \"initializer\"], arguments, {initializer: missing},\n                null, null),\n            typecode = $.typecode,\n            initializer = $.initializer\n        if(! typecodes.hasOwnProperty(typecode)){\n            throw _b_.ValueError.$factory(\"bad typecode (must be b, \" +\n                \"B, u, h, H, i, I, l, L, q, Q, f or d)\")\n        }\n        if(typecodes[typecode] === null){\n            throw _b_.NotImplementedError.$factory(\"type code \" +\n                typecode + \"is not implemented\")\n        }\n        var res = {\n            __class__: array,\n            typecode: typecode,\n            obj: null\n        }\n        if(initializer !== missing){\n            if(Array.isArray(initializer)){\n                array.fromlist(res, initializer)\n            }else if(_b_.isinstance(initializer, _b_.bytes)){\n                array.frombytes(res, initializer)\n            }else{\n                array.extend(res, initializer)\n            }\n        }\n        return res\n    }\n)\n\narray.$buffer_protocol = true\n\narray.__getitem__ = function(self, key){\n    if(self.obj && self.obj[key] !== undefined){\n        return self.obj[key]\n    }\n    throw _b_.IndexError(\"array index out of range\")\n}\n\nvar array_iterator = $B.make_iterator_class(\"array_iterator\")\narray.__iter__ = function(self){\n    return array_iterator.$factory(self.obj)\n}\n\narray.__len__ = function(self){\n    return self.obj.length\n}\n\narray.__str__ = function(self){\n    $B.args(\"__str__\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var res = \"array('\" + self.typecode + \"'\"\n    if(self.obj !== null){\n        res += \", [\" + self.obj + \"]\"\n    }\n    return res + \")\"\n}\n\nfunction normalize_index(self, i){\n    // return an index i between 0 and self.obj.length - 1\n    if(i < 0){\n        i = self.obj.length + i\n    }\n    if(i < 0){i = 0}\n    else if(i > self.obj.length - 1){\n        i = self.obj.length\n    }\n    return i\n}\n\narray.append = function(self, value){\n    $B.args(\"append\", 2, {self: null, value: null},\n        [\"self\", \"value\"], arguments, {}, null, null)\n    var pos = self.obj === null ? 0 : self.obj.length\n    return array.insert(self, pos, value)\n}\n\narray.count = function(self, x){\n    $B.args(\"count\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    if(self.obj === null){return 0}\n    return self.obj.filter(function(item){return item == x}).length\n}\n\narray.extend = function(self, iterable){\n    $B.args(\"extend\", 2, {self: null, iterable: null},\n        [\"self\", \"iterable\"], arguments, {}, null, null)\n    if(iterable.__class__ === array){\n        if(iterable.typecode !== self.typecode){\n            throw _b_.TypeError.$factory(\"can only extend with array \" +\n                \"of same kind\")\n        }\n        if(iterable.obj === null){return _b_.None}\n        // create new object with length = sum of lengths\n        var newobj = new typecodes[self.typecode](self.obj.length +\n            iterable.obj.length)\n        // copy self.obj\n        newobj.set(self.obj)\n        // copy iterable.obj\n        newobj.set(iterable.obj, self.obj.length)\n        self.obj = newobj\n    }else{\n        var it = _b_.iter(iterable)\n        while(true){\n            try{\n                var item = _b_.next(it)\n                array.append(self, item)\n            }catch(err){\n                if(err.__class__ !== _b_.StopIteration){\n                    throw err\n                }\n                break\n            }\n        }\n    }\n    return _b_.None\n}\n\narray.frombytes = function(self, s){\n    $B.args(\"frombytes\", 2, {self: null, s: null},\n        [\"self\", \"s\"], arguments, {}, null, null)\n    if(! _b_.isinstance(s, _b_.bytes)){\n        throw _b_.TypeError.$factory(\"a bytes-like object is required, \" +\n            \"not '\" + $B.class_name(s) + \"'\")\n    }\n    self.obj = new typecodes[self.typecode](s.source)\n    return None\n}\n\narray.fromlist = function(self, list){\n    $B.args(\"fromlist\", 2, {self: null, list: null},\n        [\"self\", \"list\"], arguments, {}, null, null)\n    var it = _b_.iter(list)\n    while(true){\n        try{\n            var item = _b_.next(it)\n            try{\n                array.append(self, item)\n            }catch(err){\n                console.log(err)\n                return _b_.None\n            }\n        }catch(err){\n            if(err.__class__ === _b_.StopIteration){\n                return _b_.None\n            }\n            throw err\n        }\n    }\n}\n\narray.fromstring = array.frombytes\n\narray.index = function(self, x){\n    $B.args(\"index\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.index(x): x not in array\")\n    }\n    return res\n}\n\narray.insert = function(self, i, value){\n    $B.args(\"insert\", 3, {self: null, i: null, value: null},\n        [\"self\", \"i\", \"value\"], arguments, {}, null, null)\n    if(self.obj === null){\n        self.obj = [value]\n    }else{\n        self.obj.splice(i, 0, value)\n    }\n    return _b_.None\n}\n\narray.itemsize = function(self){\n    return typecodes[self.typecode].BYTES_PER_ELEMENT\n}\n\narray.pop = function(self, i){\n    var $ = $B.args(\"count\", 2, {self: null, i: null},\n        [\"self\", \"i\"], arguments, {i: -1}, null, null)\n    i = $.i\n    if(self.obj === null){\n        throw _b_.IndexError.$factory(\"pop from empty array\")\n    }else if(self.obj.length == 1){\n        var res = self.obj[0]\n        self.obj = null\n        return res\n    }\n    i = normalize_index(self, i)\n    // store value to return\n    var res = self.obj[i]\n    // create new array, size = previous size - 1\n    var newobj = new typecodes[self.typecode](self.obj.length - 1)\n    // fill new array with values until i excluded\n    newobj.set(self.obj.slice(0, i))\n    // fill with values after i\n    newobj.set(self.obj.slice(i + 1), i)\n    // set self.obj to new array\n    self.obj = newobj\n    // return stored value\n    return res\n}\n\narray.remove = function(self, x){\n    $B.args(\"remove\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.remove(x): x not in array\")\n    }\n    array.pop(self, res)\n    return _b_.None\n}\n\narray.reverse = function(self){\n    $B.args(\"reverse\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){return _b_.None}\n    self.obj.reverse()\n    return _b_.None\n}\n\narray.tobytes = function(self){\n    $B.args(\"tobytes\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var items = Array.prototype.slice.call(self.obj),\n        res = []\n    items.forEach(function(item){\n        while(item > 256){\n            res.push(item % 256)\n            item = Math.floor(item / 256)\n        }\n        res.push(item)\n    })\n    return _b_.bytes.$factory(res)\n}\n\narray.tolist = function(self){\n    $B.args(\"tolist\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    return Array.prototype.slice.call(self.obj)\n}\n\narray.tostring = array.tobytes\n\narray.typecode = function(self){\n    return self.typecode\n}\n\n$B.set_func_names(array, \"array\")\n\nreturn {\n    array: array,\n    typecodes: Object.keys(typecodes).join('')\n}\n\n})(__BRYTHON__)\n"], "_profile": [".js", "// Private interface to the profiling instrumentation implemented in py_utils.js.\n// Uses local a copy of the eval function from py_builtin_functions.js\n\nvar $module=(function($B) {\n    eval($B.InjectBuiltins());\n    return {\n        brython:$B,\n        data:$B.$profile_data,\n        start:$B.$profile.start,\n        stop:$B.$profile.stop,\n        pause:$B.$profile.pause,\n        status:$B.$profile.status,\n        clear:$B.$profile.clear,\n        elapsed:$B.$profile.elapsed,\n        run:function(src,_globals,_locals,nruns) {\n            var current_frame = $B.frames_stack[$B.frames_stack.length-1]\n            if(current_frame!==undefined){\n                var current_locals_id = current_frame[0].replace(/\\./,'_'),\n             current_globals_id = current_frame[2].replace(/\\./,'_')\n            }\n\n            var is_exec = true,\n                leave = false\n\n            // code will be run in a specific block\n            var globals_id = '$profile_'+$B.UUID(),\n             locals_id\n\n             if(_locals===_globals){\n                 locals_id = globals_id\n             }else{\n                 locals_id = '$profile_'+$B.UUID()\n             }\n             // Initialise the object for block namespaces\n             eval('var $locals_'+globals_id+' = {}\\nvar $locals_'+locals_id+' = {}')\n\n             // Initialise block globals\n\n            // A _globals dictionary is provided, set or reuse its attribute\n            // globals_id\n            _globals.globals_id = _globals.globals_id || globals_id\n            globals_id = _globals.globals_id\n\n            if(_locals === _globals || _locals === undefined){\n                locals_id = globals_id\n                parent_scope = $B.builtins_scope\n            }else{\n                // The parent block of locals must be set to globals\n                parent_scope = {\n                    id: globals_id,\n                    parent_block: $B.builtins_scope,\n                    binding: {}\n                }\n                for(var attr in _globals.$string_dict){\n                    parent_scope.binding[attr] = true\n                }\n            }\n\n            // Initialise block globals\n            if(_globals.$jsobj){var items = _globals.$jsobj}\n            else{var items = _globals.$string_dict}\n            for(var item in items){\n                item1 = to_alias(item)\n                try{\n                    eval('$locals_' + globals_id + '[\"' + item1 +\n                        '\"] = items[item]')\n                }catch(err){\n                    console.log(err)\n                    console.log('error setting', item)\n                    break\n                }\n            }\n\n             // Initialise block locals\n            var items = _b_.dict.items(_locals), item\n            if(_locals.$jsobj){var items = _locals.$jsobj}\n            else{var items = _locals.$string_dict}\n            for(var item in items){\n                item1 = to_alias(item)\n                try{\n                    eval('$locals_' + locals_id + '[\"' + item[0] + '\"] = item[1]')\n                }catch(err){\n                    console.log(err)\n                    console.log('error setting', item)\n                    break\n                }\n            }\n             //var nb_modules = Object.keys(__BRYTHON__.modules).length\n             //console.log('before exec', nb_modules)\n\n            console.log(\"call py2js\", src, globals_id, locals_id, parent_scope)\n            var root = $B.py2js(src, globals_id, locals_id, parent_scope),\n                js, gns, lns\n\n             try{\n\n                 var js = root.to_js()\n\n                     var i,res,gns;\n                     for(i=0;i<nruns;i++) {\n                         res = eval(js)\n                         gns = eval('$locals_'+globals_id)\n                     }\n\n                     // Update _locals with the namespace after execution\n                     if(_locals!==undefined){\n                         var lns = eval('$locals_'+locals_id)\n                         var setitem = getattr(_locals,'__setitem__')\n                         for(var attr in lns){\n                             if(attr.charAt(0)=='$'){continue}\n                             setitem(attr, lns[attr])\n                         }\n                     }else{\n                         for(var attr in lns){current_frame[1][attr] = lns[attr]}\n                     }\n\n                     if(_globals!==undefined){\n                         // Update _globals with the namespace after execution\n                         var setitem = getattr(_globals,'__setitem__')\n                         for(var attr in gns){\n                             if(attr.charAt(0)=='$'){continue}\n                             setitem(attr, gns[attr])\n                         }\n                     }else{\n                         for(var attr in gns){\n                             current_frame[3][attr] = gns[attr]\n                         }\n                     }\n\n                     // fixme: some extra variables are bleeding into locals...\n                     /*  This also causes issues for unittests */\n                     if(res===undefined) return _b_.None\n                         return res\n             }catch(err){\n                 if(err.$py_error===undefined){throw $B.exception(err)}\n                 throw err\n             }finally{\n\n                 delete __BRYTHON__.modules[globals_id]\n                 delete __BRYTHON__.modules[locals_id]\n                 $B.clear_ns(globals_id)\n                 $B.clear_ns(locals_id)\n\n                 if(!is_exec && leave_frame){\n                     // For eval(), the finally clause with \"leave_frame\" was removed\n                     // so we must execute it here\n                     $B.frames_stack.pop()\n                 }\n             }\n        }\n    }\n})(__BRYTHON__)\n"], "_svg": [".js", "// creation of an HTML element\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar TagSum = $B.TagSum // defined in py_dom.js\n\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +' = _b_[\"' + $b + '\"]')\neval($s.join(';'))\n\nvar $svgNS = \"http://www.w3.org/2000/svg\"\nvar $xlinkNS = \"http://www.w3.org/1999/xlink\"\n\nfunction makeTagDict(tagName){\n    // return the dictionary for the class associated with tagName\n    var dict = $B.make_class(tagName)\n\n    dict.__init__ = function(){\n        var $ns = $B.args('__init__', 1, {self: null}, ['self'],\n            arguments, {}, 'args', 'kw'),\n            self = $ns['self'],\n            args = $ns['args']\n        if(args.length == 1){\n            var first = args[0]\n            if(isinstance(first, [str, int, float])){\n                self.appendChild(document.createTextNode(str.$factory(first)))\n            }else if(first.__class__ === TagSum){\n                for(var i = 0, len = first.children.length; i < len; i++){\n                    self.appendChild(first.children[i].elt)\n                }\n            }else{ // argument is another DOMNode instance\n                try{self.appendChild(first.elt)}\n                catch(err){throw ValueError.$factory('wrong element ' + first)}\n            }\n        }\n\n        // attributes\n        var items = _b_.list.$factory(_b_.dict.items($ns['kw']))\n        for(var i = 0, len = items.length; i < len; i++){\n            // keyword arguments\n            var arg = items[i][0],\n                value = items[i][1]\n            if(arg.toLowerCase().substr(0,2) == \"on\"){\n                // Event binding passed as argument \"onclick\", \"onfocus\"...\n                // Better use method bind of DOMNode objects\n                var js = '$B.DOMNode.bind(self,\"' +\n                    arg.toLowerCase().substr(2)\n                eval(js+'\",function(){'+value+'})')\n            }else if(arg.toLowerCase() == \"style\"){\n                $B.DOMNode.set_style(self,value)\n            }else if(arg.toLowerCase().indexOf(\"href\") !== -1){ // xlink:href\n                self.setAttributeNS( \"http://www.w3.org/1999/xlink\",\n                    \"href\",value)\n            }else{\n                if(value !== false){\n                    // option.selected=false sets it to true :-)\n                    try{\n                        arg = arg.replace('_', '-')\n                        self.setAttributeNS(null, arg, value)\n                    }catch(err){\n                        throw ValueError.$factory(\"can't set attribute \" + arg)\n                    }\n                }\n            }\n        }\n    }\n\n    dict.__mro__ = [$B.DOMNode, $B.builtins.object]\n\n    dict.__new__ = function(cls){\n        var res = $B.DOMNode.$factory(document.createElementNS($svgNS, tagName))\n        res.__class__ = cls\n        return res\n    }\n\n    dict.$factory = function(){\n        var res = $B.DOMNode.$factory(\n            document.createElementNS($svgNS, tagName))\n        res.__class__ = dict\n        // apply __init__\n        dict.__init__(res, ...arguments)\n        return res\n    }\n\n    $B.set_func_names(dict, \"browser.svg\")\n\n    return dict\n}\n\n\n// SVG\nvar $svg_tags = ['a',\n'altGlyph',\n'altGlyphDef',\n'altGlyphItem',\n'animate',\n'animateColor',\n'animateMotion',\n'animateTransform',\n'circle',\n'clipPath',\n'color_profile', // instead of color-profile\n'cursor',\n'defs',\n'desc',\n'ellipse',\n'feBlend',\n'foreignObject', //patch to enable foreign objects\n'g',\n'image',\n'line',\n'linearGradient',\n'marker',\n'mask',\n'path',\n'pattern',\n'polygon',\n'polyline',\n'radialGradient',\n'rect',\n'set',\n'stop',\n'svg',\n'text',\n'tref',\n'tspan',\n'use']\n\n// create classes\nvar obj = new Object()\nvar dicts = {}\nfor(var i = 0, len = $svg_tags.length; i < len; i++){\n    var tag = $svg_tags[i]\n    obj[tag] = makeTagDict(tag)\n}\n\nreturn obj\n})(__BRYTHON__)\n"], "_aio": [".js", "// Replacement for asyncio.\n//\n// CPython asyncio can't be implemented for Brython because it relies on\n// blocking function (eg run(), run_until_complete()), and such functions\n// can't be defined in Javascript. It also manages an event loop, and a\n// browser only has its own built-in event loop.\n//\n// This module exposes functions whose result can be \"await\"-ed inside\n// asynchrounous functions defined by \"async def\".\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar responseType = {\n    \"text\": \"text\",\n    \"binary\": \"arraybuffer\",\n    \"dataURL\": \"arraybuffer\"\n}\n\nfunction handle_kwargs(kw, method){\n    var data,\n        cache = \"no-cache\",\n        format = \"text\",\n        headers = {},\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else{\n                if(params.__class__ !== _b_.dict){\n                    throw _b_.TypeError.$factory(\"wrong type for data, \" +\n                        \"expected dict or str, got \" + $B.class_name(params))\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }\n        }else if(key == \"headers\"){\n            headers = _b_.dict.$to_obj(kw.$string_dict[key][0])\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                ajax.bind(self, event, kw.$string_dict[key][0])\n            }\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }else if(key == \"format\"){\n            format = kw.$string_dict[key][0]\n        }\n    }\n    if(method == \"post\"){\n        // For POST requests, set default header\n        if(! headers.hasOwnProperty(\"Content-type\")){\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        }\n        if(data && !headers.hasOwnProperty(\"Content-Length\")){\n            headers[\"Content-Length\"] = data.length\n        }\n    }\n    return {\n        body: data,\n        cache: cache,\n        format: format,\n        timeout: timeout,\n        headers: headers\n    }\n}\n\nfunction ajax(){\n    var $ = $B.args(\"ajax\", 2, {method: null, url: null},\n            [\"method\", \"url\"], arguments, {},\n            null, \"kw\"),\n        method = $.method.toUpperCase(),\n        url = $.url,\n        kw = $.kw\n    var args = handle_kwargs(kw, \"get\")\n    if(! args.cache){\n        url = \"?ts\" + (new Date()).getTime() + \"=0\"\n    }\n    if(args.body && method == \"GET\"){\n        url = url + (args.cache ? \"?\" : \"&\") + args.body\n    }\n    var func = function(){\n        return new Promise(function(resolve, reject){\n            var xhr = new XMLHttpRequest()\n            xhr.open(method, url, true)\n            for(key in args.headers){\n                xhr.setRequestHeader(key, args.headers[key])\n            }\n            xhr.format = args.format\n            xhr.responseType = responseType[args.format]\n            xhr.onreadystatechange = function(){\n                if(this.readyState == 4){\n                    this.__class__ = HTTPRequest\n                    resolve(this)\n                }\n            }\n            if(method == \"POST\" && args.body){\n                xhr.send(args.body)\n            }else{\n                xhr.send()\n            }\n        })\n    }\n    func.$infos = {\n        __name__: \"ajax_\" + method\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [url, args],\n        $func: func\n    }\n}\n\nfunction event(){\n    // event(element, *names) is a Promise on the events \"names\" happening on\n    // the element. This promise always resolves (never rejects) with the\n    // first triggered DOM event.\n    var $ = $B.args(\"event\", 1, {element: null},\n            [\"element\"], arguments, {}, \"names\", null),\n        element = $.element,\n        names = $.names\n    return new Promise(function(resolve){\n        var callbacks = []\n        names.forEach(function(name){\n            var callback = function(evt){\n                // When one of the handled events is triggered, all bindings\n                // are removed\n                callbacks.forEach(function(items){\n                    $B.DOMNode.unbind(element, items[0], items[1])\n                })\n                resolve($B.$DOMEvent(evt))\n            }\n            callbacks.push([name, callback])\n            $B.DOMNode.bind(element, name, callback)\n        })\n    })\n}\n\nvar HTTPRequest = $B.make_class(\"Request\")\n\nHTTPRequest.data = _b_.property.$factory(function(self){\n    if(self.format == \"binary\"){\n        var view = new Uint8Array(self.response)\n        return _b_.bytes.$factory(Array.from(view))\n    }else if(self.format == \"text\"){\n        return self.responseText\n    }else if(self.format == \"dataURL\"){\n        var base64String = btoa(String.fromCharCode.apply(null,\n            new Uint8Array(self.response)))\n        return \"data:\" + self.getResponseHeader(\"Content-Type\") +\n            \";base64,\" + base64String\n    }\n})\n\nHTTPRequest.response_headers = _b_.property.$factory(function(self){\n    var headers = self.getAllResponseHeaders()\n    if(headers === null){return _b_.None}\n    var res = $B.empty_dict()\n    if(headers.length > 0){\n        // Convert the header string into an array\n        // of individual headers\n        var lines = headers.trim().split(/[\\r\\n]+/)\n        // Create a map of header names to values\n        lines.forEach(function(line){\n          var parts = line.split(': ')\n          var header = parts.shift()\n          var value = parts.join(': ')\n          _b_.dict.$setitem(res, header, value)\n        })\n    }\n    return res\n})\n\nfunction get(){\n    return ajax.bind(null, \"GET\").apply(null, arguments)\n}\n\nfunction iscoroutine(f){\n    return f.__class__ === $B.coroutine\n}\n\nfunction iscoroutinefunction(f){\n    return (f.$infos.__code__.co_flags & 128) != 0\n}\n\nfunction post(){\n    return ajax.bind(null, \"POST\").apply(null, arguments)\n}\n\nfunction run(coro){\n    var handle_success = function(){\n            $B.leave_frame()\n        },\n        handle_error = function(err){\n            // coro.$stack is a snapshot of the frames stack when the async\n            // function was called. Restore it to get the correct call tree\n            console.log(\"Exception in asynchronous function\")\n            err.$stack = coro.$stack.concat([$B.last(err.$stack)])\n            $B.handle_error(err)\n        }\n\n    var $ = $B.args(\"run\", 3, {coro: null, onsuccess: null, onerror: null},\n            [\"coro\", \"onsuccess\", \"onerror\"], arguments,\n            {onsuccess: handle_success, onerror: handle_error},\n            null, null),\n        coro = $.coro,\n        onsuccess = $.onsuccess,\n        onerror = $.onerror\n\n    if(onerror !== handle_error){\n        function error_func(exc){\n            try{\n                onerror(exc)\n            }catch(err){\n                handle_error(err)\n            }\n        }\n    }else{\n        error_func = handle_error\n    }\n    var save_stack = $B.frames_stack.slice()\n    $B.coroutine.send(coro).then(onsuccess).catch(error_func)\n    $B.frames_stack = save_stack\n    return _b_.None\n}\n\nfunction sleep(seconds){\n    var func = function(){\n        return new Promise(resolve => setTimeout(\n            function(){resolve(_b_.None)}, 1000 * seconds))\n    }\n    func.$infos = {\n        __name__: \"sleep\"\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [seconds],\n        $func: func\n    }\n}\n\nreturn {\n    ajax: ajax,\n    event: event,\n    get: get,\n    iscoroutine: iscoroutine,\n    iscoroutinefunction: iscoroutinefunction,\n    post: post,\n    run: run,\n    sleep: sleep\n}\n\n})(__BRYTHON__)\n"], "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(isinstance(val, list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key,str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js,\n        res\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    var abuf = new Uint8Array(xhr.response)\n    res = []\n    for(var i = 0, len = abuf.length; i < len; i++){\n        res.push(abuf[i])\n    }\n    var b = _b_.bytes.$factory(res)\n\n    if(xhr.mode == \"binary\"){\n        return b\n    }else{\n        var encoding = xhr.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        encoding,\n        headers,\n        cache,\n        mode = \"text\",\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(params.__class__ === _b_.dict){\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(params))\n            }\n        }else if(key == \"encoding\"){\n            encoding = kw.$string_dict[key][0]\n            self.js.encoding = encoding\n        }else if(key == \"headers\"){\n            headers = kw.$string_dict[key].$string_dict\n            for(var key in headers){\n                self.js.setRequestHeader(key, headers[key][0])\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                var f = kw.$string_dict[key][0]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = kw.$string_dict[key][0]\n            if(mode == \"json\"){\n                self.js.responseType = \"json\"\n            }else{\n                self.js.responseType = \"arraybuffer\"\n                if(mode != \"text\" && mode != \"binary\"){\n                    throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n                }\n            }\n            self.js.mode = mode\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n    return {\n        cache: cache,\n        data:data,\n        encoding: encoding,\n        mode: mode,\n        timeout: timeout\n    }\n}\n\nvar ajax = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n\n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n\n    $infos: {\n        __module__: \"builtins\",\n        __name__: \"ajax\"\n    },\n\n    __getattribute__: function(self, attr){\n        if(ajax[attr] !== undefined){\n            return function(){\n                return ajax[attr].call(null, self, ...arguments)\n            }\n        }else if(self.js[attr] !== undefined){\n            if(typeof self.js[attr] == \"function\"){\n                return function(){\n                    if(attr == \"setRequestHeader\"){\n                        self.$has_request_header = true\n                    }else if(attr == \"open\"){\n                        self.$method = arguments[0]\n                    }\n                    return self.js[attr](...arguments)\n                }\n            }else{\n                return self.js[attr]\n            }\n        }else if(attr == \"text\"){\n            return self.js.responseText\n        }else if(attr == \"xml\"){\n            return self.js.responseXML\n        }\n    },\n\n\n    bind: function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on' + evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                if(err.__class__ !== undefined){\n                    var msg = _b_.getattr(err, 'info') +\n                        '\\n' + err.__class__.$infos.__name__\n                    if(err.args){msg += ': ' + err.args[0]}\n                    try{getattr($B.stderr, \"write\")(msg)}\n                    catch(err){console.log(msg)}\n                }else{\n                    try{getattr($B.stderr, \"write\")(err)}\n                    catch(err1){console.log(err)}\n                }\n            }\n        }\n        return $N\n    },\n\n    send: function(self, params){\n        // params can be Python dictionary or string\n        var res = ''\n        if(!params){\n            self.js.send()\n            return $N\n        }else if(isinstance(params, str)){\n            res = params\n        }else if(isinstance(params, dict)){\n            if(self.headers['content-type'] == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    add_to_res(res, str.$factory(items[i][0]), items[i][1])\n                }\n            }else{\n                if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                        ! self.$has_request_header){\n                    self.js.setRequestHeader(\"Content-Type\",\n                        \"application/x-www-form-urlencoded\")\n                }\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    var key = encodeURIComponent(str.$factory(items[i][0]));\n                    if(isinstance(items[i][1], list)){\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' +\n                                encodeURIComponent(str.$factory(items[i][1][j])) + '&'\n                        }\n                    }else{\n                        res += key + '=' +\n                            encodeURIComponent(str.$factory(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0, res.length - 1)\n            }\n        }else{\n            throw _b_.TypeError.$factory(\n                \"send() argument must be string or dictionary, not '\" +\n                str.$factory(params.__class__) + \"'\")\n        }\n        self.js.send(res)\n        return $N\n    },\n\n    set_header: function(self,key,value){\n        self.js.setRequestHeader(key,value)\n        self.headers[key.toLowerCase()] = value.toLowerCase()\n    },\n\n    set_timeout: function(self, seconds, func){\n        self.js.$requestTimer = setTimeout(\n            function() {self.js.abort();func()},\n            seconds * 1000)\n    }\n\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){this.onuninitialized(res)}\n        else if(state == 1 && this.onloading){this.onloading(res)}\n        else if(state == 2 && this.onloaded){this.onloaded(res)}\n        else if(state == 3 && this.oninteractive){this.oninteractive(res)}\n        else if(state == 4 && this.oncomplete){\n            if(timer !== null){window.clearTimeout(timer)}\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory(),\n        items = handle_kwargs(self, kw, method),\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.open(method.toUpperCase(), url, async)\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory(),\n        method = 'POST',\n        field_name = 'filetosave'\n\n    if(kw.$string_dict.method !== undefined){\n        method = kw.$string_dict.method[0]\n    }\n\n    if(kw.$string_dict.field_name !== undefined){\n        field_name = kw.$string_dict.field_name[0]\n    }\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    self.js.open(method, url, True)\n    self.js.send(formdata)\n\n    for(key in kw.$string_dict){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$string_dict[key][0])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    delete: _delete,\n    file_upload: file_upload,\n    get: get,\n    head: head,\n    options: options,\n    post: post,\n    put: put\n}\n\n})(__BRYTHON__)\n"], "random": [".js", "// Javascript implementation of the random module\n// Based on Ian Bicking's implementation of the Mersenne twister\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins,\n    i\n\nvar VERSION = 3\n\n// Code copied from https://github.com/ianb/whrandom/blob/master/mersenne.js\n// by Ian Bicking\n\n// this program is a JavaScript version of Mersenne Twister,\n// a straight conversion from the original program, mt19937ar.c,\n// translated by y. okada on july 17, 2006.\n// and modified a little at july 20, 2006, but there are not any substantial differences.\n// modularized by Ian Bicking, March 25, 2013 (found original version at http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVASCRIPT/java-script.html)\n// in this program, procedure descriptions and comments of original source code were not removed.\n// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.\n// lines commented with /* and */ are original comments.\n// lines commented with // are additional comments in this JavaScript version.\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nfunction RandomStream(seed) {\n    /*jshint bitwise:false */\n    /* Period parameters */\n    //c//#define N 624\n    //c//#define M 397\n    //c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n    //c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n    //c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n    var N = 624\n    var M = 397\n    var MATRIX_A = 0x9908b0df   /* constant vector a */\n    var UPPER_MASK = 0x80000000 /* most significant w-r bits */\n    var LOWER_MASK = 0x7fffffff /* least significant r bits */\n    //c//static unsigned long mt[N]; /* the array for the state vector  */\n    //c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\n    var mt = new Array(N)   /* the array for the state vector  */\n    var mti = N + 1           /* mti==N+1 means mt[N] is not initialized */\n\n    function unsigned32(n1){\n        // returns a 32-bits unsiged integer from an operand to which applied a\n        // bit operator.\n        return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1\n    }\n\n    function subtraction32(n1, n2){\n    // emulates lowerflow of a c 32-bits unsiged integer variable, instead of\n    // the operator -. these both arguments must be non-negative integers\n    // expressible using unsigned 32 bits.\n        return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) :\n          n1 - n2\n    }\n\n    function addition32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of\n        // the operator +. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        return unsigned32((n1 + n2) & 0xffffffff)\n    }\n\n    function multiplication32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of the\n        // operator *. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        var sum = 0\n        for (var i = 0; i < 32; ++i){\n            if((n1 >>> i) & 0x1){\n                sum = addition32(sum, unsigned32(n2 << i))\n            }\n        }\n        return sum\n    }\n\n    /* initializes mt[N] with a seed */\n    //c//void init_genrand(unsigned long s)\n    function init_genrand(s) {\n        //c//mt[0]= s & 0xffffffff;\n        mt[0] = unsigned32(s & 0xffffffff)\n        for(mti = 1; mti < N; mti++){\n            mt[mti] =\n                //c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);\n                addition32(multiplication32(1812433253,\n                    unsigned32(mt[mti - 1] ^ (mt[mti - 1] >>> 30))), mti)\n            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n            /* In the previous versions, MSBs of the seed affect   */\n            /* only MSBs of the array mt[].                        */\n            /* 2002/01/09 modified by Makoto Matsumoto             */\n            //c//mt[mti] &= 0xffffffff;\n            mt[mti] = unsigned32(mt[mti] & 0xffffffff);\n            /* for >32 bit machines */\n        }\n    }\n\n    /* initialize by an array with array-length */\n    /* init_key is the array for initializing keys */\n    /* key_length is its length */\n    /* slight change for C++, 2004/2/26 */\n    //c//void init_by_array(unsigned long init_key[], int key_length)\n    function init_by_array(init_key, key_length) {\n        //c//int i, j, k;\n        var i, j, k\n        init_genrand(19650218)\n        i = 1\n        j = 0\n        k = (N > key_length ? N : key_length)\n        for(; k; k--){\n          //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))\n          //c// + init_key[j] + j; /* non linear */\n          mt[i] = addition32(\n              addition32(unsigned32(mt[i] ^\n                  multiplication32(unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                  1664525)),\n              init_key[j]), j)\n          mt[i] =\n              //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n              unsigned32(mt[i] & 0xffffffff)\n          i++\n          j++\n          if(i >= N){mt[0] = mt[N - 1]; i = 1}\n          if(j >= key_length){j = 0}\n        }\n        for(k = N - 1; k; k--){\n            //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))\n            //c//- i; /* non linear */\n            mt[i] = subtraction32(\n                unsigned32(\n                    (mt[i]) ^\n                        multiplication32(\n                            unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                    1566083941)),\n                i\n            )\n            //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n            mt[i] = unsigned32(mt[i] & 0xffffffff)\n            i++\n            if(i >= N){mt[0] = mt[N - 1]; i = 1}\n        }\n        mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n    }\n\n    /* generates a random number on [0,0xffffffff]-interval */\n    //c//unsigned long genrand_int32(void)\n    function genrand_int32() {\n        //c//unsigned long y;\n        //c//static unsigned long mag01[2]={0x0UL, MATRIX_A};\n        var y;\n        var mag01 = [0x0, MATRIX_A];\n        /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n        if(mti >= N){ /* generate N words at one time */\n            //c//int kk;\n            var kk\n\n            if(mti == N + 1){   /* if init_genrand() has not been called, */\n              init_genrand(Date.now()) /* a default initial seed is used */\n            }\n\n            for(kk = 0; kk < N - M; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + M] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            for(;kk < N - 1; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + (M - N)] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            //c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n            //c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n            y = unsigned32((mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK))\n            mt[N - 1] = unsigned32(mt[M - 1] ^ (y >>> 1) ^ mag01[y & 0x1])\n            mti = 0\n        }\n\n        y = mt[mti++]\n\n        /* Tempering */\n        //c//y ^= (y >> 11);\n        //c//y ^= (y << 7) & 0x9d2c5680;\n        //c//y ^= (y << 15) & 0xefc60000;\n        //c//y ^= (y >> 18);\n        y = unsigned32(y ^ (y >>> 11))\n        y = unsigned32(y ^ ((y << 7) & 0x9d2c5680))\n        y = unsigned32(y ^ ((y << 15) & 0xefc60000))\n        y = unsigned32(y ^ (y >>> 18))\n\n        return y\n    }\n\n    /* generates a random number on [0,0x7fffffff]-interval */\n    //c//long genrand_int31(void)\n    function genrand_int31(){\n        //c//return (genrand_int32()>>1);\n        return (genrand_int32()>>>1)\n    }\n\n    /* generates a random number on [0,1]-real-interval */\n    //c//double genrand_real1(void)\n    function genrand_real1(){\n        return genrand_int32()*(1.0/4294967295.0)\n        /* divided by 2^32-1 */\n    }\n\n    /* generates a random number on [0,1)-real-interval */\n    //c//double genrand_real2(void)\n    function genrand_real2(){\n        return genrand_int32() * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on (0,1)-real-interval */\n    //c//double genrand_real3(void)\n    function genrand_real3() {\n        return ((genrand_int32()) + 0.5) * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on [0,1) with 53-bit resolution*/\n    //c//double genrand_res53(void)\n    function genrand_res53() {\n        //c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;\n        var a = genrand_int32() >>> 5,\n            b = genrand_int32() >>> 6\n        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0)\n    }\n    /* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n    var random = genrand_res53\n\n    random.seed = function(seed){\n        if(seed === undefined){seed = Date.now()}\n        if(typeof seed != \"number\"){seed = parseInt(seed, 10)}\n        if((seed !== 0 && ! seed) || isNaN(seed)){\n            throw _b_.ValueError.$factory(\"Bad seed: \" + _b_.str.$factory(seed))\n        }\n        init_genrand(seed)\n    }\n\n    random.seed(seed)\n\n    random.int31 = genrand_int31\n    random.real1 = genrand_real1\n    random.real2 = genrand_real2\n    random.real3 = genrand_real3\n    random.res53 = genrand_res53\n\n    // Added for compatibility with Python\n    random.getstate = function(){return [VERSION, mt, mti]}\n\n    random.setstate = function(state){\n        mt = state[1]\n        mti = state[2]\n    }\n\n    return random\n\n}\n\n// magic constants\n\nvar NV_MAGICCONST = 4 * Math.exp(-0.5)/Math.sqrt(2),\n    gauss_next = null,\n    NV_MAGICCONST = 1.71552776992141,\n    TWOPI = 6.28318530718,\n    LOG4 = 1.38629436111989,\n    SG_MAGICCONST = 2.50407739677627,\n    VERSION = VERSION\n\nvar Random = $B.make_class(\"Random\",\n    function(){\n        return {\n            __class__: Random,\n            _random: RandomStream(Date.now())\n        }\n    }\n)\n\nRandom._randbelow = function(self, x){\n    return Math.floor(x * self._random())\n}\n\nRandom._urandom = function(self, n){\n    /*\n    urandom(n) -> str\n    Return n random bytes suitable for cryptographic use.\n    */\n\n    var randbytes = []\n    for(i = 0; i < n; i++){randbytes.push(parseInt(self._random() * 256))}\n    return _b_.bytes.$factory(randbytes)\n}\n\nRandom.betavariate = function(){\n    /* Beta distribution.\n\n    Conditions on the parameters are alpha > 0 and beta > 0.\n    Returned values range between 0 and 1.\n\n\n    # This version due to Janne Sinkkonen, and matches all the std\n    # texts (e.g., Knuth Vol 2 Ed 3 pg 134 \"the beta distribution\").\n    */\n\n    var $ = $B.args('betavariate', 3, {self: null, alpha:null, beta:null},\n            ['self', 'alpha', 'beta'], arguments, {}, null, null),\n        self = $.self,\n        alpha = $.alpha,\n        beta = $.beta\n\n    var y = Random.gammavariate(self, alpha, 1)\n    if(y == 0){return _b_.float.$factory(0)}\n    else{return y / (y + Random.gammavariate(self, beta, 1))}\n}\n\nRandom.choice = function(){\n    var $ = $B.args(\"choice\", 2,\n        {self: null, seq:null},[\"self\", \"seq\"],arguments, {}, null, null),\n        self = $.self,\n        seq = $.seq\n    var len, rank\n    if(Array.isArray(seq)){len = seq.length}\n    else{len = _b_.getattr(seq,\"__len__\")()}\n    if(len == 0){\n        throw _b_.IndexError.$factory(\"Cannot choose from an empty sequence\")\n    }\n    rank = parseInt(self._random() * len)\n    if(Array.isArray(seq)){return seq[rank]}\n    else{return _b_.getattr(seq, \"__getitem__\")(rank)}\n}\n\nRandom.choices = function(){\n    var $ = $B.args(\"choices\", 3,\n            {self: null,population:null, weights:null, cum_weights:null, k:null},\n            [\"self\", \"population\", \"weights\", \"cum_weights\", \"k\"], arguments,\n            {weights: _b_.None, cum_weights: _b_.None, k: 1}, \"*\", null),\n            self = $.self,\n            population = $.population,\n            weights = $.weights,\n            cum_weights = $.cum_weights,\n            k = $.k\n\n    if(population.length == 0){\n        throw _b_.ValueError.$factory(\"population is empty\")\n    }\n    population = _b_.list.$factory(population) // issue #1268\n    if(weights === _b_.None){\n        weights = []\n        population.forEach(function(){\n            weights.push(1)\n        })\n    }else if(cum_weights !== _b_.None){\n        throw _b_.TypeError.$factory(\"Cannot specify both weights and \" +\n            \"cumulative weights\")\n    }else{\n        if(weights.length != population.length){\n            throw _b_.ValueError.$factory('The number of weights does not ' +\n                'match the population')\n        }\n    }\n    if(cum_weights === _b_.None){\n        var cum_weights = [weights[0]]\n        weights.forEach(function(weight, rank){\n            if(rank > 0){\n                cum_weights.push(cum_weights[rank - 1] + weight)\n            }\n        })\n    }else if(cum_weights.length != population.length){\n        throw _b_.ValueError.$factory('The number of weights does not ' +\n            'match the population')\n    }\n\n    var result = []\n    for(var i = 0; i < k; i++){\n        var rand = self._random() * cum_weights[cum_weights.length - 1]\n        for(var rank = 0, len = population.length; rank < len; rank++){\n            if(cum_weights[rank] > rand){\n                result.push(population[rank])\n                break\n            }\n        }\n    }\n    return result\n}\n\nRandom.expovariate = function(self, lambd){\n    /*\n    Exponential distribution.\n\n    lambd is 1.0 divided by the desired mean.  It should be\n    nonzero.  (The parameter would be called \"lambda\", but that is\n    a reserved word in Python.)  Returned values range from 0 to\n    positive infinity if lambd is positive, and from negative\n    infinity to 0 if lambd is negative.\n\n    */\n    // lambd: rate lambd = 1/mean\n    // ('lambda' is a Python reserved word)\n\n    // we use 1-random() instead of random() to preclude the\n    // possibility of taking the log of zero.\n    return -Math.log(1.0 - self._random()) / lambd\n}\n\nRandom.gammavariate = function(self, alpha, beta){\n    /* Gamma distribution.  Not the gamma function!\n\n    Conditions on the parameters are alpha > 0 and beta > 0.\n\n    The probability distribution function is:\n\n                x ** (alpha - 1) * math.exp(-x / beta)\n      pdf(x) =  --------------------------------------\n                  math.gamma(alpha) * beta ** alpha\n\n    */\n\n    // alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2\n\n    // Warning: a few older sources define the gamma distribution in terms\n    // of alpha > -1.0\n\n    var $ = $B.args('gammavariate', 3,\n            {self: null, alpha:null, beta:null},\n            ['self', 'alpha', 'beta'],\n            arguments, {}, null, null),\n        self = $.self,\n        alpha = $.alpha,\n        beta = $.beta,\n        LOG4 = Math.log(4),\n        SG_MAGICCONST = 1.0 + Math.log(4.5)\n\n    if(alpha <= 0.0 || beta <= 0.0){\n        throw _b_.ValueError.$factory('gammavariate: alpha and beta must be > 0.0')\n    }\n\n    if(alpha > 1.0){\n\n        // Uses R.C.H. Cheng, \"The generation of Gamma\n        // variables with non-integral shape parameters\",\n        // Applied Statistics, (1977), 26, No. 1, p71-74\n\n        var ainv = Math.sqrt(2.0 * alpha - 1.0),\n            bbb = alpha - LOG4,\n            ccc = alpha + ainv\n\n        while(true){\n            var u1 = self._random()\n            if(!((1e-7 < u1) && (u1 < .9999999))){\n                continue\n            }\n            var u2 = 1.0 - self._random(),\n                v = Math.log(u1 / (1.0 - u1)) / ainv,\n                x = alpha * Math.exp(v),\n                z = u1 * u1 * u2,\n                r = bbb + ccc * v - x\n            if((r + SG_MAGICCONST - 4.5 * z >= 0.0) || r >= Math.log(z)){\n                return x * beta\n            }\n        }\n    }else if(alpha == 1.0){\n        // expovariate(1)\n        var u = self._random()\n        while(u <= 1e-7){u = self._random()}\n        return -Math.log(u) * beta\n    }else{\n        // alpha is between 0 and 1 (exclusive)\n\n        // Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle\n\n        while(true){\n            var u = self._random(),\n                b = (Math.E + alpha)/Math.E,\n                p = b*u,\n                x\n            if(p <= 1.0){x = Math.pow(p, (1.0/alpha))}\n            else{x = -Math.log((b-p)/alpha)}\n            var u1 = self._random()\n            if(p > 1.0){\n                if(u1 <= Math.pow(x, alpha - 1.0)){\n                    break\n                }\n            }else if(u1 <= Math.exp(-x)){\n                break\n            }\n        }\n        return x * beta\n    }\n}\n\nRandom.gauss = function(){\n\n    /* Gaussian distribution.\n\n    mu is the mean, and sigma is the standard deviation.  This is\n    slightly faster than the normalvariate() function.\n\n    Not thread-safe without a lock around calls.\n\n    # When x and y are two variables from [0, 1), uniformly\n    # distributed, then\n    #\n    #    cos(2*pi*x)*sqrt(-2*log(1-y))\n    #    sin(2*pi*x)*sqrt(-2*log(1-y))\n    #\n    # are two *independent* variables with normal distribution\n    # (mu = 0, sigma = 1).\n    # (Lambert Meertens)\n    # (corrected version; bug discovered by Mike Miller, fixed by LM)\n\n    # Multithreading note: When two threads call this function\n    # simultaneously, it is possible that they will receive the\n    # same return value.  The window is very small though.  To\n    # avoid this, you have to use a lock around all calls.  (I\n    # didn't want to slow this down in the serial case by using a\n    # lock here.)\n    */\n\n    var $ = $B.args('gauss', 3, {self: null, mu:null, sigma:null},\n            ['self', 'mu', 'sigma'], arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        sigma = $.sigma\n\n    var z = gauss_next\n    gauss_next = null\n    if(z === null){\n        var x2pi = self._random() * Math.PI * 2,\n            g2rad = Math.sqrt(-2.0 * Math.log(1.0 - self._random())),\n            z = Math.cos(x2pi) * g2rad\n        gauss_next = Math.sin(x2pi) * g2rad\n    }\n    return mu + z*sigma\n}\n\nRandom.getrandbits = function(){\n    var $ = $B.args(\"getrandbits\", 2,\n        {self: null, k:null},[\"self\", \"k\"],arguments, {}, null, null),\n        self = $.self,\n        k = $B.$GetInt($.k)\n    // getrandbits(k) -> x.  Generates a long int with k random bits.\n    if(k <= 0){\n        throw _b_.ValueError.$factory('number of bits must be greater than zero')\n    }\n    if(k != _b_.int.$factory(k)){\n        throw _b_.TypeError.$factory('number of bits should be an integer')\n    }\n    var numbytes = (k + 7), // bits / 8 and rounded up\n        x = _b_.int.from_bytes(Random._urandom(self, numbytes), 'big')\n    return _b_.getattr(x, '__rshift__')(\n        _b_.getattr(numbytes*8,'__sub__')(k))\n}\n\nRandom.getstate = function(){\n    // Return internal state; can be passed to setstate() later.\n    var $ = $B.args('getstate', 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    return $.self._random.getstate()\n}\n\nRandom.lognormvariate = function(){\n    /*\n    Log normal distribution.\n\n    If you take the natural logarithm of this distribution, you'll get a\n    normal distribution with mean mu and standard deviation sigma.\n    mu can have any value, and sigma must be greater than zero.\n\n    */\n    return Math.exp(Random.normalvariate.apply(null, arguments))\n}\n\nRandom.normalvariate = function(){\n    /*\n    Normal distribution.\n\n    mu is the mean, and sigma is the standard deviation.\n\n    */\n\n    // mu = mean, sigma = standard deviation\n\n    // Uses Kinderman and Monahan method. Reference: Kinderman,\n    // A.J. and Monahan, J.F., \"Computer generation of random\n    // variables using the ratio of uniform deviates\", ACM Trans\n    // Math Software, 3, (1977), pp257-260.\n\n    var $ = $B.args(\"normalvariate\", 3,\n        {self: null, mu:null, sigma:null}, [\"self\", \"mu\", \"sigma\"],\n        arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        sigma = $.sigma\n\n    while(true){\n        var u1 = self._random(),\n            u2 = 1.0 - self._random(),\n            z = NV_MAGICCONST * (u1 - 0.5) / u2,\n            zz = z * z / 4.0\n        if(zz <= -Math.log(u2)){break}\n    }\n    return mu + z * sigma\n}\n\nRandom.paretovariate = function(){\n    /* Pareto distribution.  alpha is the shape parameter.*/\n    // Jain, pg. 495\n\n    var $ = $B.args(\"paretovariate\", 2, {self: null, alpha:null},\n        [\"self\", \"alpha\"], arguments, {}, null, null)\n\n    var u = 1 - $.self._random()\n    return 1 / Math.pow(u, 1 / $.alpha)\n}\n\nfunction is_integer(x){\n    return _b_.isinstance(x, _b_.int) || (\n        _b_.isinstance(x, _b_.float) &&\n            x.valueOf() == Math.floor(x.valueOf()))\n}\n\nRandom.randint = function(self, a, b){\n    var $ = $B.args('randint', 3,\n        {self: null, a:null, b:null},\n        ['self', 'a', 'b'],\n        arguments, {}, null, null)\n    if(! is_integer($.a)){\n        throw _b_.ValueError.$factory(\"non-integer value for start\")\n    }\n    if(! is_integer($.b)){\n        throw _b_.ValueError.$factory(\"non-integer value for stop\")\n    }\n    return Random.randrange($.self, $.a, $B.add($.b, 1))\n}\n\nRandom.random = function(self){\n    var res = self._random()\n    if(! Number.isInteger(res)){return new Number(res)}\n    return res\n}\n\nRandom.randrange = function(){\n    var $ = $B.args('randrange', 4,\n        {self: null, x:null, stop:null, step:null},\n        ['self', 'x', 'stop', 'step'],\n        arguments, {stop:null, step:null}, null, null),\n        self = $.self,\n        _random = self._random\n\n    if(! is_integer($.x)){\n        throw _b_.ValueError.$factory(\"non-integer arg 1 for randrange()\")\n    }\n    if($.stop !== null && ! is_integer($.stop)){\n        throw _b_.ValueError.$factory(\"non-integer arg 2 for randrange()\")\n    }\n    if($.step !== null && ! is_integer($.step)){\n        throw _b_.ValueError.$factory(\"non-integer arg 3 for randrange()\")\n    }\n\n    if($.stop === null){\n        var start = 0, stop = $.x.valueOf(), step = 1\n    }else{\n        var start = $.x.valueOf(), stop = $.stop.valueOf(),\n            step = $.step === null ? 1 : $.step.valueOf()\n        if(step == 0){throw _b_.ValueError.$factory('step cannot be 0')}\n    }\n\n    if((step > 0 && start >= stop) || (step < 0 && start <= stop)){\n        throw _b_.ValueError.$factory(\"empty range for randrange() (\" +\n            start + \", \" + stop + \", \" + step + \")\")\n    }\n    if(typeof start == 'number' && typeof stop == 'number' &&\n            typeof step == 'number'){\n        return start + step * Math.floor(_random() *\n            Math.ceil((stop - start) / step))\n    }else{\n        var d = _b_.getattr(stop, '__sub__')(start)\n        d = _b_.getattr(d, '__floordiv__')(step)\n        // Force d to be a LongInt\n        d = $B.long_int.$factory(d)\n        // d is a long integer with n digits ; to choose a random number\n        // between 0 and d the most simple is to take a random digit\n        // at each position, except the first one\n        var s = d.value,\n            _len = s.length,\n            res = Math.floor(_random() * (parseInt(s.charAt(0)) +\n                (_len == 1 ? 0 : 1))) + ''\n        var same_start = res.charAt(0) == s.charAt(0)\n        for(var i = 1; i < _len; i++){\n            if(same_start){\n                // If it's the last digit, don't allow stop as valid\n                if(i == _len - 1){\n                    res += Math.floor(_random() * parseInt(s.charAt(i))) + ''\n                }else{\n                    res += Math.floor(_random() *\n                        (parseInt(s.charAt(i)) + 1)) + ''\n                    same_start = res.charAt(i) == s.charAt(i)\n                }\n            }else{\n                res += Math.floor(_random() * 10) + ''\n            }\n        }\n        var offset = {__class__: $B.long_int, value: res,\n            pos: true}\n        d = _b_.getattr(step, '__mul__')(offset)\n        d = _b_.getattr(start, '__add__')(d)\n        return _b_.int.$factory(d)\n    }\n}\n\nRandom.sample = function(){\n    /*\n    Chooses k unique random elements from a population sequence or set.\n\n    Returns a new list containing elements from the population while\n    leaving the original population unchanged.  The resulting list is\n    in selection order so that all sub-slices will also be valid random\n    samples.  This allows raffle winners (the sample) to be partitioned\n    into grand prize and second place winners (the subslices).\n\n    Members of the population need not be hashable or unique.  If the\n    population contains repeats, then each occurrence is a possible\n    selection in the sample.\n\n    To choose a sample in a range of integers, use range as an argument.\n    This is especially fast and space efficient for sampling from a\n    large population:   sample(range(10000000), 60)\n\n    # Sampling without replacement entails tracking either potential\n    # selections (the pool) in a list or previous selections in a set.\n\n    # When the number of selections is small compared to the\n    # population, then tracking selections is efficient, requiring\n    # only a small set and an occasional reselection.  For\n    # a larger number of selections, the pool tracking method is\n    # preferred since the list takes less space than the\n    # set and it doesn't suffer from frequent reselections.'\n\n    */\n    var $ = $B.args('sample', 3, {self: null, population: null,k: null},\n        ['self', 'population','k'], arguments, {}, null, null),\n        self = $.self,\n        population = $.population,\n        k = $.k\n\n    if(!_b_.hasattr(population, '__len__')){\n        throw _b_.TypeError.$factory(\"Population must be a sequence or set. \" +\n            \"For dicts, use list(d).\")\n    }\n    var n = _b_.getattr(population, '__len__')()\n\n    if(k < 0 || k > n){\n        throw _b_.ValueError.$factory(\"Sample larger than population\")\n    }\n    var result = [],\n        setsize = 21        // size of a small set minus size of an empty list\n    if(k > 5){\n        setsize += Math.pow(4, Math.ceil(Math.log(k * 3, 4))) // table size for big sets\n    }\n    if(n <= setsize){\n        // An n-length list is smaller than a k-length set\n        if(Array.isArray(population)){\n            var pool = population.slice()\n        }else{var pool = _b_.list.$factory(population)}\n        for(var i = 0; i < k; i++){ //invariant:  non-selected at [0,n-i)\n            var j = Random._randbelow(self, n - i)\n            result[i] = pool[j]\n            pool[j] = pool[n - i - 1]   // move non-selected item into vacancy\n        }\n    }else{\n        selected = {}\n        for(var i = 0; i < k; i++){\n            var j = Random._randbelow(self, n)\n            while(selected[j] !== undefined){\n                j = Random._randbelow(self, n)\n            }\n            selected[j] = true\n            result[i] = Array.isArray(population) ? population[j] :\n                            _b_.getattr(population, '__getitem__')(j)\n        }\n    }\n    return result\n}\n\nRandom.seed = function(){\n    /*\n    Initialize internal state from hashable object.\n\n    None or no argument seeds from current time or from an operating\n    system specific randomness source if available.\n\n    If *a* is an int, all bits are used.\n    */\n    var $ = $B.args('seed', 3, {self: null, a: null, version: null},\n        ['self', 'a', 'version'],\n        arguments, {a: new Date(), version: 2}, null, null),\n        self = $.self,\n        a = $.a,\n        version = $.version\n\n    if(version == 1){a = _b_.hash(a)}\n    else if(version == 2){\n        if(_b_.isinstance(a, _b_.str)){\n            a = _b_.int.from_bytes(_b_.bytes.$factory(a, 'utf-8'), 'big')\n        }else if(_b_.isinstance(a, [_b_.bytes, _b_.bytearray])){\n            a = _b_.int.from_bytes(a, 'big')\n        }else if(!_b_.isinstance(a, _b_.int)){\n            throw _b_.TypeError.$factory('wrong argument')\n        }\n        if(a.__class__ === $B.long_int){\n            // In this implementation, seed() only accepts safe integers\n            // Generate a random one from the underlying string value,\n            // using an arbitrary seed (99) to always return the same\n            // integer\n            var numbers = a.value,\n                res = '',\n                pos\n            self._random.seed(99)\n            for(var i = 0; i < 17; i++){\n                pos = parseInt(self._random() * numbers.length)\n                res += numbers.charAt(pos)\n            }\n            a = parseInt(res)\n        }\n    }else{\n        throw _b_.ValueError.$factory('version can only be 1 or 2')\n    }\n\n    self._random.seed(a)\n    gauss_next = null\n}\n\nRandom.setstate = function(state){\n    // Restore internal state from object returned by getstate().\n    var $ = $B.args('setstate', 2, {self: null, state:null}, ['self', 'state'],\n        arguments, {}, null, null),\n        self = $.self\n    var state = self._random.getstate()\n    if(! Array.isArray($.state)){\n        throw _b_.TypeError.$factory('state must be a list, not ' +\n            $B.class_name($.state))\n    }\n    if($.state.length < state.length){\n        throw _b_.ValueError.$factory(\"need more than \" + $.state.length +\n            \" values to unpack\")\n    }else if($.state.length > state.length){\n        throw _b_.ValueError.$factory(\"too many values to unpack (expected \" +\n            state.length + \")\")\n    }\n    if($.state[0] != 3){\n        throw _b_.ValueError.$factory(\"ValueError: state with version \" +\n            $.state[0] + \" passed to Random.setstate() of version 3\")\n    }\n    var second = _b_.list.$factory($.state[1])\n    if(second.length !== state[1].length){\n        throw _b_.ValueError.$factory('state vector is the wrong size')\n    }\n    for(var i = 0; i < second.length; i++){\n        if(typeof second[i] != 'number'){\n            throw _b_.ValueError.$factory('state vector items must be integers')\n        }\n    }\n    self._random.setstate($.state)\n}\n\nRandom.shuffle = function(x, random){\n    /*\n    x, random = random.random -> shuffle list x in place; return None.\n\n    Optional arg random is a 0-argument function returning a random\n    float in [0.0, 1.0); by default, the standard random.random.\n    */\n\n    var $ = $B.args('shuffle', 3, {self: null, x: null, random: null},\n        ['self', 'x','random'],\n        arguments, {random: null}, null, null),\n        self = $.self,\n        x = $.x,\n        random = $.random\n\n    if(random === null){random = self._random}\n\n    if(Array.isArray(x)){\n        for(var i = x.length - 1; i >= 0;i--){\n            var j = Math.floor(random() * (i + 1)),\n                temp = x[j]\n            x[j] = x[i]\n            x[i] = temp\n        }\n    }else{\n        var len = _b_.getattr(x, '__len__')(), temp,\n            x_get = _b_.getattr(x, '__getitem__'),\n            x_set = _b_.getattr(x, '__setitem__')\n\n        for(i = len - 1; i >= 0; i--){\n            var j = Math.floor(random() * (i + 1)),\n                temp = x_get(j)\n            x_set(j, x_get(i))\n            x_set(i, temp)\n        }\n    }\n    return _b_.None\n}\n\nRandom.triangular = function(){\n    /*\n    Triangular distribution.\n\n    Continuous distribution bounded by given lower and upper limits,\n    and having a given mode value in-between.\n\n    http://en.wikipedia.org/wiki/Triangular_distribution\n    */\n    var $ = $B.args('triangular', 4,\n        {self: null, low: null, high: null, mode: null},\n        ['self', 'low', 'high', 'mode'],\n        arguments, {low: 0, high: 1, mode: null}, null, null),\n        low = $.low,\n        high = $.high,\n        mode = $.mode\n\n    var u = $.self._random(),\n        c = mode === null ? 0.5 : (mode - low) / (high - low)\n    if(u > c){\n        u = 1 - u\n        c = 1 - c\n        var temp = low\n        low = high\n        high = temp\n    }\n    return low + (high - low) * Math.pow(u * c, 0.5)\n}\n\nRandom.uniform = function(){\n    var $ = $B.args('uniform', 3, {self: null, a: null, b: null},\n        ['self', 'a', 'b'], arguments, {}, null, null),\n        a = $B.$GetInt($.a),\n        b = $B.$GetInt($.b)\n\n    return a + (b - a) * $.self._random()\n}\n\nRandom.vonmisesvariate = function(){\n    /* Circular data distribution.\n\n    mu is the mean angle, expressed in radians between 0 and 2*pi, and\n    kappa is the concentration parameter, which must be greater than or\n    equal to zero.  If kappa is equal to zero, this distribution reduces\n    to a uniform random angle over the range 0 to 2*pi.\n\n    */\n    // mu:    mean angle (in radians between 0 and 2*pi)\n    // kappa: concentration parameter kappa (>= 0)\n    // if kappa = 0 generate uniform random angle\n\n    // Based upon an algorithm published in: Fisher, N.I.,\n    // \"Statistical Analysis of Circular Data\", Cambridge\n    // University Press, 1993.\n\n    // Thanks to Magnus Kessler for a correction to the\n    // implementation of step 4.\n\n    var $ = $B.args('vonmisesvariate', 3,\n            {self: null, mu: null, kappa:null}, ['self', 'mu', 'kappa'],\n            arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        kappa = $.kappa,\n        TWOPI = 2*Math.PI\n\n    if(kappa <= 1e-6){return TWOPI * self._random()}\n\n    var s = 0.5 / kappa,\n        r = s + Math.sqrt(1.0 + s * s)\n\n    while(true){\n        var u1 = self._random(),\n            z = Math.cos(Math.PI * u1),\n            d = z / (r + z),\n            u2 = self._random()\n        if((u2 < 1.0 - d * d) ||\n            (u2 <= (1.0 - d) * Math.exp(d))){\n                break\n        }\n    }\n    var q = 1.0 / r,\n        f = (q + z) / (1.0 + q * z),\n        u3 = self._random()\n    if(u3 > 0.5){var theta = (mu + Math.acos(f)) % TWOPI}\n    else{var theta = (mu - Math.acos(f)) % TWOPI}\n    return theta\n}\n\nRandom.weibullvariate = function(){\n    /*Weibull distribution.\n\n    alpha is the scale parameter and beta is the shape parameter.\n\n    */\n    // Jain, pg. 499; bug fix courtesy Bill Arms\n    var $ = $B.args(\"weibullvariate\", 3,\n        {self: null, alpha: null, beta: null},\n        [\"self\", \"alpha\", \"beta\"], arguments, {}, null, null)\n\n    var u = 1 - $.self._random()\n    return $.alpha * Math.pow(-Math.log(u), 1 / $.beta)\n}\n\n$B.set_func_names(Random, \"random\")\n\nvar $module = Random.$factory()\nfor(var attr in Random){\n    $module[attr] = (function(x){\n        return function(){return Random[x]($module, ...arguments)}\n    })(attr)\n    $module[attr].$infos = Random[attr].$infos\n}\n\n$module.Random = Random\n\nvar SystemRandom = $B.make_class(\"SystemRandom\",\n    function(){\n        return {__class__: SystemRandom}\n    }\n)\nSystemRandom.__getattribute__ = function(){\n    throw $B.builtins.NotImplementedError.$factory()\n}\n\n$module.SystemRandom = SystemRandom\n\nreturn $module\n\n})(__BRYTHON__)\n\n"], "_jsre": [".js", "var $module = (function($B){\n\n    var _b_ = $B.builtins\n    var $s = []\n    for(var $b in _b_) $s.push('var ' + $b +'=_b_[\"' + $b + '\"]')\n    eval($s.join(';'))\n\n    var MatchObject = $B.make_class(\"Match\",\n        function(jsmatch, string, pattern){\n            return {\n                __class__: MatchObject,\n                jsmatch: jsmatch,\n                string: string\n            }\n        }\n    )\n    MatchObject.item = function(self, rank){\n        return self.jsmatch[rank]\n    }\n    MatchObject.group = function(self){\n        var res = []\n        for(var i = 0, _len_i = arguments.length; i < _len_i; i++){\n            if(self.jsmatch[arguments[i]] === undefined){res.push(None)}\n            else{res.push(self.jsmatch[arguments[i]])}\n        }\n        if(arguments.length == 1){return res[0]}\n        return tuple.$factory(res)\n    }\n    MatchObject.groups = function(self, _default){\n        if(_default===undefined){_default=None}\n        var res = []\n        for(var i = 1, _len_i = self.length; i < _len_i; i++){\n            if(self.jsmatch[i] === undefined){res.push(_default)}\n            else{res.push(self.jsmatch[i])}\n        }\n        return tuple.$factory(res)\n    }\n    MatchObject.start = function(self){\n        return self.index\n    }\n    MatchObject.end = function(self){\n        return self.length - self.index\n    }\n\n    $B.set_func_names(MatchObject, '_jsre')\n\n    var obj = {__class__: $module,\n        __str__: function(){return \"<module 're'>\"}\n    }\n    obj.A = obj.ASCII = 256\n    obj.I = obj.IGNORECASE = 2 // 'i'\n    obj.L = obj.LOCALE = 4\n    obj.M = obj.MULTILINE = 8 // 'm'\n    obj.S = obj.DOTALL = 16\n    obj.U = obj.UNICODE = 32\n    obj.X = obj.VERBOSE = 64\n    obj._is_valid = function(pattern) {\n        if ($B.$options.re == 'pyre'){return false}  //force use of python's re module\n        if ($B.$options.re == 'jsre'){return true}   //force use of brythons re module\n        // FIXME: Improve\n\n        if(! isinstance(pattern, str)){\n           // this is probably a SRE_PATTERN, so return false, and let\n           // python's re module handle this.\n           return false\n        }\n        var is_valid = false\n        try{\n            new RegExp(pattern)\n            is_valid = true\n        }\n        catch(e){}\n        if(! is_valid){return false}  //if js won't parse the pattern return false\n\n        // using reference http://www.regular-expressions.info/\n        // to compare python re and javascript regex libraries\n\n        // look for things javascript does not support\n        // check for name capturing group\n        var mylist = ['?P=', '?P<', '(?#', '(?<=', '(?<!', '(?(']\n        for(var i = 0, _len_i = mylist.length; i < _len_i; i++) {\n           if (pattern.indexOf(mylist[i]) > -1) return false\n        }\n\n        var re_list=['\\{,\\d+\\}']\n        for(var i=0, _len_i = re_list.length; i < _len_i; i++) {\n           var _re = new RegExp(re_list[i])\n           if (_re.test(pattern)){return false}\n        }\n\n        // it looks like the pattern has passed all our tests so lets assume\n        // javascript can handle this pattern.\n        return true\n    }\n    var $SRE_PatternDict = {\n        __class__:_b_.type,\n        $infos:{\n            __name__:'SRE_Pattern'\n        }\n    }\n    $SRE_PatternDict.__mro__ = [object]\n    $SRE_PatternDict.findall = function(self, string){\n        return obj.findall(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.finditer = function(self, string){\n        return obj.finditer(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.match = function(self, string){\n        return obj.match(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.search = function(self, string){\n        return obj.search(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.sub = function(self,repl,string){\n        return obj.sub(self.pattern,repl,string,self.flags)\n    }\n    $B.set_func_names($SRE_PatternDict, \"_jsre\")\n    // TODO: groups\n    // TODO: groupindex\n    function normflags(flags){\n        return ((flags & obj.I)? 'i' : '') + ((flags & obj.M)? 'm' : '');\n    }\n    // TODO: fullmatch()\n    // TODO: split()\n    // TODO: subn()\n    obj.compile = function(pattern, flags){\n        return {\n            __class__: $SRE_PatternDict,\n            pattern: pattern,\n            flags: normflags(flags)\n        }\n    }\n    obj.escape = function(string){\n        // Escape all the characters in pattern except ASCII letters, numbers\n        // and '_'. This is useful if you want to match an arbitrary literal\n        // string that may have regular expression metacharacters in it.\n        var res = ''\n        var ok = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n        for(var i = 0, _len_i = string.length; i < _len_i; i++){\n            if(ok.search(string.charAt(i))>-1){res += string.charAt(i)}\n        }\n        return res\n    }\n    obj.findall = function(pattern, string, flags){\n        var $ns=$B.args('re.findall', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{}, 'args', 'kw') ,\n            args = $ns['args'] ,\n            _flags = 0;\n        if(args.length>0){var flags = args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags),\n            jsmatch = string.match(jsp)\n        if(jsmatch === null){return []}\n        return jsmatch\n    }\n    obj.finditer = function(pattern, string, flags){\n        var $ns=$B.args('re.finditer', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{},'args','kw'),\n            args = $ns['args'],\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern, flags),\n            jsmatch = string.match(jsp);\n        if(jsmatch === null){return []}\n\n        var _list = []\n        for(var j = 0, _len_j = jsmatch.length; j < _len_j; j++) {\n            var mo = {}\n            mo._match=jsmatch[j]\n            mo.group = function(){\n               var res = []\n               for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                   if(jsmatch[arguments[i]] === undefined){res.push(None)}\n                   else{res.push(jsmatch[arguments[i]])}\n               }\n               if(arguments.length == 1){return res[0]}\n               return tuple.$factory(res)\n            }\n            mo.groups = function(_default){\n               if(_default === undefined){_default=None}\n               var res = []\n               for(var i = 1, _len_i = jsmatch.length; i < _len_i; i++){\n                  if(jsmatch[i] === undefined){res.push(_default)}\n                  else{res.push(jsmatch[i])}\n               }\n               return tuple.$factory(res)\n            }\n            mo.start = function(){return mo._match.index}\n            mo.end = function(){return mo._match.length - mo._match.index}\n            mo.string = string\n            _list.push(mo)\n        }\n        return _list\n    }\n    obj.search = function(pattern, string){\n        var $ns = $B.args('re.search', 2,\n            {pattern:null, string:null},['pattern', 'string'],\n            arguments, {}, 'args', 'kw')\n        var args = $ns['args']\n        if(args.length>0){var flags = args[0]}\n        else{var flags = getattr($ns['kw'], 'get')('flags', '')}\n        flags = normflags(flags)\n        var jsp = new RegExp(pattern, flags)\n        var jsmatch = string.match(jsp)\n        if(jsmatch === null){return None}\n        return MatchObject.$factory(jsmatch, string, pattern)\n    }\n    obj.sub = function(pattern, repl, string){\n        var $ns=$B.args('re.search', 3,\n            {pattern: null, repl: null, string: null},\n            ['pattern', 'repl', 'string'],\n            arguments,{}, 'args', 'kw')\n        for($var in $ns){eval(\"var \" + $var + \"=$ns[$var]\")}\n        var args = $ns['args']\n        var count = _b_.dict.get($ns['kw'], 'count', 0)\n        var flags = _b_.dict.get($ns['kw'], 'flags', '')\n        if(args.length > 0){var count = args[0]}\n        if(args.length > 1){var flags = args[1]}\n        flags = normflags(flags)\n        if(typeof repl == \"string\"){\n            // backreferences are \\1, \\2... in Python but $1,$2... in Javascript\n            repl = repl.replace(/\\\\(\\d+)/g, '$$$1')\n        }else if(typeof repl == \"function\"){\n            // the argument passed to the Python function is the match object\n            // the arguments passed to the Javascript function are :\n            // - the matched substring\n            // - the matched groups\n            // - the offset of the matched substring inside the string\n            // - the string being examined\n            var $repl1 = function(){\n                var mo = Object()\n                mo.string = arguments[arguments.length - 1]\n                var matched = arguments[0];\n                var start = arguments[arguments.length - 2]\n                var end = start + matched.length\n                mo.start = function(){return start}\n                mo.end = function(){return end}\n                groups = []\n                for(var i = 1, _len_i = arguments.length-2; i < _len_i; i++){\n                    groups.push(arguments[i])\n                }\n                mo.groups = function(_default){\n                    if(_default === undefined){_default = None}\n                    var res = []\n                    for(var i = 0, _len_i = groups.length; i < _len_i; i++){\n                        if(groups[i] === undefined){res.push(_default)}\n                        else{res.push(groups[i])}\n                    }\n                    return res\n                }\n                mo.group = function(i){\n                    if(i==0){return matched}\n                    return groups[i-1]\n                }\n                return repl(mo)\n            }\n        }\n        if(count == 0){flags += 'g'}\n        var jsp = new RegExp(pattern, flags)\n        if(typeof repl == 'function'){return string.replace(jsp, $repl1)}\n        else{return string.replace(jsp, repl)}\n    }\n    obj.match = (function(search_func){\n        return function(){\n            // match is like search but pattern must start with ^\n            var pattern = arguments[0]\n            if(pattern.charAt(0) != '^'){pattern = '^'+pattern}\n            var args = [pattern]\n            for(var i = 1, _len_i = arguments.length; i < _len_i; i++){\n                args.push(arguments[i])\n            }\n            return search_func.apply(null, args)\n        }\n    })(obj.search)\n\n    return obj\n}\n)(__BRYTHON__)\n"], "crypto_js": [".py", "", [], 1], "crypto_js.rollups": [".py", "", [], 1], "crypto_js.rollups.sha256": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},\nx=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,\nd)).finalize(c)}}});var w=f.algo={};return f}(Math);\n(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=\nc[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);\n"], "crypto_js.rollups.sha224": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(g,l){var f={},k=f.lib={},h=function(){},m=k.Base={extend:function(a){h.prototype=this;var c=new h;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=k.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),t=f.enc={},s=t.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},n=t.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},j=t.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\nw=k.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?g.ceil(f):g.max((f|0)-this._minBufferSize,0);a=f*e;b=g.min(4*a,b);if(a){for(var u=0;u<a;u+=e)this._doProcessBlock(d,u);u=d.splice(0,a);c.sigBytes-=b}return new q.init(u,b)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});k.Hasher=w.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){w.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new v.HMAC.init(a,\nd)).finalize(c)}}});var v=f.algo={};return f}(Math);\n(function(g){for(var l=CryptoJS,f=l.lib,k=f.WordArray,h=f.Hasher,f=l.algo,m=[],q=[],t=function(a){return 4294967296*(a-(a|0))|0},s=2,n=0;64>n;){var j;a:{j=s;for(var w=g.sqrt(j),v=2;v<=w;v++)if(!(j%v)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=t(g.pow(s,0.5))),q[n]=t(g.pow(s,1/3)),n++);s++}var a=[],f=f.SHA256=h.extend({_doReset:function(){this._hash=new k.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],k=b[3],h=b[4],l=b[5],m=b[6],n=b[7],p=0;64>p;p++){if(16>p)a[p]=\nc[d+p]|0;else{var j=a[p-15],r=a[p-2];a[p]=((j<<25|j>>>7)^(j<<14|j>>>18)^j>>>3)+a[p-7]+((r<<15|r>>>17)^(r<<13|r>>>19)^r>>>10)+a[p-16]}j=n+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&l^~h&m)+q[p]+a[p];r=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);n=m;m=l;l=h;h=k+j|0;k=g;g=f;f=e;e=j+r|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+k|0;b[4]=b[4]+h|0;b[5]=b[5]+l|0;b[6]=b[6]+m|0;b[7]=b[7]+n|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=g.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=h.clone.call(this);a._hash=this._hash.clone();return a}});l.SHA256=h._createHelper(f);l.HmacSHA256=h._createHmacHelper(f)})(Math);\n(function(){var g=CryptoJS,l=g.lib.WordArray,f=g.algo,k=f.SHA256,f=f.SHA224=k.extend({_doReset:function(){this._hash=new l.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var f=k._doFinalize.call(this);f.sigBytes-=4;return f}});g.SHA224=k._createHelper(f);g.HmacSHA224=k._createHmacHelper(f)})();\n"], "crypto_js.rollups.sha384": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,c){var d={},j=d.lib={},f=function(){},m=j.Base={extend:function(a){f.prototype=this;var b=new f;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nB=j.WordArray=m.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=c?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,g=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var k=0;k<a;k++)b[e+k>>>2]|=(g[k>>>2]>>>24-8*(k%4)&255)<<24-8*((e+k)%4);else if(65535<g.length)for(k=0;k<a;k+=4)b[e+k>>>2]=g[k>>>2];else b.push.apply(b,g);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],g=0;g<n;g+=4)b.push(4294967296*a.random()|0);return new B.init(b,n)}}),v=d.enc={},y=v.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++){var k=b[e>>>2]>>>24-8*(e%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e+=2)g[e>>>3]|=parseInt(a.substr(e,\n2),16)<<24-4*(e%8);return new B.init(g,b/2)}},F=v.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++)g.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e++)g[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new B.init(g,b)}},ha=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(F.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return F.parse(unescape(encodeURIComponent(a)))}},\nZ=j.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new B.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=ha.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,g=b.words,e=b.sigBytes,k=this.blockSize,m=e/(4*k),m=n?a.ceil(m):a.max((m|0)-this._minBufferSize,0);n=m*k;e=a.min(4*n,e);if(n){for(var c=0;c<n;c+=k)this._doProcessBlock(g,c);c=g.splice(0,n);b.sigBytes-=e}return new B.init(c,e)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=Z.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){Z.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,g){return(new a.init(g)).finalize(b)}},_createHmacHelper:function(a){return function(b,g){return(new ia.HMAC.init(a,\ng)).finalize(b)}}});var ia=d.algo={};return d}(Math);\n(function(a){var c=CryptoJS,d=c.lib,j=d.Base,f=d.WordArray,c=c.x64={};c.Word=j.extend({init:function(a,c){this.high=a;this.low=c}});c.WordArray=j.extend({init:function(c,d){c=this.words=c||[];this.sigBytes=d!=a?d:8*c.length},toX32:function(){for(var a=this.words,c=a.length,d=[],j=0;j<c;j++){var F=a[j];d.push(F.high);d.push(F.low)}return f.create(d,this.sigBytes)},clone:function(){for(var a=j.clone.call(this),c=a.words=this.words.slice(0),d=c.length,f=0;f<d;f++)c[f]=c[f].clone();return a}})})();\n(function(){function a(){return f.create.apply(f,arguments)}for(var c=CryptoJS,d=c.lib.Hasher,j=c.x64,f=j.Word,m=j.WordArray,j=c.algo,B=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],y=0;80>y;y++)v[y]=a();j=j.SHA512=d.extend({_doReset:function(){this._hash=new m.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,c){for(var d=this._hash.words,\nf=d[0],j=d[1],b=d[2],g=d[3],e=d[4],k=d[5],m=d[6],d=d[7],y=f.high,M=f.low,$=j.high,N=j.low,aa=b.high,O=b.low,ba=g.high,P=g.low,ca=e.high,Q=e.low,da=k.high,R=k.low,ea=m.high,S=m.low,fa=d.high,T=d.low,s=y,p=M,G=$,D=N,H=aa,E=O,W=ba,I=P,t=ca,q=Q,U=da,J=R,V=ea,K=S,X=fa,L=T,u=0;80>u;u++){var z=v[u];if(16>u)var r=z.high=a[c+2*u]|0,h=z.low=a[c+2*u+1]|0;else{var r=v[u-15],h=r.high,w=r.low,r=(h>>>1|w<<31)^(h>>>8|w<<24)^h>>>7,w=(w>>>1|h<<31)^(w>>>8|h<<24)^(w>>>7|h<<25),C=v[u-2],h=C.high,l=C.low,C=(h>>>19|l<<\n13)^(h<<3|l>>>29)^h>>>6,l=(l>>>19|h<<13)^(l<<3|h>>>29)^(l>>>6|h<<26),h=v[u-7],Y=h.high,A=v[u-16],x=A.high,A=A.low,h=w+h.low,r=r+Y+(h>>>0<w>>>0?1:0),h=h+l,r=r+C+(h>>>0<l>>>0?1:0),h=h+A,r=r+x+(h>>>0<A>>>0?1:0);z.high=r;z.low=h}var Y=t&U^~t&V,A=q&J^~q&K,z=s&G^s&H^G&H,ja=p&D^p&E^D&E,w=(s>>>28|p<<4)^(s<<30|p>>>2)^(s<<25|p>>>7),C=(p>>>28|s<<4)^(p<<30|s>>>2)^(p<<25|s>>>7),l=B[u],ka=l.high,ga=l.low,l=L+((q>>>14|t<<18)^(q>>>18|t<<14)^(q<<23|t>>>9)),x=X+((t>>>14|q<<18)^(t>>>18|q<<14)^(t<<23|q>>>9))+(l>>>0<\nL>>>0?1:0),l=l+A,x=x+Y+(l>>>0<A>>>0?1:0),l=l+ga,x=x+ka+(l>>>0<ga>>>0?1:0),l=l+h,x=x+r+(l>>>0<h>>>0?1:0),h=C+ja,z=w+z+(h>>>0<C>>>0?1:0),X=V,L=K,V=U,K=J,U=t,J=q,q=I+l|0,t=W+x+(q>>>0<I>>>0?1:0)|0,W=H,I=E,H=G,E=D,G=s,D=p,p=l+h|0,s=x+z+(p>>>0<l>>>0?1:0)|0}M=f.low=M+p;f.high=y+s+(M>>>0<p>>>0?1:0);N=j.low=N+D;j.high=$+G+(N>>>0<D>>>0?1:0);O=b.low=O+E;b.high=aa+H+(O>>>0<E>>>0?1:0);P=g.low=P+I;g.high=ba+W+(P>>>0<I>>>0?1:0);Q=e.low=Q+q;e.high=ca+t+(Q>>>0<q>>>0?1:0);R=k.low=R+J;k.high=da+U+(R>>>0<J>>>0?1:0);\nS=m.low=S+K;m.high=ea+V+(S>>>0<K>>>0?1:0);T=d.low=T+L;d.high=fa+X+(T>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,c=a.words,d=8*this._nDataBytes,f=8*a.sigBytes;c[f>>>5]|=128<<24-f%32;c[(f+128>>>10<<5)+30]=Math.floor(d/4294967296);c[(f+128>>>10<<5)+31]=d;a.sigBytes=4*c.length;this._process();return this._hash.toX32()},clone:function(){var a=d.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});c.SHA512=d._createHelper(j);c.HmacSHA512=d._createHmacHelper(j)})();\n(function(){var a=CryptoJS,c=a.x64,d=c.Word,j=c.WordArray,c=a.algo,f=c.SHA512,c=c.SHA384=f.extend({_doReset:function(){this._hash=new j.init([new d.init(3418070365,3238371032),new d.init(1654270250,914150663),new d.init(2438529370,812702999),new d.init(355462360,4144912697),new d.init(1731405415,4290775857),new d.init(2394180231,1750603025),new d.init(3675008525,1694076839),new d.init(1203062813,3204075428)])},_doFinalize:function(){var a=f._doFinalize.call(this);a.sigBytes-=16;return a}});a.SHA384=\nf._createHelper(c);a.HmacSHA384=f._createHmacHelper(c)})();\n"], "crypto_js.rollups.sha1": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nn=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,\n2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},\nk=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,\nf)).finalize(b)}}});var s=p.algo={};return p}(Math);\n(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^\nk)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();\n"], "crypto_js.rollups.sha512": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,m){var r={},f=r.lib={},g=function(){},l=f.Base={extend:function(a){g.prototype=this;var b=new g;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\np=f.WordArray=l.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=m?b:4*a.length},toString:function(a){return(a||q).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var j=0;j<a;j++)b[c+j>>>2]|=(d[j>>>2]>>>24-8*(j%4)&255)<<24-8*((c+j)%4);else if(65535<d.length)for(j=0;j<a;j+=4)b[c+j>>>2]=d[j>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],d=0;d<n;d+=4)b.push(4294967296*a.random()|0);return new p.init(b,n)}}),y=r.enc={},q=y.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var j=b[c>>>2]>>>24-8*(c%4)&255;d.push((j>>>4).toString(16));d.push((j&15).toString(16))}return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,\n2),16)<<24-4*(c%8);return new p.init(d,b/2)}},G=y.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new p.init(d,b)}},fa=y.Utf8={stringify:function(a){try{return decodeURIComponent(escape(G.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return G.parse(unescape(encodeURIComponent(a)))}},\nh=f.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=fa.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,d=b.words,c=b.sigBytes,j=this.blockSize,l=c/(4*j),l=n?a.ceil(l):a.max((l|0)-this._minBufferSize,0);n=l*j;c=a.min(4*n,c);if(n){for(var h=0;h<n;h+=j)this._doProcessBlock(d,h);h=d.splice(0,n);b.sigBytes-=c}return new p.init(h,c)},clone:function(){var a=l.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});f.Hasher=h.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){h.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new ga.HMAC.init(a,\nd)).finalize(b)}}});var ga=r.algo={};return r}(Math);\n(function(a){var m=CryptoJS,r=m.lib,f=r.Base,g=r.WordArray,m=m.x64={};m.Word=f.extend({init:function(a,p){this.high=a;this.low=p}});m.WordArray=f.extend({init:function(l,p){l=this.words=l||[];this.sigBytes=p!=a?p:8*l.length},toX32:function(){for(var a=this.words,p=a.length,f=[],q=0;q<p;q++){var G=a[q];f.push(G.high);f.push(G.low)}return g.create(f,this.sigBytes)},clone:function(){for(var a=f.clone.call(this),p=a.words=this.words.slice(0),g=p.length,q=0;q<g;q++)p[q]=p[q].clone();return a}})})();\n(function(){function a(){return g.create.apply(g,arguments)}for(var m=CryptoJS,r=m.lib.Hasher,f=m.x64,g=f.Word,l=f.WordArray,f=m.algo,p=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],y=[],q=0;80>q;q++)y[q]=a();f=f.SHA512=r.extend({_doReset:function(){this._hash=new l.init([new g.init(1779033703,4089235720),new g.init(3144134277,2227873595),new g.init(1013904242,4271175723),new g.init(2773480762,1595750129),new g.init(1359893119,2917565137),new g.init(2600822924,725511199),new g.init(528734635,4215389547),new g.init(1541459225,327033209)])},_doProcessBlock:function(a,f){for(var h=this._hash.words,\ng=h[0],n=h[1],b=h[2],d=h[3],c=h[4],j=h[5],l=h[6],h=h[7],q=g.high,m=g.low,r=n.high,N=n.low,Z=b.high,O=b.low,$=d.high,P=d.low,aa=c.high,Q=c.low,ba=j.high,R=j.low,ca=l.high,S=l.low,da=h.high,T=h.low,v=q,s=m,H=r,E=N,I=Z,F=O,W=$,J=P,w=aa,t=Q,U=ba,K=R,V=ca,L=S,X=da,M=T,x=0;80>x;x++){var B=y[x];if(16>x)var u=B.high=a[f+2*x]|0,e=B.low=a[f+2*x+1]|0;else{var u=y[x-15],e=u.high,z=u.low,u=(e>>>1|z<<31)^(e>>>8|z<<24)^e>>>7,z=(z>>>1|e<<31)^(z>>>8|e<<24)^(z>>>7|e<<25),D=y[x-2],e=D.high,k=D.low,D=(e>>>19|k<<13)^\n(e<<3|k>>>29)^e>>>6,k=(k>>>19|e<<13)^(k<<3|e>>>29)^(k>>>6|e<<26),e=y[x-7],Y=e.high,C=y[x-16],A=C.high,C=C.low,e=z+e.low,u=u+Y+(e>>>0<z>>>0?1:0),e=e+k,u=u+D+(e>>>0<k>>>0?1:0),e=e+C,u=u+A+(e>>>0<C>>>0?1:0);B.high=u;B.low=e}var Y=w&U^~w&V,C=t&K^~t&L,B=v&H^v&I^H&I,ha=s&E^s&F^E&F,z=(v>>>28|s<<4)^(v<<30|s>>>2)^(v<<25|s>>>7),D=(s>>>28|v<<4)^(s<<30|v>>>2)^(s<<25|v>>>7),k=p[x],ia=k.high,ea=k.low,k=M+((t>>>14|w<<18)^(t>>>18|w<<14)^(t<<23|w>>>9)),A=X+((w>>>14|t<<18)^(w>>>18|t<<14)^(w<<23|t>>>9))+(k>>>0<M>>>\n0?1:0),k=k+C,A=A+Y+(k>>>0<C>>>0?1:0),k=k+ea,A=A+ia+(k>>>0<ea>>>0?1:0),k=k+e,A=A+u+(k>>>0<e>>>0?1:0),e=D+ha,B=z+B+(e>>>0<D>>>0?1:0),X=V,M=L,V=U,L=K,U=w,K=t,t=J+k|0,w=W+A+(t>>>0<J>>>0?1:0)|0,W=I,J=F,I=H,F=E,H=v,E=s,s=k+e|0,v=A+B+(s>>>0<k>>>0?1:0)|0}m=g.low=m+s;g.high=q+v+(m>>>0<s>>>0?1:0);N=n.low=N+E;n.high=r+H+(N>>>0<E>>>0?1:0);O=b.low=O+F;b.high=Z+I+(O>>>0<F>>>0?1:0);P=d.low=P+J;d.high=$+W+(P>>>0<J>>>0?1:0);Q=c.low=Q+t;c.high=aa+w+(Q>>>0<t>>>0?1:0);R=j.low=R+K;j.high=ba+U+(R>>>0<K>>>0?1:0);S=l.low=\nS+L;l.high=ca+V+(S>>>0<L>>>0?1:0);T=h.low=T+M;h.high=da+X+(T>>>0<M>>>0?1:0)},_doFinalize:function(){var a=this._data,f=a.words,h=8*this._nDataBytes,g=8*a.sigBytes;f[g>>>5]|=128<<24-g%32;f[(g+128>>>10<<5)+30]=Math.floor(h/4294967296);f[(g+128>>>10<<5)+31]=h;a.sigBytes=4*f.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});m.SHA512=r._createHelper(f);m.HmacSHA512=r._createHmacHelper(f)})();\n"], "crypto_js.rollups.md5": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(s,p){var m={},l=m.lib={},n=function(){},r=l.Base={extend:function(b){n.prototype=this;var h=new n;b&&h.mixIn(b);h.hasOwnProperty(\"init\")||(h.init=function(){h.$super.init.apply(this,arguments)});h.init.prototype=h;h.$super=this;return h},create:function(){var b=this.extend();b.init.apply(b,arguments);return b},init:function(){},mixIn:function(b){for(var h in b)b.hasOwnProperty(h)&&(this[h]=b[h]);b.hasOwnProperty(\"toString\")&&(this.toString=b.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=l.WordArray=r.extend({init:function(b,h){b=this.words=b||[];this.sigBytes=h!=p?h:4*b.length},toString:function(b){return(b||t).stringify(this)},concat:function(b){var h=this.words,a=b.words,j=this.sigBytes;b=b.sigBytes;this.clamp();if(j%4)for(var g=0;g<b;g++)h[j+g>>>2]|=(a[g>>>2]>>>24-8*(g%4)&255)<<24-8*((j+g)%4);else if(65535<a.length)for(g=0;g<b;g+=4)h[j+g>>>2]=a[g>>>2];else h.push.apply(h,a);this.sigBytes+=b;return this},clamp:function(){var b=this.words,h=this.sigBytes;b[h>>>2]&=4294967295<<\n32-8*(h%4);b.length=s.ceil(h/4)},clone:function(){var b=r.clone.call(this);b.words=this.words.slice(0);return b},random:function(b){for(var h=[],a=0;a<b;a+=4)h.push(4294967296*s.random()|0);return new q.init(h,b)}}),v=m.enc={},t=v.Hex={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++){var k=a[j>>>2]>>>24-8*(j%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j+=2)g[j>>>3]|=parseInt(b.substr(j,\n2),16)<<24-4*(j%8);return new q.init(g,a/2)}},a=v.Latin1={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++)g.push(String.fromCharCode(a[j>>>2]>>>24-8*(j%4)&255));return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j++)g[j>>>2]|=(b.charCodeAt(j)&255)<<24-8*(j%4);return new q.init(g,a)}},u=v.Utf8={stringify:function(b){try{return decodeURIComponent(escape(a.stringify(b)))}catch(g){throw Error(\"Malformed UTF-8 data\");}},parse:function(b){return a.parse(unescape(encodeURIComponent(b)))}},\ng=l.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(b){\"string\"==typeof b&&(b=u.parse(b));this._data.concat(b);this._nDataBytes+=b.sigBytes},_process:function(b){var a=this._data,g=a.words,j=a.sigBytes,k=this.blockSize,m=j/(4*k),m=b?s.ceil(m):s.max((m|0)-this._minBufferSize,0);b=m*k;j=s.min(4*b,j);if(b){for(var l=0;l<b;l+=k)this._doProcessBlock(g,l);l=g.splice(0,b);a.sigBytes-=j}return new q.init(l,j)},clone:function(){var b=r.clone.call(this);\nb._data=this._data.clone();return b},_minBufferSize:0});l.Hasher=g.extend({cfg:r.extend(),init:function(b){this.cfg=this.cfg.extend(b);this.reset()},reset:function(){g.reset.call(this);this._doReset()},update:function(b){this._append(b);this._process();return this},finalize:function(b){b&&this._append(b);return this._doFinalize()},blockSize:16,_createHelper:function(b){return function(a,g){return(new b.init(g)).finalize(a)}},_createHmacHelper:function(b){return function(a,g){return(new k.HMAC.init(b,\ng)).finalize(a)}}});var k=m.algo={};return m}(Math);\n(function(s){function p(a,k,b,h,l,j,m){a=a+(k&b|~k&h)+l+m;return(a<<j|a>>>32-j)+k}function m(a,k,b,h,l,j,m){a=a+(k&h|b&~h)+l+m;return(a<<j|a>>>32-j)+k}function l(a,k,b,h,l,j,m){a=a+(k^b^h)+l+m;return(a<<j|a>>>32-j)+k}function n(a,k,b,h,l,j,m){a=a+(b^(k|~h))+l+m;return(a<<j|a>>>32-j)+k}for(var r=CryptoJS,q=r.lib,v=q.WordArray,t=q.Hasher,q=r.algo,a=[],u=0;64>u;u++)a[u]=4294967296*s.abs(s.sin(u+1))|0;q=q.MD5=t.extend({_doReset:function(){this._hash=new v.init([1732584193,4023233417,2562383102,271733878])},\n_doProcessBlock:function(g,k){for(var b=0;16>b;b++){var h=k+b,w=g[h];g[h]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var b=this._hash.words,h=g[k+0],w=g[k+1],j=g[k+2],q=g[k+3],r=g[k+4],s=g[k+5],t=g[k+6],u=g[k+7],v=g[k+8],x=g[k+9],y=g[k+10],z=g[k+11],A=g[k+12],B=g[k+13],C=g[k+14],D=g[k+15],c=b[0],d=b[1],e=b[2],f=b[3],c=p(c,d,e,f,h,7,a[0]),f=p(f,c,d,e,w,12,a[1]),e=p(e,f,c,d,j,17,a[2]),d=p(d,e,f,c,q,22,a[3]),c=p(c,d,e,f,r,7,a[4]),f=p(f,c,d,e,s,12,a[5]),e=p(e,f,c,d,t,17,a[6]),d=p(d,e,f,c,u,22,a[7]),\nc=p(c,d,e,f,v,7,a[8]),f=p(f,c,d,e,x,12,a[9]),e=p(e,f,c,d,y,17,a[10]),d=p(d,e,f,c,z,22,a[11]),c=p(c,d,e,f,A,7,a[12]),f=p(f,c,d,e,B,12,a[13]),e=p(e,f,c,d,C,17,a[14]),d=p(d,e,f,c,D,22,a[15]),c=m(c,d,e,f,w,5,a[16]),f=m(f,c,d,e,t,9,a[17]),e=m(e,f,c,d,z,14,a[18]),d=m(d,e,f,c,h,20,a[19]),c=m(c,d,e,f,s,5,a[20]),f=m(f,c,d,e,y,9,a[21]),e=m(e,f,c,d,D,14,a[22]),d=m(d,e,f,c,r,20,a[23]),c=m(c,d,e,f,x,5,a[24]),f=m(f,c,d,e,C,9,a[25]),e=m(e,f,c,d,q,14,a[26]),d=m(d,e,f,c,v,20,a[27]),c=m(c,d,e,f,B,5,a[28]),f=m(f,c,\nd,e,j,9,a[29]),e=m(e,f,c,d,u,14,a[30]),d=m(d,e,f,c,A,20,a[31]),c=l(c,d,e,f,s,4,a[32]),f=l(f,c,d,e,v,11,a[33]),e=l(e,f,c,d,z,16,a[34]),d=l(d,e,f,c,C,23,a[35]),c=l(c,d,e,f,w,4,a[36]),f=l(f,c,d,e,r,11,a[37]),e=l(e,f,c,d,u,16,a[38]),d=l(d,e,f,c,y,23,a[39]),c=l(c,d,e,f,B,4,a[40]),f=l(f,c,d,e,h,11,a[41]),e=l(e,f,c,d,q,16,a[42]),d=l(d,e,f,c,t,23,a[43]),c=l(c,d,e,f,x,4,a[44]),f=l(f,c,d,e,A,11,a[45]),e=l(e,f,c,d,D,16,a[46]),d=l(d,e,f,c,j,23,a[47]),c=n(c,d,e,f,h,6,a[48]),f=n(f,c,d,e,u,10,a[49]),e=n(e,f,c,d,\nC,15,a[50]),d=n(d,e,f,c,s,21,a[51]),c=n(c,d,e,f,A,6,a[52]),f=n(f,c,d,e,q,10,a[53]),e=n(e,f,c,d,y,15,a[54]),d=n(d,e,f,c,w,21,a[55]),c=n(c,d,e,f,v,6,a[56]),f=n(f,c,d,e,D,10,a[57]),e=n(e,f,c,d,t,15,a[58]),d=n(d,e,f,c,B,21,a[59]),c=n(c,d,e,f,r,6,a[60]),f=n(f,c,d,e,z,10,a[61]),e=n(e,f,c,d,j,15,a[62]),d=n(d,e,f,c,x,21,a[63]);b[0]=b[0]+c|0;b[1]=b[1]+d|0;b[2]=b[2]+e|0;b[3]=b[3]+f|0},_doFinalize:function(){var a=this._data,k=a.words,b=8*this._nDataBytes,h=8*a.sigBytes;k[h>>>5]|=128<<24-h%32;var l=s.floor(b/\n4294967296);k[(h+64>>>9<<4)+15]=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360;k[(h+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;a.sigBytes=4*(k.length+1);this._process();a=this._hash;k=a.words;for(b=0;4>b;b++)h=k[b],k[b]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;return a},clone:function(){var a=t.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=t._createHelper(q);r.HmacMD5=t._createHmacHelper(q)})(Math);\n"], "crypto_js.rollups.sha3": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(v,p){var d={},u=d.lib={},r=function(){},f=u.Base={extend:function(a){r.prototype=this;var b=new r;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\ns=u.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=p?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,c=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var n=0;n<a;n++)b[j+n>>>2]|=(c[n>>>2]>>>24-8*(n%4)&255)<<24-8*((j+n)%4);else if(65535<c.length)for(n=0;n<a;n+=4)b[j+n>>>2]=c[n>>>2];else b.push.apply(b,c);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<\n32-8*(b%4);a.length=v.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],c=0;c<a;c+=4)b.push(4294967296*v.random()|0);return new s.init(b,a)}}),x=d.enc={},y=x.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++){var n=b[j>>>2]>>>24-8*(j%4)&255;c.push((n>>>4).toString(16));c.push((n&15).toString(16))}return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j+=2)c[j>>>3]|=parseInt(a.substr(j,\n2),16)<<24-4*(j%8);return new s.init(c,b/2)}},e=x.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++)c.push(String.fromCharCode(b[j>>>2]>>>24-8*(j%4)&255));return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j++)c[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new s.init(c,b)}},q=x.Utf8={stringify:function(a){try{return decodeURIComponent(escape(e.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return e.parse(unescape(encodeURIComponent(a)))}},\nt=u.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new s.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=q.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,c=b.words,j=b.sigBytes,n=this.blockSize,e=j/(4*n),e=a?v.ceil(e):v.max((e|0)-this._minBufferSize,0);a=e*n;j=v.min(4*a,j);if(a){for(var f=0;f<a;f+=n)this._doProcessBlock(c,f);f=c.splice(0,a);b.sigBytes-=j}return new s.init(f,j)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});u.Hasher=t.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){t.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,c){return(new a.init(c)).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return(new w.HMAC.init(a,\nc)).finalize(b)}}});var w=d.algo={};return d}(Math);\n(function(v){var p=CryptoJS,d=p.lib,u=d.Base,r=d.WordArray,p=p.x64={};p.Word=u.extend({init:function(f,s){this.high=f;this.low=s}});p.WordArray=u.extend({init:function(f,s){f=this.words=f||[];this.sigBytes=s!=v?s:8*f.length},toX32:function(){for(var f=this.words,s=f.length,d=[],p=0;p<s;p++){var e=f[p];d.push(e.high);d.push(e.low)}return r.create(d,this.sigBytes)},clone:function(){for(var f=u.clone.call(this),d=f.words=this.words.slice(0),p=d.length,r=0;r<p;r++)d[r]=d[r].clone();return f}})})();\n(function(v){for(var p=CryptoJS,d=p.lib,u=d.WordArray,r=d.Hasher,f=p.x64.Word,d=p.algo,s=[],x=[],y=[],e=1,q=0,t=0;24>t;t++){s[e+5*q]=(t+1)*(t+2)/2%64;var w=(2*e+3*q)%5,e=q%5,q=w}for(e=0;5>e;e++)for(q=0;5>q;q++)x[e+5*q]=q+5*((2*e+3*q)%5);e=1;for(q=0;24>q;q++){for(var a=w=t=0;7>a;a++){if(e&1){var b=(1<<a)-1;32>b?w^=1<<b:t^=1<<b-32}e=e&128?e<<1^113:e<<1}y[q]=f.create(t,w)}for(var c=[],e=0;25>e;e++)c[e]=f.create();d=d.SHA3=r.extend({cfg:r.cfg.extend({outputLength:512}),_doReset:function(){for(var a=this._state=\n[],b=0;25>b;b++)a[b]=new f.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(a,b){for(var e=this._state,f=this.blockSize/2,h=0;h<f;h++){var l=a[b+2*h],m=a[b+2*h+1],l=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360,m=(m<<8|m>>>24)&16711935|(m<<24|m>>>8)&4278255360,g=e[h];g.high^=m;g.low^=l}for(f=0;24>f;f++){for(h=0;5>h;h++){for(var d=l=0,k=0;5>k;k++)g=e[h+5*k],l^=g.high,d^=g.low;g=c[h];g.high=l;g.low=d}for(h=0;5>h;h++){g=c[(h+4)%5];l=c[(h+1)%5];m=l.high;k=l.low;l=g.high^\n(m<<1|k>>>31);d=g.low^(k<<1|m>>>31);for(k=0;5>k;k++)g=e[h+5*k],g.high^=l,g.low^=d}for(m=1;25>m;m++)g=e[m],h=g.high,g=g.low,k=s[m],32>k?(l=h<<k|g>>>32-k,d=g<<k|h>>>32-k):(l=g<<k-32|h>>>64-k,d=h<<k-32|g>>>64-k),g=c[x[m]],g.high=l,g.low=d;g=c[0];h=e[0];g.high=h.high;g.low=h.low;for(h=0;5>h;h++)for(k=0;5>k;k++)m=h+5*k,g=e[m],l=c[m],m=c[(h+1)%5+5*k],d=c[(h+2)%5+5*k],g.high=l.high^~m.high&d.high,g.low=l.low^~m.low&d.low;g=e[0];h=y[f];g.high^=h.high;g.low^=h.low}},_doFinalize:function(){var a=this._data,\nb=a.words,c=8*a.sigBytes,e=32*this.blockSize;b[c>>>5]|=1<<24-c%32;b[(v.ceil((c+1)/e)*e>>>5)-1]|=128;a.sigBytes=4*b.length;this._process();for(var a=this._state,b=this.cfg.outputLength/8,c=b/8,e=[],h=0;h<c;h++){var d=a[h],f=d.high,d=d.low,f=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360,d=(d<<8|d>>>24)&16711935|(d<<24|d>>>8)&4278255360;e.push(d);e.push(f)}return new u.init(e,b)},clone:function(){for(var a=r.clone.call(this),b=a._state=this._state.slice(0),c=0;25>c;c++)b[c]=b[c].clone();return a}});\np.SHA3=r._createHelper(d);p.HmacSHA3=r._createHmacHelper(d)})(Math);\n"], "contextvars": [".py", "from _contextvars import Context,ContextVar,Token,copy_context\n\n\n__all__=('Context','ContextVar','Token','copy_context')\n", ["_contextvars"]], "time": [".py", "import _locale\nimport javascript\n\n\ndate=javascript.Date.new\nnow=javascript.Date.now\n\n\n\n\n\n\n\n_STRUCT_TM_ITEMS=9\n\n\n\n\n\ndef _get_day_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n return yday\n \ndef _get_week_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n\n \n d1=date(arg[0],arg[1]-1,arg[2])\n d0=date(arg[0],0,1)\n firstday=d0.getDay()\n if firstday ==0:\n  firstday=7\n firstweek=8 -firstday\n doy=arg[7]\n if firstday !=1:\n  doy=doy -firstweek\n if doy %7 ==0:\n  week_number=doy //7\n else :\n  week_number=doy //7+1\n return week_number\n \ndef _check_struct_time(t):\n mm=t[1]\n if mm ==0:\n  mm=1\n if -1 >mm >13:\n  raise ValueError(\"month out of range\")\n  \n dd=t[2]\n if dd ==0:dd=1\n if -1 >dd >32:\n  raise ValueError(\"day of month out of range\")\n  \n hh=t[3]\n if -1 >hh >24:\n  raise ValueError(\"hour out of range\")\n  \n minu=t[4]\n if -1 >minu >60:\n  raise ValueError(\"minute out of range\")\n  \n ss=t[5]\n if -1 >ss >62:\n  raise ValueError(\"seconds out of range\")\n  \n wd=t[6]%7\n if wd <-2:\n  raise ValueError(\"day of week out of range\")\n  \n dy=t[7]\n if dy ==0:dy=1\n if -1 >dy >367:\n  raise ValueError(\"day of year out of range\")\n  \n return t[0],mm,dd,hh,minu,ss,wd,dy,t[-1]\n \n \ndef _is_dst(secs=None ):\n ''\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n  \n  \n  \n jan=date(d.getFullYear(),0,1)\n jul=date(d.getFullYear(),6,1)\n dst=int(d.getTimezoneOffset()<max(abs(jan.getTimezoneOffset()),\n abs(jul.getTimezoneOffset())))\n return dst\n \ndef _get_tzname():\n ''\n d=date()\n d=d.toTimeString()\n try :\n  d=d.split('(')[1].split(')')[0]\n  return (d,'NotAvailable')\n except :\n  return ('','')\n  \ndef _set_altzone():\n d=date()\n jan=date(d.getFullYear(),0,1)\n jul=date(d.getFullYear(),6,1)\n result=timezone -(jan.getTimezoneOffset()-jul.getTimezoneOffset())*60\n return result\n \ndef _check_input(t):\n if t and isinstance(t,struct_time)and len(t.args)==9:\n  t=t.args\n elif t and isinstance(t,tuple)and len(t)==9:\n  t=t\n elif t and isinstance(t,struct_time)and len(t.args)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t.args)))\n elif t and isinstance(t,tuple)and len(t)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t)))\n elif t and not isinstance(t,(tuple,struct_time)):\n  raise TypeError(\"Tuple or struct_time argument required\")\n else :\n  t=localtime().args\n return t\n \n \n \n \n \ndaylight=_is_dst()\ntimezone=date().getTimezoneOffset()*60\ntzname=_get_tzname()\naltzone=_set_altzone()if daylight else timezone\n\n\ndef asctime(t=None ):\n weekdays={i:day for (i,day)in\n enumerate(\"Mon Tue Wed Thu Fri Sat Sun\".split())\n }\n \n months={i+1:month for (i,month)in\n enumerate(\"Jan Fev Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split())\n }\n \n t=_check_input(t)\n t=_check_struct_time(t)\n \n result=\"%s %s %2d %02d:%02d:%02d %d\"%(\n weekdays[t[6]],months[t[1]],t[2],t[3],t[4],t[5],t[0])\n return result\n \ndef ctime(timestamp=None ):\n return asctime(localtime(timestamp))\n \ndef gmtime(secs=None ):\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n wday=d.getUTCDay()-1 if d.getUTCDay()-1 >=0 else 6\n tmp=struct_time([d.getUTCFullYear(),\n d.getUTCMonth()+1,d.getUTCDate(),\n d.getUTCHours(),d.getUTCMinutes(),d.getUTCSeconds(),\n wday,0,0])\n tmp.args[7]=_get_day_of_year(tmp.args)\n return tmp\n \ndef localtime(secs=None ):\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n dst=_is_dst(secs)\n wday=d.getDay()-1 if d.getDay()-1 >=0 else 6\n tmp=struct_time([d.getFullYear(),\n d.getMonth()+1,d.getDate(),\n d.getHours(),d.getMinutes(),d.getSeconds(),\n wday,0,dst])\n tmp.args[7]=_get_day_of_year(tmp.args)\n return tmp\n \ndef mktime(t):\n if isinstance(t,struct_time):\n  d1=date(t.tm_year,t.tm_mon -1,t.tm_mday,\n  t.tm_hour,t.tm_min,t.tm_sec,0).getTime()\n elif isinstance(t,tuple):\n  d1=date(t[0],t[1]-1,t[2],t[3],t[4],t[5],0).getTime()\n else :\n  raise ValueError(\"Tuple or struct_time argument required\")\n d2=date(0).getTime()\n return (d1 -d2)/1000.\n \ndef monotonic():\n return now()/1000.\n \ndef perf_counter():\n return now()/1000.\n \ndef process_time():\n return now()/1000.\n \ndef time():\n return float(date().getTime()/1000)\n \ndef sleep(secs):\n ''\n\n \n raise NotImplementedError(\"Blocking functions like time.sleep() are not \"\n \"supported in the browser. Use functions in module browser.timer \"\n \"instead.\")\n \ndef strftime(_format,t=None ):\n def ns(t,nb):\n \n  res=str(t)\n  while len(res)<nb:\n   res='0'+res\n  return res\n  \n t=_check_input(t)\n t=_check_struct_time(t)\n \n YY=ns(t[0],4)\n yy=ns(t[0],4)[2:]\n mm=ns(t[1],2)\n dd=ns(t[2],2)\n HH=t[3]\n HH24=ns(HH,2)\n HH12=ns(HH %12,2)\n if HH12 ==0:\n  HH12=12\n AMPM='AM'if 0 <=HH <12 else 'PM'\n MM=ns(t[4],2)\n SS=ns(t[5],2)\n DoY=ns(t[7],3)\n w=t[6]+1 if t[6]<6 else 0\n W=ns(_get_week_of_year(t),2)\n \n abb_weekdays=['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n full_weekdays=['Sunday','Monday','Tuesday','Wednesday',\n 'Thursday','Friday','Saturday']\n abb_months=['Jan','Feb','Mar','Apr','May','Jun',\n 'Jul','Aug','Sep','Oct','Nov','Dec']\n full_months=['January','February','March','April','May','June',\n 'July','August','September','October','November','December']\n \n res=_format\n if __BRYTHON__.locale ==\"C\":\n  res=res.replace(\"%c\",abb_weekdays[w]+' '+abb_months[int(mm)-1]+\n  ' '+dd+' '+HH24+':'+MM+':'+SS+' '+YY)\n  res=res.replace(\"%x\",mm+'/'+dd+'/'+yy)\n  res=res.replace(\"%X\",HH24+':'+MM+':'+SS)\n else :\n  formatter=_locale._date_format\n  c_format=formatter(\"x\")+\" \"+formatter(\"X\")\n  res=res.replace(\"%c\",c_format)\n  x_format=formatter(\"x\")\n  res=res.replace(\"%x\",x_format)\n  X_format=formatter(\"X\")\n  res=res.replace(\"%X\",X_format)\n  \n res=res.replace(\"%H\",HH24)\n res=res.replace(\"%I\",HH12)\n res=res.replace(\"%i\",HH12.lstrip(\"0\"))\n res=res.replace(\"%p\",AMPM)\n res=res.replace(\"%M\",MM)\n res=res.replace(\"%S\",SS)\n res=res.replace(\"%Y\",YY)\n res=res.replace(\"%y\",yy)\n res=res.replace(\"%m\",mm)\n res=res.replace(\"%d\",dd)\n res=res.replace(\"%a\",abb_weekdays[w])\n res=res.replace(\"%A\",full_weekdays[w])\n res=res.replace(\"%b\",abb_months[int(mm)-1])\n res=res.replace(\"%B\",full_months[int(mm)-1])\n res=res.replace(\"%j\",DoY)\n res=res.replace(\"%w\",str(w))\n res=res.replace(\"%W\",W)\n res=res.replace(\"%%\",'%')\n \n return res\n \nclass struct_time:\n\n def __init__(self,*args,**kw):\n \n  time_tuple=args[0]\n  if len(time_tuple)!=9:\n   raise TypeError(\"time.struct_time() takes a 9-sequence (%s-sequence given)\"%len(args))\n   \n  self.args=time_tuple\n  \n @property\n def tm_year(self):\n  return self.args[0]\n  \n @property\n def tm_mon(self):\n  return self.args[1]\n  \n @property\n def tm_mday(self):\n  return self.args[2]\n  \n @property\n def tm_hour(self):\n  return self.args[3]\n  \n @property\n def tm_min(self):\n  return self.args[4]\n  \n @property\n def tm_sec(self):\n  return self.args[5]\n  \n @property\n def tm_wday(self):\n  return self.args[6]\n  \n @property\n def tm_yday(self):\n  return self.args[7]\n  \n @property\n def tm_isdst(self):\n  return self.args[8]\n  \n def __eq__(self,other):\n  return self.args ==other.args\n  \n def __getitem__(self,i):\n  return self.args[i]\n  \n def __iter__(self):\n  return iter(self.args)\n  \n def __reduce_ex__(self,protocol):\n  return (struct_time,(self.args,{}))\n  \n def __repr__(self):\n  return (\"time.structime(tm_year={}, tm_mon={}, tm_day={}, \"+\\\n  \"tm_hour={}, tm_min={}, tm_sec={}, tm_wday={}, \"+\\\n  \"tm_yday={}, tm_isdst={})\").format(*self.args)\n  \n def __str__(self):\n  return self.__repr__()\n  \ndef to_struct_time(*arg):\n arg=list(arg)\n \n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n  \n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n arg.append(yday)\n arg.append(-1)\n return struct_time(tuple(arg))\n \ndef wait(secs):\n\n pass\n \ndef strptime(string,_format):\n import _strptime\n return _strptime._strptime_datetime(to_struct_time,string,_format)\n \n \n \n_clock_msg=\"\"\"Browser cannot access CPU. See '%s'\"\"\"\ndef _clock_xx(url):\n raise NotImplementedError(_clock_msg %url)\nclock=time\nclock_getres=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_getres\")\nclock_gettime=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_gettime\")\nclock_settime=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_settime\")\nCLOCK_HIGHRES=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_HIGHRES\"\nCLOCK_MONOTONIC=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC\"\nCLOCK_MONOTONIC_RAW=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW\"\nCLOCK_PROCESS_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_PROCESS_CPUTIME_ID\"\nCLOCK_REALTIME=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_REALTIME\"\nCLOCK_THREAD_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_THREAD_CPUTIME_ID\"\n\nclass ClockInfo:\n\n def __init__(self,*kw):\n  for key,value in kw.items():\n   setattr(self,key,value)\n   \ndef get_clock_info(cl):\n\n if cl =='monotonic':\n  return ClockInfo(adjustable=False ,\n  implementation='window.performance.now',\n  monotonic=True ,\n  resolution=0.000001)\n elif cl =='perf_counter'or cl =='process_time':\n  return ClockInfo(adjustable=False ,\n  implementation='date.getTime',\n  monotonic=False ,\n  resolution=0.001)\n else :\n  _clock_xx(\"https://docs.python.org/3/library/time.html#time.get_clock_info\")\n  \ndef tzset():\n pass\n", ["_locale", "_strptime", "javascript"]], "faulthandler": [".py", "''\n\n\n_EXCEPTION_ACCESS_VIOLATION=-1073741819\n\n_EXCEPTION_INT_DIVIDE_BY_ZERO=-1073741676\n\n_EXCEPTION_NONCONTINUABLE=1\n\n_EXCEPTION_NONCONTINUABLE_EXCEPTION=-1073741787\n\n_EXCEPTION_STACK_OVERFLOW=-1073741571\n\nclass __loader__(object):\n ''\n\n\n\n\n \n \n \n __delattr__=\"<slot wrapper '__delattr__' of 'object' objects>\"\n \n __dict__=\"{'__module__': '_frozen_importlib', '__doc__': 'Meta path import for built-in modules.\\n\\n    All methods are either class or static methods to avoid the need to\\n    instantiate the class.\\n\\n    ', 'module_repr': <staticmethod object at 0x000001F9B17F15F8>, 'find_spec': <classmethod object at 0x000001F9B17F1630>, 'find_module': <classmethod object at 0x000001F9B17F1668>, 'create_module': <classmethod object at 0x000001F9B17F16A0>, 'exec_module': <classmethod object at 0x000001F9B17F16D8>, 'get_code': <classmethod object at 0x000001F9B17F1748>, 'get_source': <classmethod object at 0x000001F9B17F17B8>, 'is_package': <classmethod object at 0x000001F9B17F1828>, 'load_module': <classmethod object at 0x000001F9B17F1860>, '__dict__': <attribute '__dict__' of 'BuiltinImporter' objects>, '__weakref__': <attribute '__weakref__' of 'BuiltinImporter' objects>}\"\n \n __dir__=\"<method '__dir__' of 'object' objects>\"\n \n __eq__=\"<slot wrapper '__eq__' of 'object' objects>\"\n \n __format__=\"<method '__format__' of 'object' objects>\"\n \n __ge__=\"<slot wrapper '__ge__' of 'object' objects>\"\n \n __getattribute__=\"<slot wrapper '__getattribute__' of 'object' objects>\"\n \n __gt__=\"<slot wrapper '__gt__' of 'object' objects>\"\n \n __hash__=\"<slot wrapper '__hash__' of 'object' objects>\"\n \n __init__=\"<slot wrapper '__init__' of 'object' objects>\"\n \n def __init_subclass__(*args,**kw):\n  ''\n\n\n  \n  pass\n  \n __le__=\"<slot wrapper '__le__' of 'object' objects>\"\n \n __lt__=\"<slot wrapper '__lt__' of 'object' objects>\"\n \n __module__=\"\"\"_frozen_importlib\"\"\"\n \n __ne__=\"<slot wrapper '__ne__' of 'object' objects>\"\n \n def __new__(*args,**kw):\n  ''\n  pass\n  \n __reduce__=\"<method '__reduce__' of 'object' objects>\"\n \n __reduce_ex__=\"<method '__reduce_ex__' of 'object' objects>\"\n \n __repr__=\"<slot wrapper '__repr__' of 'object' objects>\"\n \n __setattr__=\"<slot wrapper '__setattr__' of 'object' objects>\"\n \n __sizeof__=\"<method '__sizeof__' of 'object' objects>\"\n \n __str__=\"<slot wrapper '__str__' of 'object' objects>\"\n \n def __subclasshook__(*args,**kw):\n  ''\n\n\n\n\n  \n  pass\n  \n __weakref__=\"<attribute '__weakref__' of 'BuiltinImporter' objects>\"\n \n create_module=\"<bound method BuiltinImporter.create_module of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n exec_module=\"<bound method BuiltinImporter.exec_module of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n find_module=\"<bound method BuiltinImporter.find_module of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n find_spec=\"<bound method BuiltinImporter.find_spec of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n get_code=\"<bound method BuiltinImporter.get_code of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n get_source=\"<bound method BuiltinImporter.get_source of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n is_package=\"<bound method BuiltinImporter.is_package of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n load_module=\"<bound method _load_module_shim of <class '_frozen_importlib.BuiltinImporter'>>\"\n \n def module_repr(*args,**kw):\n  ''\n\n\n  \n  pass\n__spec__=\"ModuleSpec(name='faulthandler', loader=<class '_frozen_importlib.BuiltinImporter'>, origin='built-in')\"\n\ndef _fatal_error(*args,**kw):\n ''\n pass\n \ndef _fatal_error_c_thread(*args,**kw):\n ''\n pass\n \ndef _raise_exception(*args,**kw):\n ''\n pass\n \ndef _read_null(*args,**kw):\n ''\n pass\n \ndef _sigabrt(*args,**kw):\n ''\n pass\n \ndef _sigfpe(*args,**kw):\n ''\n pass\n \ndef _sigsegv(*args,**kw):\n ''\n pass\n \ndef cancel_dump_traceback_later(*args,**kw):\n ''\n pass\n \ndef disable(*args,**kw):\n ''\n pass\n \ndef dump_traceback(*args,**kw):\n ''\n pass\n \ndef dump_traceback_later(*args,**kw):\n ''\n \n pass\n \ndef enable(*args,**kw):\n ''\n pass\n \ndef is_enabled(*args,**kw):\n ''\n pass\n", []], "uu": [".py", "#! /usr/bin/env python3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"Implementation of the UUencode and UUdecode functions.\n\nencode(in_file, out_file [,name, mode], *, backtick=False)\ndecode(in_file [, out_file, mode, quiet])\n\"\"\"\n\nimport binascii\nimport os\nimport sys\n\n__all__=[\"Error\",\"encode\",\"decode\"]\n\nclass Error(Exception):\n pass\n \ndef encode(in_file,out_file,name=None ,mode=None ,*,backtick=False ):\n ''\n \n \n \n opened_files=[]\n try :\n  if in_file =='-':\n   in_file=sys.stdin.buffer\n  elif isinstance(in_file,str):\n   if name is None :\n    name=os.path.basename(in_file)\n   if mode is None :\n    try :\n     mode=os.stat(in_file).st_mode\n    except AttributeError:\n     pass\n   in_file=open(in_file,'rb')\n   opened_files.append(in_file)\n   \n   \n   \n  if out_file =='-':\n   out_file=sys.stdout.buffer\n  elif isinstance(out_file,str):\n   out_file=open(out_file,'wb')\n   opened_files.append(out_file)\n   \n   \n   \n  if name is None :\n   name='-'\n  if mode is None :\n   mode=0o666\n   \n   \n   \n  out_file.write(('begin %o %s\\n'%((mode&0o777),name)).encode(\"ascii\"))\n  data=in_file.read(45)\n  while len(data)>0:\n   out_file.write(binascii.b2a_uu(data,backtick=backtick))\n   data=in_file.read(45)\n  if backtick:\n   out_file.write(b'`\\nend\\n')\n  else :\n   out_file.write(b' \\nend\\n')\n finally :\n  for f in opened_files:\n   f.close()\n   \n   \ndef decode(in_file,out_file=None ,mode=None ,quiet=False ):\n ''\n \n \n \n opened_files=[]\n if in_file =='-':\n  in_file=sys.stdin.buffer\n elif isinstance(in_file,str):\n  in_file=open(in_file,'rb')\n  opened_files.append(in_file)\n  \n try :\n \n \n \n  while True :\n   hdr=in_file.readline()\n   if not hdr:\n    raise Error('No valid begin line found in input file')\n   if not hdr.startswith(b'begin'):\n    continue\n   hdrfields=hdr.split(b' ',2)\n   if len(hdrfields)==3 and hdrfields[0]==b'begin':\n    try :\n     int(hdrfields[1],8)\n     break\n    except ValueError:\n     pass\n  if out_file is None :\n  \n   out_file=hdrfields[2].rstrip(b' \\t\\r\\n\\f').decode(\"ascii\")\n   if os.path.exists(out_file):\n    raise Error('Cannot overwrite existing file: %s'%out_file)\n  if mode is None :\n   mode=int(hdrfields[1],8)\n   \n   \n   \n  if out_file =='-':\n   out_file=sys.stdout.buffer\n  elif isinstance(out_file,str):\n   fp=open(out_file,'wb')\n   os.chmod(out_file,mode)\n   out_file=fp\n   opened_files.append(out_file)\n   \n   \n   \n  s=in_file.readline()\n  while s and s.strip(b' \\t\\r\\n\\f')!=b'end':\n   try :\n    data=binascii.a2b_uu(s)\n   except binascii.Error as v:\n   \n    nbytes=(((s[0]-32)&63)*4+5)//3\n    data=binascii.a2b_uu(s[:nbytes])\n    if not quiet:\n     sys.stderr.write(\"Warning: %s\\n\"%v)\n   out_file.write(data)\n   s=in_file.readline()\n  if not s:\n   raise Error('Truncated input file')\n finally :\n  for f in opened_files:\n   f.close()\n   \ndef test():\n ''\n \n import optparse\n parser=optparse.OptionParser(usage='usage: %prog [-d] [-t] [input [output]]')\n parser.add_option('-d','--decode',dest='decode',help='Decode (instead of encode)?',default=False ,action='store_true')\n parser.add_option('-t','--text',dest='text',help='data is text, encoded format unix-compatible text?',default=False ,action='store_true')\n \n (options,args)=parser.parse_args()\n if len(args)>2:\n  parser.error('incorrect number of arguments')\n  sys.exit(1)\n  \n  \n input=sys.stdin.buffer\n output=sys.stdout.buffer\n if len(args)>0:\n  input=args[0]\n if len(args)>1:\n  output=args[1]\n  \n if options.decode:\n  if options.text:\n   if isinstance(output,str):\n    output=open(output,'wb')\n   else :\n    print(sys.argv[0],': cannot do -t to stdout')\n    sys.exit(1)\n  decode(input,output)\n else :\n  if options.text:\n   if isinstance(input,str):\n    input=open(input,'rb')\n   else :\n    print(sys.argv[0],': cannot do -t from stdin')\n    sys.exit(1)\n  encode(input,output)\n  \nif __name__ =='__main__':\n test()\n", ["binascii", "optparse", "os", "sys"]], "webbrowser": [".py", "\n\nfrom browser import window\n\ndef open(url,new=0,autoraise=True ):\n window.open(url)\n \ndef open_new(url):\n return window.open(url,\"_blank\")\n \ndef open_new_tab(url):\n return open(url)\n \n", ["browser"]], "_codecs": [".py", "\ndef ascii_decode(*args,**kw):\n pass\n \ndef ascii_encode(*args,**kw):\n pass\n \ndef charbuffer_encode(*args,**kw):\n pass\n \ndef charmap_build(decoding_table):\n return {car:i for (i,car)in enumerate(decoding_table)}\n \ndef charmap_decode(input,errors,decoding_table):\n res=''\n for car in input:\n  code=decoding_table[car]\n  if code is None :\n   raise UnicodeDecodeError(input)\n  res +=code\n return res,len(input)\n \ndef charmap_encode(input,errors,encoding_table):\n t=[]\n for car in input:\n  code=encoding_table.get(car)\n  if code is None :\n   raise UnicodeEncodeError(input)\n  t.append(code)\n return bytes(t),len(input)\n \ndef decode(obj,encoding=\"utf-8\",errors=\"strict\"):\n ''\n\n\n\n\n\n \n return __BRYTHON__.decode(obj,encoding,errors)\n \ndef encode(obj,encoding=\"utf-8\",errors=\"strict\"):\n ''\n\n\n\n\n\n \n return __BRYTHON__.encode(obj,encoding,errors)\n \ndef escape_decode(*args,**kw):\n pass\n \ndef escape_encode(*args,**kw):\n pass\n \ndef latin_1_decode(*args,**kw):\n pass\n \ndef latin_1_encode(*args,**kw):\n pass\n \ndef lookup(encoding):\n ''\n\n \n if encoding in ('utf-8','utf_8'):\n  from browser import console\n  import encodings.utf_8\n  return encodings.utf_8.getregentry()\n  \n LookupError(encoding)\n \ndef lookup_error(*args,**kw):\n ''\n\n \n pass\n \ndef mbcs_decode(*args,**kw):\n pass\n \ndef mbcs_encode(*args,**kw):\n pass\n \ndef raw_unicode_escape_decode(*args,**kw):\n pass\n \ndef raw_unicode_escape_encode(*args,**kw):\n pass\n \ndef readbuffer_encode(*args,**kw):\n pass\n \ndef register(*args,**kw):\n ''\n\n\n\n \n pass\n \ndef register_error(*args,**kw):\n ''\n\n\n\n\n \n pass\n \ndef unicode_escape_decode(*args,**kw):\n pass\n \ndef unicode_escape_encode(*args,**kw):\n pass\n \ndef unicode_internal_decode(*args,**kw):\n pass\n \ndef unicode_internal_encode(*args,**kw):\n pass\n \ndef utf_16_be_decode(*args,**kw):\n pass\n \ndef utf_16_be_encode(*args,**kw):\n pass\n \ndef utf_16_decode(*args,**kw):\n pass\n \ndef utf_16_encode(*args,**kw):\n pass\n \ndef utf_16_ex_decode(*args,**kw):\n pass\n \ndef utf_16_le_decode(*args,**kw):\n pass\n \ndef utf_16_le_encode(*args,**kw):\n pass\n \ndef utf_32_be_decode(*args,**kw):\n pass\n \ndef utf_32_be_encode(*args,**kw):\n pass\n \ndef utf_32_decode(*args,**kw):\n pass\n \ndef utf_32_encode(*args,**kw):\n pass\n \ndef utf_32_ex_decode(*args,**kw):\n pass\n \ndef utf_32_le_decode(*args,**kw):\n pass\n \ndef utf_32_le_encode(*args,**kw):\n pass\n \ndef utf_7_decode(*args,**kw):\n pass\n \ndef utf_7_encode(*args,**kw):\n pass\n \ndef utf_8_decode(decoder,bytes_obj,errors,*args):\n return (bytes_obj.decode(\"utf-8\"),len(bytes_obj))\n \ndef utf_8_encode(*args,**kw):\n input=args[0]\n if len(args)==2:\n  errors=args[1]\n else :\n  errors=kw.get('errors','strict')\n  \n  \n return (bytes(input,'utf-8'),len(input))\n", ["browser", "encodings.utf_8"]], "genericpath": [".py", "''\n\n\n\n\nimport os\nimport stat\n\n__all__=['commonprefix','exists','getatime','getctime','getmtime',\n'getsize','isdir','isfile','samefile','sameopenfile',\n'samestat']\n\n\n\n\ndef exists(path):\n ''\n try :\n  os.stat(path)\n except (OSError,ValueError):\n  return False\n return True\n \n \n \n \ndef isfile(path):\n ''\n try :\n  st=os.stat(path)\n except (OSError,ValueError):\n  return False\n return stat.S_ISREG(st.st_mode)\n \n \n \n \n \ndef isdir(s):\n ''\n try :\n  st=os.stat(s)\n except (OSError,ValueError):\n  return False\n return stat.S_ISDIR(st.st_mode)\n \n \ndef getsize(filename):\n ''\n return os.stat(filename).st_size\n \n \ndef getmtime(filename):\n ''\n return os.stat(filename).st_mtime\n \n \ndef getatime(filename):\n ''\n return os.stat(filename).st_atime\n \n \ndef getctime(filename):\n ''\n return os.stat(filename).st_ctime\n \n \n \ndef commonprefix(m):\n ''\n if not m:return ''\n \n \n \n \n if not isinstance(m[0],(list,tuple)):\n  m=tuple(map(os.fspath,m))\n s1=min(m)\n s2=max(m)\n for i,c in enumerate(s1):\n  if c !=s2[i]:\n   return s1[:i]\n return s1\n \n \n \ndef samestat(s1,s2):\n ''\n return (s1.st_ino ==s2.st_ino and\n s1.st_dev ==s2.st_dev)\n \n \n \ndef samefile(f1,f2):\n ''\n\n\n\n \n s1=os.stat(f1)\n s2=os.stat(f2)\n return samestat(s1,s2)\n \n \n \n \ndef sameopenfile(fp1,fp2):\n ''\n s1=os.fstat(fp1)\n s2=os.fstat(fp2)\n return samestat(s1,s2)\n \n \n \n \n \n \n \n \n \ndef _splitext(p,sep,altsep,extsep):\n ''\n\n\n \n \n \n sepIndex=p.rfind(sep)\n if altsep:\n  altsepIndex=p.rfind(altsep)\n  sepIndex=max(sepIndex,altsepIndex)\n  \n dotIndex=p.rfind(extsep)\n if dotIndex >sepIndex:\n \n  filenameIndex=sepIndex+1\n  while filenameIndex <dotIndex:\n   if p[filenameIndex:filenameIndex+1]!=extsep:\n    return p[:dotIndex],p[dotIndex:]\n   filenameIndex +=1\n   \n return p,p[:0]\n \ndef _check_arg_types(funcname,*args):\n hasstr=hasbytes=False\n for s in args:\n  if isinstance(s,str):\n   hasstr=True\n  elif isinstance(s,bytes):\n   hasbytes=True\n  else :\n   raise TypeError('%s() argument must be str or bytes, not %r'%\n   (funcname,s.__class__.__name__))from None\n if hasstr and hasbytes:\n  raise TypeError(\"Can't mix strings and bytes in path components\")from None\n", ["os", "stat"]], "tb": [".py", "import sys\nfrom browser import console\n\nclass Trace:\n\n def __init__(self):\n  self.buf=\"\"\n  \n def write(self,*data):\n  self.buf +=\" \".join([str(x)for x in data])\n  \n def format(self):\n  ''\n  return self.buf\n  \ndef format_exc():\n trace=Trace()\n exc_info=sys.exc_info()\n exc_class=exc_info[0].__name__\n exc_msg=str(exc_info[1])\n tb=exc_info[2].tb_next\n if exc_info[0]is SyntaxError:\n  return syntax_error(exc_info[1].args)\n trace.write(\"Traceback (most recent call last):\\n\")\n while tb is not None :\n  frame=tb.tb_frame\n  code=frame.f_code\n  name=code.co_name\n  filename=code.co_filename\n  trace.write(f\"  File {filename}, line {tb.tb_lineno}, in {name}\\n\")\n  if not filename.startswith(\"<\"):\n   trace.write(f\"    {tb.tb_lasti}\\n\")\n  tb=tb.tb_next\n trace.write(f\"{exc_class}: {exc_msg}\\n\")\n return trace.format()\n \ndef print_exc(file=None ):\n if file is None :\n  file=sys.stderr\n file.write(format_exc())\n \ndef syntax_error(args):\n trace=Trace()\n info,filename,lineno,offset,line=args\n trace.write(f\"  File {filename}, line {lineno}\\n\")\n trace.write(\"    \"+line+\"\\n\")\n trace.write(\"    \"+offset *\" \"+\"^\\n\")\n trace.write(\"SyntaxError:\",info,\"\\n\")\n return trace.buf\n", ["browser", "sys"]], "_io": [".py", "''\n\n\n\nimport os\nimport abc\nimport codecs\nimport errno\n\ntry :\n from _thread import allocate_lock as Lock\nexcept ImportError:\n from _dummy_thread import allocate_lock as Lock\n \n \nfrom _io_classes import *\nimport _io_classes\n_IOBase=_io_classes._IOBase\n_RawIOBase=_io_classes._RawIOBase\n_BufferedIOBase=_io_classes._BufferedIOBase\n_TextIOBase=_io_classes._TextIOBase\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\nvalid_seek_flags={0,1,2}\nif hasattr(os,'SEEK_HOLE'):\n valid_seek_flags.add(os.SEEK_HOLE)\n valid_seek_flags.add(os.SEEK_DATA)\n \n \nDEFAULT_BUFFER_SIZE=8 *1024\n\n\n\n\n\n\nBlockingIOError=BlockingIOError\n\n\ndef __open(file,mode=\"r\",buffering=-1,encoding=None ,errors=None ,\nnewline=None ,closefd=True ,opener=None ):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not isinstance(file,(str,bytes,int)):\n  raise TypeError(\"invalid file: %r\"%file)\n if not isinstance(mode,str):\n  raise TypeError(\"invalid mode: %r\"%mode)\n if not isinstance(buffering,int):\n  raise TypeError(\"invalid buffering: %r\"%buffering)\n if encoding is not None and not isinstance(encoding,str):\n  raise TypeError(\"invalid encoding: %r\"%encoding)\n if errors is not None and not isinstance(errors,str):\n  raise TypeError(\"invalid errors: %r\"%errors)\n modes=set(mode)\n if modes -set(\"axrwb+tU\")or len(mode)>len(modes):\n  raise ValueError(\"invalid mode: %r\"%mode)\n creating=\"x\"in modes\n reading=\"r\"in modes\n writing=\"w\"in modes\n appending=\"a\"in modes\n updating=\"+\"in modes\n text=\"t\"in modes\n binary=\"b\"in modes\n if \"U\"in modes:\n  if creating or writing or appending:\n   raise ValueError(\"can't use U and writing mode at once\")\n  reading=True\n if text and binary:\n  raise ValueError(\"can't have text and binary mode at once\")\n if creating+reading+writing+appending >1:\n  raise ValueError(\"can't have read/write/append mode at once\")\n if not (creating or reading or writing or appending):\n  raise ValueError(\"must have exactly one of read/write/append mode\")\n if binary and encoding is not None :\n  raise ValueError(\"binary mode doesn't take an encoding argument\")\n if binary and errors is not None :\n  raise ValueError(\"binary mode doesn't take an errors argument\")\n if binary and newline is not None :\n  raise ValueError(\"binary mode doesn't take a newline argument\")\n raw=FileIO(file,\n (creating and \"x\"or \"\")+\n (reading and \"r\"or \"\")+\n (writing and \"w\"or \"\")+\n (appending and \"a\"or \"\")+\n (updating and \"+\"or \"\"),\n closefd,opener=opener)\n line_buffering=False\n if buffering ==1 or buffering <0 and raw.isatty():\n  buffering=-1\n  line_buffering=True\n if buffering <0:\n  buffering=DEFAULT_BUFFER_SIZE\n  try :\n   bs=os.fstat(raw.fileno()).st_blksize\n  except (os.error,AttributeError):\n   pass\n  else :\n   if bs >1:\n    buffering=bs\n if buffering <0:\n  raise ValueError(\"invalid buffering size\")\n if buffering ==0:\n  if binary:\n   return raw\n  raise ValueError(\"can't have unbuffered text I/O\")\n if updating:\n  buffer=BufferedRandom(raw,buffering)\n elif creating or writing or appending:\n  buffer=BufferedWriter(raw,buffering)\n elif reading:\n  buffer=BufferedReader(raw,buffering)\n else :\n  raise ValueError(\"unknown mode: %r\"%mode)\n if binary:\n  return buffer\n text=TextIOWrapper(buffer,encoding,errors,newline,line_buffering)\n text.mode=mode\n return text\n \nopen=__open\n\ndef open_code(file):\n return __builtins__.open(file,encoding=\"utf-8\")\n \nclass DocDescriptor:\n ''\n \n def __get__(self,obj,typ):\n  return (\n  \"open(file, mode='r', buffering=-1, encoding=None, \"\n  \"errors=None, newline=None, closefd=True)\\n\\n\"+\n  open.__doc__)\n  \nclass OpenWrapper:\n ''\n\n\n\n\n\n \n __doc__=DocDescriptor()\n \n def __new__(cls,*args,**kwargs):\n  return open(*args,**kwargs)\n  \n  \n  \n  \nclass UnsupportedOperation(ValueError,IOError):\n pass\n \n", ["_dummy_thread", "_io_classes", "_thread", "abc", "codecs", "errno", "os"]], "binascii": [".py", "''\n\n\n\n\n\n\n\nimport _base64\n\nfrom _binascii import *\n\nclass Error(ValueError):\n def __init__(self,msg=''):\n  self._msg=msg\n  \n def __str__(self):\n  return \" binascii.Error: \"+self._msg\n  \n  \nclass Done(Exception):\n pass\n \nclass Incomplete(Error):\n pass\n \ndef a2b_uu(s):\n if not s:\n  return ''\n  \n length=(ord(s[0])-0x20)%64\n \n def quadruplets_gen(s):\n  while s:\n   try :\n    yield ord(s[0]),ord(s[1]),ord(s[2]),ord(s[3])\n   except IndexError:\n    s +='   '\n    yield ord(s[0]),ord(s[1]),ord(s[2]),ord(s[3])\n    return\n   s=s[4:]\n   \n try :\n  result=[''.join(\n  [chr((A -0x20)<<2 |(((B -0x20)>>4)&0x3)),\n  chr(((B -0x20)&0xf)<<4 |(((C -0x20)>>2)&0xf)),\n  chr(((C -0x20)&0x3)<<6 |((D -0x20)&0x3f))\n  ])for A,B,C,D in quadruplets_gen(s[1:].rstrip())]\n except ValueError:\n  raise Error('Illegal char')\n result=''.join(result)\n trailingdata=result[length:]\n if trailingdata.strip('\\x00'):\n  raise Error('Trailing garbage')\n result=result[:length]\n if len(result)<length:\n  result +=((length -len(result))*'\\x00')\n return bytes(result,__BRYTHON__.charset)\n \n \ntable_a2b_base64={\n'A':0,\n'B':1,\n'C':2,\n'D':3,\n'E':4,\n'F':5,\n'G':6,\n'H':7,\n'I':8,\n'J':9,\n'K':10,\n'L':11,\n'M':12,\n'N':13,\n'O':14,\n'P':15,\n'Q':16,\n'R':17,\n'S':18,\n'T':19,\n'U':20,\n'V':21,\n'W':22,\n'X':23,\n'Y':24,\n'Z':25,\n'a':26,\n'b':27,\n'c':28,\n'd':29,\n'e':30,\n'f':31,\n'g':32,\n'h':33,\n'i':34,\n'j':35,\n'k':36,\n'l':37,\n'm':38,\n'n':39,\n'o':40,\n'p':41,\n'q':42,\n'r':43,\n's':44,\n't':45,\n'u':46,\n'v':47,\n'w':48,\n'x':49,\n'y':50,\n'z':51,\n'0':52,\n'1':53,\n'2':54,\n'3':55,\n'4':56,\n'5':57,\n'6':58,\n'7':59,\n'8':60,\n'9':61,\n'+':62,\n'/':63,\n'=':0,\n}\n\n\ndef XXXa2b_base64(s):\n return _base64.Base64.decode(s)\n \ntable_b2a_base64=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\\n\"0123456789+/\"\n\ndef XXXb2a_base64(s,newline=True ):\n length=len(s)\n final_length=length %3\n \n def triples_gen(s):\n  while s:\n   try :\n    yield s[0],s[1],s[2]\n   except IndexError:\n    s +=b'\\0\\0'\n    yield s[0],s[1],s[2]\n    return\n   s=s[3:]\n   \n a=triples_gen(s[:length -final_length])\n \n result=[''.join(\n [table_b2a_base64[(A >>2)&0x3F],\n table_b2a_base64[((A <<4)|((B >>4)&0xF))&0x3F],\n table_b2a_base64[((B <<2)|((C >>6)&0x3))&0x3F],\n table_b2a_base64[(C)&0x3F]])\n for A,B,C in a]\n \n final=s[length -final_length:]\n if final_length ==0:\n  snippet=''\n elif final_length ==1:\n  a=final[0]\n  snippet=table_b2a_base64[(a >>2)&0x3F]+\\\n  table_b2a_base64[(a <<4)&0x3F]+'=='\n else :\n  a=final[0]\n  b=final[1]\n  snippet=table_b2a_base64[(a >>2)&0x3F]+\\\n  table_b2a_base64[((a <<4)|(b >>4)&0xF)&0x3F]+\\\n  table_b2a_base64[(b <<2)&0x3F]+'='\n  \n result=''.join(result)+snippet\n if newline:\n  result +='\\n'\n return bytes(result,__BRYTHON__.charset)\n \ndef a2b_qp(s,header=False ):\n inp=0\n odata=[]\n while inp <len(s):\n  if s[inp]=='=':\n   inp +=1\n   if inp >=len(s):\n    break\n    \n   if (s[inp]=='\\n')or (s[inp]=='\\r'):\n    if s[inp]!='\\n':\n     while inp <len(s)and s[inp]!='\\n':\n      inp +=1\n    if inp <len(s):\n     inp +=1\n   elif s[inp]=='=':\n   \n    odata.append('=')\n    inp +=1\n   elif s[inp]in hex_numbers and s[inp+1]in hex_numbers:\n    ch=chr(int(s[inp:inp+2],16))\n    inp +=2\n    odata.append(ch)\n   else :\n    odata.append('=')\n  elif header and s[inp]=='_':\n   odata.append(' ')\n   inp +=1\n  else :\n   odata.append(s[inp])\n   inp +=1\n return bytes(''.join(odata),__BRYTHON__.charset)\n \ndef b2a_qp(data,quotetabs=False ,istext=True ,header=False ):\n ''\n\n\n\n\n \n MAXLINESIZE=76\n \n \n lf=data.find('\\n')\n crlf=lf >0 and data[lf -1]=='\\r'\n \n inp=0\n linelen=0\n odata=[]\n while inp <len(data):\n  c=data[inp]\n  if (c >'~'or\n  c =='='or\n  (header and c =='_')or\n  (c =='.'and linelen ==0 and (inp+1 ==len(data)or\n  data[inp+1]=='\\n'or\n  data[inp+1]=='\\r'))or\n  (not istext and (c =='\\r'or c =='\\n'))or\n  ((c =='\\t'or c ==' ')and (inp+1 ==len(data)))or\n  (c <=' 'and c !='\\r'and c !='\\n'and\n  (quotetabs or (not quotetabs and (c !='\\t'and c !=' '))))):\n   linelen +=3\n   if linelen >=MAXLINESIZE:\n    odata.append('=')\n    if crlf:odata.append('\\r')\n    odata.append('\\n')\n    linelen=3\n   odata.append('='+two_hex_digits(ord(c)))\n   inp +=1\n  else :\n   if (istext and\n   (c =='\\n'or (inp+1 <len(data)and c =='\\r'and\n   data[inp+1]=='\\n'))):\n    linelen=0\n    \n    if (len(odata)>0 and\n    (odata[-1]==' 'or odata[-1]=='\\t')):\n     ch=ord(odata[-1])\n     odata[-1]='='\n     odata.append(two_hex_digits(ch))\n     \n    if crlf:odata.append('\\r')\n    odata.append('\\n')\n    if c =='\\r':\n     inp +=2\n    else :\n     inp +=1\n   else :\n    if (inp+1 <len(data)and\n    data[inp+1]!='\\n'and\n    (linelen+1)>=MAXLINESIZE):\n     odata.append('=')\n     if crlf:odata.append('\\r')\n     odata.append('\\n')\n     linelen=0\n     \n    linelen +=1\n    if header and c ==' ':\n     c='_'\n    odata.append(c)\n    inp +=1\n return ''.join(odata)\n \nhex_numbers='0123456789ABCDEF'\ndef hex(n):\n if n ==0:\n  return '0'\n  \n if n <0:\n  n=-n\n  sign='-'\n else :\n  sign=''\n arr=[]\n \n def hex_gen(n):\n  ''\n  while n:\n   yield n %0x10\n   n=n /0x10\n   \n for nibble in hex_gen(n):\n  arr=[hex_numbers[nibble]]+arr\n return sign+''.join(arr)\n \ndef two_hex_digits(n):\n return hex_numbers[n /0x10]+hex_numbers[n %0x10]\n \n \ndef strhex_to_int(s):\n i=0\n for c in s:\n  i=i *0x10+hex_numbers.index(c)\n return i\n \nhqx_encoding='!\"#$%&\\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr'\n\nDONE=0x7f\nSKIP=0x7e\nFAIL=0x7d\n\ntable_a2b_hqx=[\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,SKIP,FAIL,FAIL,SKIP,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,0x00,0x01,0x02,0x03,0x04,0x05,0x06,\n\n0x07,0x08,0x09,0x0A,0x0B,0x0C,FAIL,FAIL,\n\n0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,FAIL,\n\n0x14,0x15,DONE,FAIL,FAIL,FAIL,FAIL,FAIL,\n\n0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,\n\n0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,FAIL,\n\n0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,FAIL,\n\n0x2C,0x2D,0x2E,0x2F,FAIL,FAIL,FAIL,FAIL,\n\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,FAIL,\n\n0x37,0x38,0x39,0x3A,0x3B,0x3C,FAIL,FAIL,\n\n0x3D,0x3E,0x3F,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n]\n\ndef a2b_hqx(s):\n result=[]\n \n def quadruples_gen(s):\n  t=[]\n  for c in s:\n   res=table_a2b_hqx[ord(c)]\n   if res ==SKIP:\n    continue\n   elif res ==FAIL:\n    raise Error('Illegal character')\n   elif res ==DONE:\n    yield t\n    raise Done\n   else :\n    t.append(res)\n   if len(t)==4:\n    yield t\n    t=[]\n  yield t\n  \n done=0\n try :\n  for snippet in quadruples_gen(s):\n   length=len(snippet)\n   if length ==4:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n    result.append(chr(((snippet[1]&0x0f)<<4)|(snippet[2]>>2)))\n    result.append(chr(((snippet[2]&0x03)<<6)|(snippet[3])))\n   elif length ==3:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n    result.append(chr(((snippet[1]&0x0f)<<4)|(snippet[2]>>2)))\n   elif length ==2:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n except Done:\n  done=1\n except Error:\n  raise\n return (''.join(result),done)\n \n \n \ndef b2a_hqx(s):\n result=[]\n \n def triples_gen(s):\n  while s:\n   try :\n    yield ord(s[0]),ord(s[1]),ord(s[2])\n   except IndexError:\n    yield tuple([ord(c)for c in s])\n   s=s[3:]\n   \n for snippet in triples_gen(s):\n  length=len(snippet)\n  if length ==3:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)|((snippet[1]&0xf0)>>4)])\n   result.append(hqx_encoding[\n   (snippet[1]&0x0f)<<2 |((snippet[2]&0xc0)>>6)])\n   result.append(hqx_encoding[snippet[2]&0x3f])\n  elif length ==2:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)|((snippet[1]&0xf0)>>4)])\n   result.append(hqx_encoding[\n   (snippet[1]&0x0f)<<2])\n  elif length ==1:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)])\n return ''.join(result)\n \ncrctab_hqx=[\n0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0,\n]\n\ndef crc_hqx(s,crc):\n for c in s:\n  crc=((crc <<8)&0xff00)^crctab_hqx[((crc >>8)&0xff)^ord(c)]\n  \n return crc\n \ndef rlecode_hqx(s):\n ''\n\n\n\n \n if not s:\n  return ''\n result=[]\n prev=s[0]\n count=1\n \n \n \n \n if s[-1]=='!':\n  s=s[1:]+'?'\n else :\n  s=s[1:]+'!'\n  \n for c in s:\n  if c ==prev and count <255:\n   count +=1\n  else :\n   if count ==1:\n    if prev !='\\x90':\n     result.append(prev)\n    else :\n     result.extend(['\\x90','\\x00'])\n   elif count <4:\n    if prev !='\\x90':\n     result.extend([prev]*count)\n    else :\n     result.extend(['\\x90','\\x00']*count)\n   else :\n    if prev !='\\x90':\n     result.extend([prev,'\\x90',chr(count)])\n    else :\n     result.extend(['\\x90','\\x00','\\x90',chr(count)])\n   count=1\n   prev=c\n   \n return ''.join(result)\n \ndef rledecode_hqx(s):\n s=s.split('\\x90')\n result=[s[0]]\n prev=s[0]\n for snippet in s[1:]:\n  count=ord(snippet[0])\n  if count >0:\n   result.append(prev[-1]*(count -1))\n   prev=snippet\n  else :\n   result.append('\\x90')\n   prev='\\x90'\n  result.append(snippet[1:])\n  \n return ''.join(result)\n \ncrc_32_tab=[\n0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,\n0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,\n0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,\n0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,\n0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,\n0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,\n0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,\n0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,\n0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,\n0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,\n0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,\n0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,\n0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,\n0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,\n0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,\n0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,\n0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,\n0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,\n0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,\n0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,\n0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,\n0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,\n0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,\n0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,\n0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,\n0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,\n0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,\n0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,\n0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,\n0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,\n0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,\n0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,\n0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,\n0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,\n0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,\n0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,\n0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,\n0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,\n0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,\n0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,\n0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,\n0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,\n0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,\n0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,\n0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,\n0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,\n0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,\n0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,\n0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,\n0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,\n0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,\n0x2d02ef8d\n]\n\ndef crc32(s,crc=0):\n result=0\n crc=~int(crc)&0xffffffff\n \n for c in s:\n  crc=crc_32_tab[(crc ^int(ord(c)))&0xff]^(crc >>8)\n  \n  \n  \n result=crc ^0xffffffff\n \n if result >2 **31:\n  result=((result+2 **31)%2 **32)-2 **31\n  \n return result\n", ["_base64", "_binascii"]], "stat": [".py", "''\n\n\n\n\n\n\nST_MODE=0\nST_INO=1\nST_DEV=2\nST_NLINK=3\nST_UID=4\nST_GID=5\nST_SIZE=6\nST_ATIME=7\nST_MTIME=8\nST_CTIME=9\n\n\n\ndef S_IMODE(mode):\n ''\n\n \n return mode&0o7777\n \ndef S_IFMT(mode):\n ''\n\n \n return mode&0o170000\n \n \n \n \nS_IFDIR=0o040000\nS_IFCHR=0o020000\nS_IFBLK=0o060000\nS_IFREG=0o100000\nS_IFIFO=0o010000\nS_IFLNK=0o120000\nS_IFSOCK=0o140000\n\n\n\ndef S_ISDIR(mode):\n ''\n return S_IFMT(mode)==S_IFDIR\n \ndef S_ISCHR(mode):\n ''\n return S_IFMT(mode)==S_IFCHR\n \ndef S_ISBLK(mode):\n ''\n return S_IFMT(mode)==S_IFBLK\n \ndef S_ISREG(mode):\n ''\n return S_IFMT(mode)==S_IFREG\n \ndef S_ISFIFO(mode):\n ''\n return S_IFMT(mode)==S_IFIFO\n \ndef S_ISLNK(mode):\n ''\n return S_IFMT(mode)==S_IFLNK\n \ndef S_ISSOCK(mode):\n ''\n return S_IFMT(mode)==S_IFSOCK\n \n \n \nS_ISUID=0o4000\nS_ISGID=0o2000\nS_ENFMT=S_ISGID\nS_ISVTX=0o1000\nS_IREAD=0o0400\nS_IWRITE=0o0200\nS_IEXEC=0o0100\nS_IRWXU=0o0700\nS_IRUSR=0o0400\nS_IWUSR=0o0200\nS_IXUSR=0o0100\nS_IRWXG=0o0070\nS_IRGRP=0o0040\nS_IWGRP=0o0020\nS_IXGRP=0o0010\nS_IRWXO=0o0007\nS_IROTH=0o0004\nS_IWOTH=0o0002\nS_IXOTH=0o0001\n\n\n\nUF_NODUMP=0x00000001\nUF_IMMUTABLE=0x00000002\nUF_APPEND=0x00000004\nUF_OPAQUE=0x00000008\nUF_NOUNLINK=0x00000010\nUF_COMPRESSED=0x00000020\nUF_HIDDEN=0x00008000\nSF_ARCHIVED=0x00010000\nSF_IMMUTABLE=0x00020000\nSF_APPEND=0x00040000\nSF_NOUNLINK=0x00100000\nSF_SNAPSHOT=0x00200000\n\n\n_filemode_table=(\n((S_IFLNK,\"l\"),\n(S_IFSOCK,\"s\"),\n(S_IFREG,\"-\"),\n(S_IFBLK,\"b\"),\n(S_IFDIR,\"d\"),\n(S_IFCHR,\"c\"),\n(S_IFIFO,\"p\")),\n\n((S_IRUSR,\"r\"),),\n((S_IWUSR,\"w\"),),\n((S_IXUSR |S_ISUID,\"s\"),\n(S_ISUID,\"S\"),\n(S_IXUSR,\"x\")),\n\n((S_IRGRP,\"r\"),),\n((S_IWGRP,\"w\"),),\n((S_IXGRP |S_ISGID,\"s\"),\n(S_ISGID,\"S\"),\n(S_IXGRP,\"x\")),\n\n((S_IROTH,\"r\"),),\n((S_IWOTH,\"w\"),),\n((S_IXOTH |S_ISVTX,\"t\"),\n(S_ISVTX,\"T\"),\n(S_IXOTH,\"x\"))\n)\n\ndef filemode(mode):\n ''\n perm=[]\n for table in _filemode_table:\n  for bit,char in table:\n   if mode&bit ==bit:\n    perm.append(char)\n    break\n  else :\n   perm.append(\"-\")\n return \"\".join(perm)\n \n \n \n \n \nFILE_ATTRIBUTE_ARCHIVE=32\nFILE_ATTRIBUTE_COMPRESSED=2048\nFILE_ATTRIBUTE_DEVICE=64\nFILE_ATTRIBUTE_DIRECTORY=16\nFILE_ATTRIBUTE_ENCRYPTED=16384\nFILE_ATTRIBUTE_HIDDEN=2\nFILE_ATTRIBUTE_INTEGRITY_STREAM=32768\nFILE_ATTRIBUTE_NORMAL=128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED=8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA=131072\nFILE_ATTRIBUTE_OFFLINE=4096\nFILE_ATTRIBUTE_READONLY=1\nFILE_ATTRIBUTE_REPARSE_POINT=1024\nFILE_ATTRIBUTE_SPARSE_FILE=512\nFILE_ATTRIBUTE_SYSTEM=4\nFILE_ATTRIBUTE_TEMPORARY=256\nFILE_ATTRIBUTE_VIRTUAL=65536\n\n\n\ntry :\n from _stat import *\nexcept ImportError:\n pass\n", ["_stat"]], "_compat_pickle": [".py", "\n\n\n\n\n\n\nIMPORT_MAPPING={\n'__builtin__':'builtins',\n'copy_reg':'copyreg',\n'Queue':'queue',\n'SocketServer':'socketserver',\n'ConfigParser':'configparser',\n'repr':'reprlib',\n'tkFileDialog':'tkinter.filedialog',\n'tkSimpleDialog':'tkinter.simpledialog',\n'tkColorChooser':'tkinter.colorchooser',\n'tkCommonDialog':'tkinter.commondialog',\n'Dialog':'tkinter.dialog',\n'Tkdnd':'tkinter.dnd',\n'tkFont':'tkinter.font',\n'tkMessageBox':'tkinter.messagebox',\n'ScrolledText':'tkinter.scrolledtext',\n'Tkconstants':'tkinter.constants',\n'Tix':'tkinter.tix',\n'ttk':'tkinter.ttk',\n'Tkinter':'tkinter',\n'markupbase':'_markupbase',\n'_winreg':'winreg',\n'thread':'_thread',\n'dummy_thread':'_dummy_thread',\n'dbhash':'dbm.bsd',\n'dumbdbm':'dbm.dumb',\n'dbm':'dbm.ndbm',\n'gdbm':'dbm.gnu',\n'xmlrpclib':'xmlrpc.client',\n'SimpleXMLRPCServer':'xmlrpc.server',\n'httplib':'http.client',\n'htmlentitydefs':'html.entities',\n'HTMLParser':'html.parser',\n'Cookie':'http.cookies',\n'cookielib':'http.cookiejar',\n'BaseHTTPServer':'http.server',\n'test.test_support':'test.support',\n'commands':'subprocess',\n'urlparse':'urllib.parse',\n'robotparser':'urllib.robotparser',\n'urllib2':'urllib.request',\n'anydbm':'dbm',\n'_abcoll':'collections.abc',\n}\n\n\n\n\n\nNAME_MAPPING={\n('__builtin__','xrange'):('builtins','range'),\n('__builtin__','reduce'):('functools','reduce'),\n('__builtin__','intern'):('sys','intern'),\n('__builtin__','unichr'):('builtins','chr'),\n('__builtin__','unicode'):('builtins','str'),\n('__builtin__','long'):('builtins','int'),\n('itertools','izip'):('builtins','zip'),\n('itertools','imap'):('builtins','map'),\n('itertools','ifilter'):('builtins','filter'),\n('itertools','ifilterfalse'):('itertools','filterfalse'),\n('itertools','izip_longest'):('itertools','zip_longest'),\n('UserDict','IterableUserDict'):('collections','UserDict'),\n('UserList','UserList'):('collections','UserList'),\n('UserString','UserString'):('collections','UserString'),\n('whichdb','whichdb'):('dbm','whichdb'),\n('_socket','fromfd'):('socket','fromfd'),\n('_multiprocessing','Connection'):('multiprocessing.connection','Connection'),\n('multiprocessing.process','Process'):('multiprocessing.context','Process'),\n('multiprocessing.forking','Popen'):('multiprocessing.popen_fork','Popen'),\n('urllib','ContentTooShortError'):('urllib.error','ContentTooShortError'),\n('urllib','getproxies'):('urllib.request','getproxies'),\n('urllib','pathname2url'):('urllib.request','pathname2url'),\n('urllib','quote_plus'):('urllib.parse','quote_plus'),\n('urllib','quote'):('urllib.parse','quote'),\n('urllib','unquote_plus'):('urllib.parse','unquote_plus'),\n('urllib','unquote'):('urllib.parse','unquote'),\n('urllib','url2pathname'):('urllib.request','url2pathname'),\n('urllib','urlcleanup'):('urllib.request','urlcleanup'),\n('urllib','urlencode'):('urllib.parse','urlencode'),\n('urllib','urlopen'):('urllib.request','urlopen'),\n('urllib','urlretrieve'):('urllib.request','urlretrieve'),\n('urllib2','HTTPError'):('urllib.error','HTTPError'),\n('urllib2','URLError'):('urllib.error','URLError'),\n}\n\nPYTHON2_EXCEPTIONS=(\n\"ArithmeticError\",\n\"AssertionError\",\n\"AttributeError\",\n\"BaseException\",\n\"BufferError\",\n\"BytesWarning\",\n\"DeprecationWarning\",\n\"EOFError\",\n\"EnvironmentError\",\n\"Exception\",\n\"FloatingPointError\",\n\"FutureWarning\",\n\"GeneratorExit\",\n\"IOError\",\n\"ImportError\",\n\"ImportWarning\",\n\"IndentationError\",\n\"IndexError\",\n\"KeyError\",\n\"KeyboardInterrupt\",\n\"LookupError\",\n\"MemoryError\",\n\"NameError\",\n\"NotImplementedError\",\n\"OSError\",\n\"OverflowError\",\n\"PendingDeprecationWarning\",\n\"ReferenceError\",\n\"RuntimeError\",\n\"RuntimeWarning\",\n\n\"StopIteration\",\n\"SyntaxError\",\n\"SyntaxWarning\",\n\"SystemError\",\n\"SystemExit\",\n\"TabError\",\n\"TypeError\",\n\"UnboundLocalError\",\n\"UnicodeDecodeError\",\n\"UnicodeEncodeError\",\n\"UnicodeError\",\n\"UnicodeTranslateError\",\n\"UnicodeWarning\",\n\"UserWarning\",\n\"ValueError\",\n\"Warning\",\n\"ZeroDivisionError\",\n)\n\ntry :\n WindowsError\nexcept NameError:\n pass\nelse :\n PYTHON2_EXCEPTIONS +=(\"WindowsError\",)\n \nfor excname in PYTHON2_EXCEPTIONS:\n NAME_MAPPING[(\"exceptions\",excname)]=(\"builtins\",excname)\n \nMULTIPROCESSING_EXCEPTIONS=(\n'AuthenticationError',\n'BufferTooShort',\n'ProcessError',\n'TimeoutError',\n)\n\nfor excname in MULTIPROCESSING_EXCEPTIONS:\n NAME_MAPPING[(\"multiprocessing\",excname)]=(\"multiprocessing.context\",excname)\n \n \nREVERSE_IMPORT_MAPPING=dict((v,k)for (k,v)in IMPORT_MAPPING.items())\nassert len(REVERSE_IMPORT_MAPPING)==len(IMPORT_MAPPING)\nREVERSE_NAME_MAPPING=dict((v,k)for (k,v)in NAME_MAPPING.items())\nassert len(REVERSE_NAME_MAPPING)==len(NAME_MAPPING)\n\n\n\nIMPORT_MAPPING.update({\n'cPickle':'pickle',\n'_elementtree':'xml.etree.ElementTree',\n'FileDialog':'tkinter.filedialog',\n'SimpleDialog':'tkinter.simpledialog',\n'DocXMLRPCServer':'xmlrpc.server',\n'SimpleHTTPServer':'http.server',\n'CGIHTTPServer':'http.server',\n\n'UserDict':'collections',\n'UserList':'collections',\n'UserString':'collections',\n'whichdb':'dbm',\n'StringIO':'io',\n'cStringIO':'io',\n})\n\nREVERSE_IMPORT_MAPPING.update({\n'_bz2':'bz2',\n'_dbm':'dbm',\n'_functools':'functools',\n'_gdbm':'gdbm',\n'_pickle':'pickle',\n})\n\nNAME_MAPPING.update({\n('__builtin__','basestring'):('builtins','str'),\n('exceptions','StandardError'):('builtins','Exception'),\n('UserDict','UserDict'):('collections','UserDict'),\n('socket','_socketobject'):('socket','SocketType'),\n})\n\nREVERSE_NAME_MAPPING.update({\n('_functools','reduce'):('__builtin__','reduce'),\n('tkinter.filedialog','FileDialog'):('FileDialog','FileDialog'),\n('tkinter.filedialog','LoadFileDialog'):('FileDialog','LoadFileDialog'),\n('tkinter.filedialog','SaveFileDialog'):('FileDialog','SaveFileDialog'),\n('tkinter.simpledialog','SimpleDialog'):('SimpleDialog','SimpleDialog'),\n('xmlrpc.server','ServerHTMLDoc'):('DocXMLRPCServer','ServerHTMLDoc'),\n('xmlrpc.server','XMLRPCDocGenerator'):\n('DocXMLRPCServer','XMLRPCDocGenerator'),\n('xmlrpc.server','DocXMLRPCRequestHandler'):\n('DocXMLRPCServer','DocXMLRPCRequestHandler'),\n('xmlrpc.server','DocXMLRPCServer'):\n('DocXMLRPCServer','DocXMLRPCServer'),\n('xmlrpc.server','DocCGIXMLRPCRequestHandler'):\n('DocXMLRPCServer','DocCGIXMLRPCRequestHandler'),\n('http.server','SimpleHTTPRequestHandler'):\n('SimpleHTTPServer','SimpleHTTPRequestHandler'),\n('http.server','CGIHTTPRequestHandler'):\n('CGIHTTPServer','CGIHTTPRequestHandler'),\n('_socket','socket'):('socket','_socketobject'),\n})\n\nPYTHON3_OSERROR_EXCEPTIONS=(\n'BrokenPipeError',\n'ChildProcessError',\n'ConnectionAbortedError',\n'ConnectionError',\n'ConnectionRefusedError',\n'ConnectionResetError',\n'FileExistsError',\n'FileNotFoundError',\n'InterruptedError',\n'IsADirectoryError',\n'NotADirectoryError',\n'PermissionError',\n'ProcessLookupError',\n'TimeoutError',\n)\n\nfor excname in PYTHON3_OSERROR_EXCEPTIONS:\n REVERSE_NAME_MAPPING[('builtins',excname)]=('exceptions','OSError')\n \nPYTHON3_IMPORTERROR_EXCEPTIONS=(\n'ModuleNotFoundError',\n)\n\nfor excname in PYTHON3_IMPORTERROR_EXCEPTIONS:\n REVERSE_NAME_MAPPING[('builtins',excname)]=('exceptions','ImportError')\n", []], "struct": [".py", "__all__=[\n\n'calcsize','pack','pack_into','unpack','unpack_from',\n'iter_unpack',\n\n\n'Struct',\n\n\n'error'\n]\n\nfrom _struct import *\nfrom _struct import _clearcache\nfrom _struct import __doc__\n", ["_struct"]], "_sysconfigdata_0_brython_": [".py", "build_time_vars={}\n", []], "itertools": [".py", "import operator\n\nclass accumulate:\n def __init__(self,iterable,func=operator.add):\n  self.it=iter(iterable)\n  self._total=None\n  self.func=func\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self._total:\n   self._total=next(self.it)\n   return self._total\n  else :\n   element=next(self.it)\n   try :\n    self._total=self.func(self._total,element)\n   except :\n    raise TypeError(\"unsupported operand type\")\n   return self._total\n   \n   \n   \nclass chain:\n def __init__(self,*iterables):\n  self._iterables_iter=iter(map(iter,iterables))\n  \n  self._cur_iterable_iter=iter([])\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True :\n   try :\n    return next(self._cur_iterable_iter)\n   except StopIteration:\n    self._cur_iterable_iter=next(self._iterables_iter)\n    \n @classmethod\n def from_iterable(cls,iterable):\n  for it in iterable:\n   for element in it:\n    yield element\n    \nclass combinations:\n def __init__(self,iterable,r):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=r\n  self.indices=list(range(self.r))\n  self.zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.r >self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in self.indices)\n  else :\n   try :\n    for i in reversed(range(self.r)):\n     if self.indices[i]!=i+self.n -self.r:\n      break\n    self.indices[i]+=1\n    for j in range(i+1,self.r):\n     self.indices[j]=self.indices[j -1]+1\n    return tuple(self.pool[i]for i in self.indices)\n   except :\n    raise StopIteration\n    \nclass combinations_with_replacement:\n def __init__(self,iterable,r):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=r\n  self.indices=[0]*self.r\n  self.zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self.n and self.r:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in self.indices)\n  else :\n   try :\n    for i in reversed(range(self.r)):\n     if self.indices[i]!=self.n -1:\n      break\n    self.indices[i:]=[self.indices[i]+1]*(self.r -i)\n    return tuple(self.pool[i]for i in self.indices)\n   except :\n    raise StopIteration\n    \n    \n    \nclass compress:\n def __init__(self,data,selectors):\n  self.data=iter(data)\n  self.selectors=iter(selectors)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True :\n   next_item=next(self.data)\n   next_selector=next(self.selectors)\n   if bool(next_selector):\n    return next_item\n    \n    \n    \n    \nclass count:\n ''\n\n\n\n \n def __init__(self,start=0,step=1):\n  if not isinstance(start,(int,float)):\n   raise TypeError('a number is required')\n  self.times=start -step\n  self.step=step\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  self.times +=self.step\n  return self.times\n  \n def __repr__(self):\n  return 'count(%d)'%(self.times+self.step)\n  \n  \n  \nclass cycle:\n def __init__(self,iterable):\n  self._cur_iter=iter(iterable)\n  self._saved=[]\n  self._must_save=True\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  try :\n   next_elt=next(self._cur_iter)\n   if self._must_save:\n    self._saved.append(next_elt)\n  except StopIteration:\n   self._cur_iter=iter(self._saved)\n   next_elt=next(self._cur_iter)\n   self._must_save=False\n  return next_elt\n  \n  \n  \nclass dropwhile:\n def __init__(self,predicate,iterable):\n  self._predicate=predicate\n  self._iter=iter(iterable)\n  self._dropped=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self._iter)\n  if self._dropped:\n   return value\n  while self._predicate(value):\n   value=next(self._iter)\n  self._dropped=True\n  return value\n  \n  \n  \nclass filterfalse:\n def __init__(self,predicate,iterable):\n \n  self._iter=iter(iterable)\n  if predicate is None :\n   self._predicate=bool\n  else :\n   self._predicate=predicate\n   \n def __iter__(self):\n  return self\n def __next__(self):\n  next_elt=next(self._iter)\n  while True :\n   if not self._predicate(next_elt):\n    return next_elt\n   next_elt=next(self._iter)\n   \nclass groupby:\n\n\n def __init__(self,iterable,key=None ):\n  if key is None :\n   key=lambda x:x\n  self.keyfunc=key\n  self.it=iter(iterable)\n  self.tgtkey=self.currkey=self.currvalue=object()\n def __iter__(self):\n  return self\n def __next__(self):\n  while self.currkey ==self.tgtkey:\n   self.currvalue=next(self.it)\n   self.currkey=self.keyfunc(self.currvalue)\n  self.tgtkey=self.currkey\n  return (self.currkey,self._grouper(self.tgtkey))\n def _grouper(self,tgtkey):\n  while self.currkey ==tgtkey:\n   yield self.currvalue\n   self.currvalue=next(self.it)\n   self.currkey=self.keyfunc(self.currvalue)\n   \n   \n   \nclass islice:\n def __init__(self,iterable,*args):\n  s=slice(*args)\n  self.start,self.stop,self.step=s.start or 0,s.stop,s.step\n  if not isinstance(self.start,int):\n   raise ValueError(\"Start argument must be an integer\")\n  if self.stop !=None and not isinstance(self.stop,int):\n   raise ValueError(\"Stop argument must be an integer or None\")\n  if self.step is None :\n   self.step=1\n  if self.start <0 or (self.stop !=None and self.stop <0\n  )or self.step <=0:\n   raise ValueError(\"indices for islice() must be positive\")\n  self.it=iter(iterable)\n  self.donext=None\n  self.cnt=0\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  nextindex=self.start\n  if self.stop !=None and nextindex >=self.stop:\n   raise StopIteration\n  while self.cnt <=nextindex:\n   nextitem=next(self.it)\n   self.cnt +=1\n  self.start +=self.step\n  return nextitem\n  \nclass permutations:\n def __init__(self,iterable,r=None ):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=self.n if r is None else r\n  self.indices=list(range(self.n))\n  self.cycles=list(range(self.n,self.n -self.r,-1))\n  self.zero=False\n  self.stop=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  indices=self.indices\n  if self.r >self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in indices[:self.r])\n   \n  i=self.r -1\n  while i >=0:\n   j=self.cycles[i]-1\n   if j >0:\n    self.cycles[i]=j\n    indices[i],indices[-j]=indices[-j],indices[i]\n    return tuple(self.pool[i]for i in indices[:self.r])\n   self.cycles[i]=len(indices)-i\n   n1=len(indices)-1\n   assert n1 >=0\n   num=indices[i]\n   for k in range(i,n1):\n    indices[k]=indices[k+1]\n   indices[n1]=num\n   i -=1\n  raise StopIteration\n  \n  \ndef product(*args,repeat=1):\n\n\n pools=[tuple(pool)for pool in args]*repeat\n result=[[]]\n for pool in pools:\n  result=[x+[y]for x in result for y in pool]\n for prod in result:\n  yield tuple(prod)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _product:\n def __init__(self,*args,**kw):\n  if len(kw)>1:\n   raise TypeError(\"product() takes at most 1 argument (%d given)\"%\n   len(kw))\n  self.repeat=kw.get('repeat',1)\n  if not isinstance(self.repeat,int):\n   raise TypeError(\"integer argument expected, got %s\"%\n   type(self.repeat))\n  self.gears=[x for x in args]*self.repeat\n  self.num_gears=len(self.gears)\n  \n  self.indicies=[(0,len(self.gears[x]))\n  for x in range(0,self.num_gears)]\n  self.cont=True\n  self.zero=False\n  \n def roll_gears(self):\n \n \n \n  should_carry=True\n  for n in range(0,self.num_gears):\n   nth_gear=self.num_gears -n -1\n   if should_carry:\n    count,lim=self.indicies[nth_gear]\n    count +=1\n    if count ==lim and nth_gear ==0:\n     self.cont=False\n    if count ==lim:\n     should_carry=True\n     count=0\n    else :\n     should_carry=False\n    self.indicies[nth_gear]=(count,lim)\n   else :\n    break\n    \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.zero:\n   raise StopIteration\n  if self.repeat >0:\n   if not self.cont:\n    raise StopIteration\n   l=[]\n   for x in range(0,self.num_gears):\n    index,limit=self.indicies[x]\n    print('itertools 353',self.gears,x,index)\n    l.append(self.gears[x][index])\n   self.roll_gears()\n   return tuple(l)\n  elif self.repeat ==0:\n   self.zero=True\n   return ()\n  else :\n   raise ValueError(\"repeat argument cannot be negative\")\n   \n   \n   \nclass repeat:\n def __init__(self,obj,times=None ):\n  self._obj=obj\n  if times is not None :\n   range(times)\n   if times <0:\n    times=0\n  self._times=times\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n \n  if self._times is not None :\n   if self._times <=0:\n    raise StopIteration()\n   self._times -=1\n  return self._obj\n  \n def __repr__(self):\n  if self._times is not None :\n   return 'repeat(%r, %r)'%(self._obj,self._times)\n  else :\n   return 'repeat(%r)'%(self._obj,)\n   \n def __len__(self):\n  if self._times ==-1 or self._times is None :\n   raise TypeError(\"len() of uniszed object\")\n  return self._times\n  \n  \n  \nclass starmap(object):\n def __init__(self,function,iterable):\n  self._func=function\n  self._iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  t=next(self._iter)\n  return self._func(*t)\n  \n  \n  \nclass takewhile(object):\n def __init__(self,predicate,iterable):\n  self._predicate=predicate\n  self._iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self._iter)\n  if not self._predicate(value):\n   raise StopIteration()\n  return value\n  \n  \n  \nclass TeeData(object):\n def __init__(self,iterator):\n  self.data=[]\n  self._iter=iterator\n  \n def __getitem__(self,i):\n \n  while i >=len(self.data):\n   self.data.append(next(self._iter))\n  return self.data[i]\n  \n  \nclass TeeObject(object):\n def __init__(self,iterable=None ,tee_data=None ):\n  if tee_data:\n   self.tee_data=tee_data\n   self.pos=0\n   \n  elif isinstance(iterable,TeeObject):\n   self.tee_data=iterable.tee_data\n   self.pos=iterable.pos\n  else :\n   self.tee_data=TeeData(iter(iterable))\n   self.pos=0\n   \n def __next__(self):\n  data=self.tee_data[self.pos]\n  self.pos +=1\n  return data\n  \n def __iter__(self):\n  return self\n  \n  \ndef tee(iterable,n=2):\n if isinstance(iterable,TeeObject):\n  return tuple([iterable]+\n  [TeeObject(tee_data=iterable.tee_data)for i in range(n -1)])\n tee_data=TeeData(iter(iterable))\n return tuple([TeeObject(tee_data=tee_data)for i in range(n)])\n \nclass zip_longest:\n def __init__(self,*args,fillvalue=None ):\n  self.args=[iter(arg)for arg in args]\n  self.fillvalue=fillvalue\n  self.units=len(args)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  temp=[]\n  nb=0\n  for i in range(self.units):\n   try :\n    temp.append(next(self.args[i]))\n    nb +=1\n   except StopIteration:\n    temp.append(self.fillvalue)\n  if nb ==0:\n   raise StopIteration\n  return tuple(temp)\n", ["operator"]], "formatter": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\nimport warnings\nwarnings.warn('the formatter module is deprecated',DeprecationWarning,\nstacklevel=2)\n\n\nAS_IS=None\n\n\nclass NullFormatter:\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,writer=None ):\n  if writer is None :\n   writer=NullWriter()\n  self.writer=writer\n def end_paragraph(self,blankline):pass\n def add_line_break(self):pass\n def add_hor_rule(self,*args,**kw):pass\n def add_label_data(self,format,counter,blankline=None ):pass\n def add_flowing_data(self,data):pass\n def add_literal_data(self,data):pass\n def flush_softspace(self):pass\n def push_alignment(self,align):pass\n def pop_alignment(self):pass\n def push_font(self,x):pass\n def pop_font(self):pass\n def push_margin(self,margin):pass\n def pop_margin(self):pass\n def set_spacing(self,spacing):pass\n def push_style(self,*styles):pass\n def pop_style(self,n=1):pass\n def assert_line_data(self,flag=1):pass\n \n \nclass AbstractFormatter:\n ''\n\n\n\n\n\n \n \n \n \n \n \n \n def __init__(self,writer):\n  self.writer=writer\n  self.align=None\n  self.align_stack=[]\n  self.font_stack=[]\n  self.margin_stack=[]\n  self.spacing=None\n  self.style_stack=[]\n  self.nospace=1\n  self.softspace=0\n  self.para_end=1\n  self.parskip=0\n  self.hard_break=1\n  self.have_label=0\n  \n def end_paragraph(self,blankline):\n  if not self.hard_break:\n   self.writer.send_line_break()\n   self.have_label=0\n  if self.parskip <blankline and not self.have_label:\n   self.writer.send_paragraph(blankline -self.parskip)\n   self.parskip=blankline\n   self.have_label=0\n  self.hard_break=self.nospace=self.para_end=1\n  self.softspace=0\n  \n def add_line_break(self):\n  if not (self.hard_break or self.para_end):\n   self.writer.send_line_break()\n   self.have_label=self.parskip=0\n  self.hard_break=self.nospace=1\n  self.softspace=0\n  \n def add_hor_rule(self,*args,**kw):\n  if not self.hard_break:\n   self.writer.send_line_break()\n  self.writer.send_hor_rule(*args,**kw)\n  self.hard_break=self.nospace=1\n  self.have_label=self.para_end=self.softspace=self.parskip=0\n  \n def add_label_data(self,format,counter,blankline=None ):\n  if self.have_label or not self.hard_break:\n   self.writer.send_line_break()\n  if not self.para_end:\n   self.writer.send_paragraph((blankline and 1)or 0)\n  if isinstance(format,str):\n   self.writer.send_label_data(self.format_counter(format,counter))\n  else :\n   self.writer.send_label_data(format)\n  self.nospace=self.have_label=self.hard_break=self.para_end=1\n  self.softspace=self.parskip=0\n  \n def format_counter(self,format,counter):\n  label=''\n  for c in format:\n   if c =='1':\n    label=label+('%d'%counter)\n   elif c in 'aA':\n    if counter >0:\n     label=label+self.format_letter(c,counter)\n   elif c in 'iI':\n    if counter >0:\n     label=label+self.format_roman(c,counter)\n   else :\n    label=label+c\n  return label\n  \n def format_letter(self,case,counter):\n  label=''\n  while counter >0:\n   counter,x=divmod(counter -1,26)\n   \n   \n   \n   s=chr(ord(case)+x)\n   label=s+label\n  return label\n  \n def format_roman(self,case,counter):\n  ones=['i','x','c','m']\n  fives=['v','l','d']\n  label,index='',0\n  \n  while counter >0:\n   counter,x=divmod(counter,10)\n   if x ==9:\n    label=ones[index]+ones[index+1]+label\n   elif x ==4:\n    label=ones[index]+fives[index]+label\n   else :\n    if x >=5:\n     s=fives[index]\n     x=x -5\n    else :\n     s=''\n    s=s+ones[index]*x\n    label=s+label\n   index=index+1\n  if case =='I':\n   return label.upper()\n  return label\n  \n def add_flowing_data(self,data):\n  if not data:return\n  prespace=data[:1].isspace()\n  postspace=data[-1:].isspace()\n  data=\" \".join(data.split())\n  if self.nospace and not data:\n   return\n  elif prespace or self.softspace:\n   if not data:\n    if not self.nospace:\n     self.softspace=1\n     self.parskip=0\n    return\n   if not self.nospace:\n    data=' '+data\n  self.hard_break=self.nospace=self.para_end=\\\n  self.parskip=self.have_label=0\n  self.softspace=postspace\n  self.writer.send_flowing_data(data)\n  \n def add_literal_data(self,data):\n  if not data:return\n  if self.softspace:\n   self.writer.send_flowing_data(\" \")\n  self.hard_break=data[-1:]=='\\n'\n  self.nospace=self.para_end=self.softspace=\\\n  self.parskip=self.have_label=0\n  self.writer.send_literal_data(data)\n  \n def flush_softspace(self):\n  if self.softspace:\n   self.hard_break=self.para_end=self.parskip=\\\n   self.have_label=self.softspace=0\n   self.nospace=1\n   self.writer.send_flowing_data(' ')\n   \n def push_alignment(self,align):\n  if align and align !=self.align:\n   self.writer.new_alignment(align)\n   self.align=align\n   self.align_stack.append(align)\n  else :\n   self.align_stack.append(self.align)\n   \n def pop_alignment(self):\n  if self.align_stack:\n   del self.align_stack[-1]\n  if self.align_stack:\n   self.align=align=self.align_stack[-1]\n   self.writer.new_alignment(align)\n  else :\n   self.align=None\n   self.writer.new_alignment(None )\n   \n def push_font(self,font):\n  size,i,b,tt=font\n  if self.softspace:\n   self.hard_break=self.para_end=self.softspace=0\n   self.nospace=1\n   self.writer.send_flowing_data(' ')\n  if self.font_stack:\n   csize,ci,cb,ctt=self.font_stack[-1]\n   if size is AS_IS:size=csize\n   if i is AS_IS:i=ci\n   if b is AS_IS:b=cb\n   if tt is AS_IS:tt=ctt\n  font=(size,i,b,tt)\n  self.font_stack.append(font)\n  self.writer.new_font(font)\n  \n def pop_font(self):\n  if self.font_stack:\n   del self.font_stack[-1]\n  if self.font_stack:\n   font=self.font_stack[-1]\n  else :\n   font=None\n  self.writer.new_font(font)\n  \n def push_margin(self,margin):\n  self.margin_stack.append(margin)\n  fstack=[m for m in self.margin_stack if m]\n  if not margin and fstack:\n   margin=fstack[-1]\n  self.writer.new_margin(margin,len(fstack))\n  \n def pop_margin(self):\n  if self.margin_stack:\n   del self.margin_stack[-1]\n  fstack=[m for m in self.margin_stack if m]\n  if fstack:\n   margin=fstack[-1]\n  else :\n   margin=None\n  self.writer.new_margin(margin,len(fstack))\n  \n def set_spacing(self,spacing):\n  self.spacing=spacing\n  self.writer.new_spacing(spacing)\n  \n def push_style(self,*styles):\n  if self.softspace:\n   self.hard_break=self.para_end=self.softspace=0\n   self.nospace=1\n   self.writer.send_flowing_data(' ')\n  for style in styles:\n   self.style_stack.append(style)\n  self.writer.new_styles(tuple(self.style_stack))\n  \n def pop_style(self,n=1):\n  del self.style_stack[-n:]\n  self.writer.new_styles(tuple(self.style_stack))\n  \n def assert_line_data(self,flag=1):\n  self.nospace=self.hard_break=not flag\n  self.para_end=self.parskip=self.have_label=0\n  \n  \nclass NullWriter:\n ''\n\n\n\n\n\n \n def __init__(self):pass\n def flush(self):pass\n def new_alignment(self,align):pass\n def new_font(self,font):pass\n def new_margin(self,margin,level):pass\n def new_spacing(self,spacing):pass\n def new_styles(self,styles):pass\n def send_paragraph(self,blankline):pass\n def send_line_break(self):pass\n def send_hor_rule(self,*args,**kw):pass\n def send_label_data(self,data):pass\n def send_flowing_data(self,data):pass\n def send_literal_data(self,data):pass\n \n \nclass AbstractWriter(NullWriter):\n ''\n\n\n\n\n \n \n def new_alignment(self,align):\n  print(\"new_alignment(%r)\"%(align,))\n  \n def new_font(self,font):\n  print(\"new_font(%r)\"%(font,))\n  \n def new_margin(self,margin,level):\n  print(\"new_margin(%r, %d)\"%(margin,level))\n  \n def new_spacing(self,spacing):\n  print(\"new_spacing(%r)\"%(spacing,))\n  \n def new_styles(self,styles):\n  print(\"new_styles(%r)\"%(styles,))\n  \n def send_paragraph(self,blankline):\n  print(\"send_paragraph(%r)\"%(blankline,))\n  \n def send_line_break(self):\n  print(\"send_line_break()\")\n  \n def send_hor_rule(self,*args,**kw):\n  print(\"send_hor_rule()\")\n  \n def send_label_data(self,data):\n  print(\"send_label_data(%r)\"%(data,))\n  \n def send_flowing_data(self,data):\n  print(\"send_flowing_data(%r)\"%(data,))\n  \n def send_literal_data(self,data):\n  print(\"send_literal_data(%r)\"%(data,))\n  \n  \nclass DumbWriter(NullWriter):\n ''\n\n\n\n\n\n \n \n def __init__(self,file=None ,maxcol=72):\n  self.file=file or sys.stdout\n  self.maxcol=maxcol\n  NullWriter.__init__(self)\n  self.reset()\n  \n def reset(self):\n  self.col=0\n  self.atbreak=0\n  \n def send_paragraph(self,blankline):\n  self.file.write('\\n'*blankline)\n  self.col=0\n  self.atbreak=0\n  \n def send_line_break(self):\n  self.file.write('\\n')\n  self.col=0\n  self.atbreak=0\n  \n def send_hor_rule(self,*args,**kw):\n  self.file.write('\\n')\n  self.file.write('-'*self.maxcol)\n  self.file.write('\\n')\n  self.col=0\n  self.atbreak=0\n  \n def send_literal_data(self,data):\n  self.file.write(data)\n  i=data.rfind('\\n')\n  if i >=0:\n   self.col=0\n   data=data[i+1:]\n  data=data.expandtabs()\n  self.col=self.col+len(data)\n  self.atbreak=0\n  \n def send_flowing_data(self,data):\n  if not data:return\n  atbreak=self.atbreak or data[0].isspace()\n  col=self.col\n  maxcol=self.maxcol\n  write=self.file.write\n  for word in data.split():\n   if atbreak:\n    if col+len(word)>=maxcol:\n     write('\\n')\n     col=0\n    else :\n     write(' ')\n     col=col+1\n   write(word)\n   col=col+len(word)\n   atbreak=1\n  self.col=col\n  self.atbreak=data[-1].isspace()\n  \n  \ndef test(file=None ):\n w=DumbWriter()\n f=AbstractFormatter(w)\n if file is not None :\n  fp=open(file)\n elif sys.argv[1:]:\n  fp=open(sys.argv[1])\n else :\n  fp=sys.stdin\n try :\n  for line in fp:\n   if line =='\\n':\n    f.end_paragraph(1)\n   else :\n    f.add_flowing_data(line)\n finally :\n  if fp is not sys.stdin:\n   fp.close()\n f.end_paragraph(0)\n \n \nif __name__ =='__main__':\n test()\n", ["sys", "warnings"]], "sre_constants": [".py", "\n\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\n\nMAGIC=20171005\n\nfrom _sre import MAXREPEAT,MAXGROUPS\n\n\n\n\nclass error(Exception):\n ''\n\n\n\n\n\n\n\n\n \n \n __module__='re'\n \n def __init__(self,msg,pattern=None ,pos=None ):\n  self.msg=msg\n  self.pattern=pattern\n  self.pos=pos\n  if pattern is not None and pos is not None :\n   msg='%s at position %d'%(msg,pos)\n   if isinstance(pattern,str):\n    newline='\\n'\n   else :\n    newline=b'\\n'\n   self.lineno=pattern.count(newline,0,pos)+1\n   self.colno=pos -pattern.rfind(newline,0,pos)\n   if newline in pattern:\n    msg='%s (line %d, column %d)'%(msg,self.lineno,self.colno)\n  else :\n   self.lineno=self.colno=None\n  super().__init__(msg)\n  \n  \nclass _NamedIntConstant(int):\n def __new__(cls,value,name):\n  self=super(_NamedIntConstant,cls).__new__(cls,value)\n  self.name=name\n  return self\n  \n def __repr__(self):\n  return self.name\n  \nMAXREPEAT=_NamedIntConstant(MAXREPEAT,'MAXREPEAT')\n\ndef _makecodes(names):\n names=names.strip().split()\n items=[_NamedIntConstant(i,name)for i,name in enumerate(names)]\n globals().update({item.name:item for item in items})\n return items\n \n \n \nOPCODES=_makecodes(\"\"\"\n    FAILURE SUCCESS\n\n    ANY ANY_ALL\n    ASSERT ASSERT_NOT\n    AT\n    BRANCH\n    CALL\n    CATEGORY\n    CHARSET BIGCHARSET\n    GROUPREF GROUPREF_EXISTS\n    IN\n    INFO\n    JUMP\n    LITERAL\n    MARK\n    MAX_UNTIL\n    MIN_UNTIL\n    NOT_LITERAL\n    NEGATE\n    RANGE\n    REPEAT\n    REPEAT_ONE\n    SUBPATTERN\n    MIN_REPEAT_ONE\n\n    GROUPREF_IGNORE\n    IN_IGNORE\n    LITERAL_IGNORE\n    NOT_LITERAL_IGNORE\n\n    GROUPREF_LOC_IGNORE\n    IN_LOC_IGNORE\n    LITERAL_LOC_IGNORE\n    NOT_LITERAL_LOC_IGNORE\n\n    GROUPREF_UNI_IGNORE\n    IN_UNI_IGNORE\n    LITERAL_UNI_IGNORE\n    NOT_LITERAL_UNI_IGNORE\n    RANGE_UNI_IGNORE\n\n    MIN_REPEAT MAX_REPEAT\n\"\"\")\ndel OPCODES[-2:]\n\n\nATCODES=_makecodes(\"\"\"\n    AT_BEGINNING AT_BEGINNING_LINE AT_BEGINNING_STRING\n    AT_BOUNDARY AT_NON_BOUNDARY\n    AT_END AT_END_LINE AT_END_STRING\n\n    AT_LOC_BOUNDARY AT_LOC_NON_BOUNDARY\n\n    AT_UNI_BOUNDARY AT_UNI_NON_BOUNDARY\n\"\"\")\n\n\nCHCODES=_makecodes(\"\"\"\n    CATEGORY_DIGIT CATEGORY_NOT_DIGIT\n    CATEGORY_SPACE CATEGORY_NOT_SPACE\n    CATEGORY_WORD CATEGORY_NOT_WORD\n    CATEGORY_LINEBREAK CATEGORY_NOT_LINEBREAK\n\n    CATEGORY_LOC_WORD CATEGORY_LOC_NOT_WORD\n\n    CATEGORY_UNI_DIGIT CATEGORY_UNI_NOT_DIGIT\n    CATEGORY_UNI_SPACE CATEGORY_UNI_NOT_SPACE\n    CATEGORY_UNI_WORD CATEGORY_UNI_NOT_WORD\n    CATEGORY_UNI_LINEBREAK CATEGORY_UNI_NOT_LINEBREAK\n\"\"\")\n\n\n\nOP_IGNORE={\nLITERAL:LITERAL_IGNORE,\nNOT_LITERAL:NOT_LITERAL_IGNORE,\n}\n\nOP_LOCALE_IGNORE={\nLITERAL:LITERAL_LOC_IGNORE,\nNOT_LITERAL:NOT_LITERAL_LOC_IGNORE,\n}\n\nOP_UNICODE_IGNORE={\nLITERAL:LITERAL_UNI_IGNORE,\nNOT_LITERAL:NOT_LITERAL_UNI_IGNORE,\n}\n\nAT_MULTILINE={\nAT_BEGINNING:AT_BEGINNING_LINE,\nAT_END:AT_END_LINE\n}\n\nAT_LOCALE={\nAT_BOUNDARY:AT_LOC_BOUNDARY,\nAT_NON_BOUNDARY:AT_LOC_NON_BOUNDARY\n}\n\nAT_UNICODE={\nAT_BOUNDARY:AT_UNI_BOUNDARY,\nAT_NON_BOUNDARY:AT_UNI_NON_BOUNDARY\n}\n\nCH_LOCALE={\nCATEGORY_DIGIT:CATEGORY_DIGIT,\nCATEGORY_NOT_DIGIT:CATEGORY_NOT_DIGIT,\nCATEGORY_SPACE:CATEGORY_SPACE,\nCATEGORY_NOT_SPACE:CATEGORY_NOT_SPACE,\nCATEGORY_WORD:CATEGORY_LOC_WORD,\nCATEGORY_NOT_WORD:CATEGORY_LOC_NOT_WORD,\nCATEGORY_LINEBREAK:CATEGORY_LINEBREAK,\nCATEGORY_NOT_LINEBREAK:CATEGORY_NOT_LINEBREAK\n}\n\nCH_UNICODE={\nCATEGORY_DIGIT:CATEGORY_UNI_DIGIT,\nCATEGORY_NOT_DIGIT:CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_SPACE:CATEGORY_UNI_SPACE,\nCATEGORY_NOT_SPACE:CATEGORY_UNI_NOT_SPACE,\nCATEGORY_WORD:CATEGORY_UNI_WORD,\nCATEGORY_NOT_WORD:CATEGORY_UNI_NOT_WORD,\nCATEGORY_LINEBREAK:CATEGORY_UNI_LINEBREAK,\nCATEGORY_NOT_LINEBREAK:CATEGORY_UNI_NOT_LINEBREAK\n}\n\n\nSRE_FLAG_TEMPLATE=1\nSRE_FLAG_IGNORECASE=2\nSRE_FLAG_LOCALE=4\nSRE_FLAG_MULTILINE=8\nSRE_FLAG_DOTALL=16\nSRE_FLAG_UNICODE=32\nSRE_FLAG_VERBOSE=64\nSRE_FLAG_DEBUG=128\nSRE_FLAG_ASCII=256\n\n\nSRE_INFO_PREFIX=1\nSRE_INFO_LITERAL=2\nSRE_INFO_CHARSET=4\n\nif __name__ ==\"__main__\":\n def dump(f,d,prefix):\n  items=sorted(d)\n  for item in items:\n   f.write(\"#define %s_%s %d\\n\"%(prefix,item,item))\n with open(\"sre_constants.h\",\"w\")as f:\n  f.write(\"\"\"\\\n/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * NOTE: This file is generated by sre_constants.py.  If you need\n * to change anything in here, edit sre_constants.py and run it.\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * See the _sre.c file for information on usage and redistribution.\n */\n\n\"\"\")\n  \n  f.write(\"#define SRE_MAGIC %d\\n\"%MAGIC)\n  \n  dump(f,OPCODES,\"SRE_OP\")\n  dump(f,ATCODES,\"SRE\")\n  dump(f,CHCODES,\"SRE\")\n  \n  f.write(\"#define SRE_FLAG_TEMPLATE %d\\n\"%SRE_FLAG_TEMPLATE)\n  f.write(\"#define SRE_FLAG_IGNORECASE %d\\n\"%SRE_FLAG_IGNORECASE)\n  f.write(\"#define SRE_FLAG_LOCALE %d\\n\"%SRE_FLAG_LOCALE)\n  f.write(\"#define SRE_FLAG_MULTILINE %d\\n\"%SRE_FLAG_MULTILINE)\n  f.write(\"#define SRE_FLAG_DOTALL %d\\n\"%SRE_FLAG_DOTALL)\n  f.write(\"#define SRE_FLAG_UNICODE %d\\n\"%SRE_FLAG_UNICODE)\n  f.write(\"#define SRE_FLAG_VERBOSE %d\\n\"%SRE_FLAG_VERBOSE)\n  f.write(\"#define SRE_FLAG_DEBUG %d\\n\"%SRE_FLAG_DEBUG)\n  f.write(\"#define SRE_FLAG_ASCII %d\\n\"%SRE_FLAG_ASCII)\n  \n  f.write(\"#define SRE_INFO_PREFIX %d\\n\"%SRE_INFO_PREFIX)\n  f.write(\"#define SRE_INFO_LITERAL %d\\n\"%SRE_INFO_LITERAL)\n  f.write(\"#define SRE_INFO_CHARSET %d\\n\"%SRE_INFO_CHARSET)\n  \n print(\"done\")\n", ["_sre"]], "heapq": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__about__=\"\"\"Heap queues\n\n[explanation by Fran\u00e7ois Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\na usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__=['heappush','heappop','heapify','heapreplace','merge',\n'nlargest','nsmallest','heappushpop']\n\ndef heappush(heap,item):\n ''\n heap.append(item)\n _siftdown(heap,0,len(heap)-1)\n \ndef heappop(heap):\n ''\n lastelt=heap.pop()\n if heap:\n  returnitem=heap[0]\n  heap[0]=lastelt\n  _siftup(heap,0)\n  return returnitem\n return lastelt\n \ndef heapreplace(heap,item):\n ''\n\n\n\n\n\n\n\n\n \n returnitem=heap[0]\n heap[0]=item\n _siftup(heap,0)\n return returnitem\n \ndef heappushpop(heap,item):\n ''\n if heap and heap[0]<item:\n  item,heap[0]=heap[0],item\n  _siftup(heap,0)\n return item\n \ndef heapify(x):\n ''\n n=len(x)\n \n \n \n \n \n for i in reversed(range(n //2)):\n  _siftup(x,i)\n  \ndef _heappop_max(heap):\n ''\n lastelt=heap.pop()\n if heap:\n  returnitem=heap[0]\n  heap[0]=lastelt\n  _siftup_max(heap,0)\n  return returnitem\n return lastelt\n \ndef _heapreplace_max(heap,item):\n ''\n returnitem=heap[0]\n heap[0]=item\n _siftup_max(heap,0)\n return returnitem\n \ndef _heapify_max(x):\n ''\n n=len(x)\n for i in reversed(range(n //2)):\n  _siftup_max(x,i)\n  \n  \n  \n  \ndef _siftdown(heap,startpos,pos):\n newitem=heap[pos]\n \n \n while pos >startpos:\n  parentpos=(pos -1)>>1\n  parent=heap[parentpos]\n  if newitem <parent:\n   heap[pos]=parent\n   pos=parentpos\n   continue\n  break\n heap[pos]=newitem\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _siftup(heap,pos):\n endpos=len(heap)\n startpos=pos\n newitem=heap[pos]\n \n childpos=2 *pos+1\n while childpos <endpos:\n \n  rightpos=childpos+1\n  if rightpos <endpos and not heap[childpos]<heap[rightpos]:\n   childpos=rightpos\n   \n  heap[pos]=heap[childpos]\n  pos=childpos\n  childpos=2 *pos+1\n  \n  \n heap[pos]=newitem\n _siftdown(heap,startpos,pos)\n \ndef _siftdown_max(heap,startpos,pos):\n ''\n newitem=heap[pos]\n \n \n while pos >startpos:\n  parentpos=(pos -1)>>1\n  parent=heap[parentpos]\n  if parent <newitem:\n   heap[pos]=parent\n   pos=parentpos\n   continue\n  break\n heap[pos]=newitem\n \ndef _siftup_max(heap,pos):\n ''\n endpos=len(heap)\n startpos=pos\n newitem=heap[pos]\n \n childpos=2 *pos+1\n while childpos <endpos:\n \n  rightpos=childpos+1\n  if rightpos <endpos and not heap[rightpos]<heap[childpos]:\n   childpos=rightpos\n   \n  heap[pos]=heap[childpos]\n  pos=childpos\n  childpos=2 *pos+1\n  \n  \n heap[pos]=newitem\n _siftdown_max(heap,startpos,pos)\n \ndef merge(*iterables,key=None ,reverse=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n h=[]\n h_append=h.append\n \n if reverse:\n  _heapify=_heapify_max\n  _heappop=_heappop_max\n  _heapreplace=_heapreplace_max\n  direction=-1\n else :\n  _heapify=heapify\n  _heappop=heappop\n  _heapreplace=heapreplace\n  direction=1\n  \n if key is None :\n  for order,it in enumerate(map(iter,iterables)):\n   try :\n    next=it.__next__\n    h_append([next(),order *direction,next])\n   except StopIteration:\n    pass\n  _heapify(h)\n  while len(h)>1:\n   try :\n    while True :\n     value,order,next=s=h[0]\n     yield value\n     s[0]=next()\n     _heapreplace(h,s)\n   except StopIteration:\n    _heappop(h)\n  if h:\n  \n   value,order,next=h[0]\n   yield value\n   yield from next.__self__\n  return\n  \n for order,it in enumerate(map(iter,iterables)):\n  try :\n   next=it.__next__\n   value=next()\n   h_append([key(value),order *direction,value,next])\n  except StopIteration:\n   pass\n _heapify(h)\n while len(h)>1:\n  try :\n   while True :\n    key_value,order,value,next=s=h[0]\n    yield value\n    value=next()\n    s[0]=key(value)\n    s[2]=value\n    _heapreplace(h,s)\n  except StopIteration:\n   _heappop(h)\n if h:\n  key_value,order,value,next=h[0]\n  yield value\n  yield from next.__self__\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef nsmallest(n,iterable,key=None ):\n ''\n\n\n \n \n \n if n ==1:\n  it=iter(iterable)\n  sentinel=object()\n  if key is None :\n   result=min(it,default=sentinel)\n  else :\n   result=min(it,default=sentinel,key=key)\n  return []if result is sentinel else [result]\n  \n  \n try :\n  size=len(iterable)\n except (TypeError,AttributeError):\n  pass\n else :\n  if n >=size:\n   return sorted(iterable,key=key)[:n]\n   \n   \n if key is None :\n  it=iter(iterable)\n  \n  \n  result=[(elem,i)for i,elem in zip(range(n),it)]\n  if not result:\n   return result\n  _heapify_max(result)\n  top=result[0][0]\n  order=n\n  _heapreplace=_heapreplace_max\n  for elem in it:\n   if elem <top:\n    _heapreplace(result,(elem,order))\n    top,_order=result[0]\n    order +=1\n  result.sort()\n  return [elem for (elem,order)in result]\n  \n  \n it=iter(iterable)\n result=[(key(elem),i,elem)for i,elem in zip(range(n),it)]\n if not result:\n  return result\n _heapify_max(result)\n top=result[0][0]\n order=n\n _heapreplace=_heapreplace_max\n for elem in it:\n  k=key(elem)\n  if k <top:\n   _heapreplace(result,(k,order,elem))\n   top,_order,_elem=result[0]\n   order +=1\n result.sort()\n return [elem for (k,order,elem)in result]\n \ndef nlargest(n,iterable,key=None ):\n ''\n\n\n \n \n \n if n ==1:\n  it=iter(iterable)\n  sentinel=object()\n  if key is None :\n   result=max(it,default=sentinel)\n  else :\n   result=max(it,default=sentinel,key=key)\n  return []if result is sentinel else [result]\n  \n  \n try :\n  size=len(iterable)\n except (TypeError,AttributeError):\n  pass\n else :\n  if n >=size:\n   return sorted(iterable,key=key,reverse=True )[:n]\n   \n   \n if key is None :\n  it=iter(iterable)\n  result=[(elem,i)for i,elem in zip(range(0,-n,-1),it)]\n  if not result:\n   return result\n  heapify(result)\n  top=result[0][0]\n  order=-n\n  _heapreplace=heapreplace\n  for elem in it:\n   if top <elem:\n    _heapreplace(result,(elem,order))\n    top,_order=result[0]\n    order -=1\n  result.sort(reverse=True )\n  return [elem for (elem,order)in result]\n  \n  \n it=iter(iterable)\n result=[(key(elem),i,elem)for i,elem in zip(range(0,-n,-1),it)]\n if not result:\n  return result\n heapify(result)\n top=result[0][0]\n order=-n\n _heapreplace=heapreplace\n for elem in it:\n  k=key(elem)\n  if top <k:\n   _heapreplace(result,(k,order,elem))\n   top,_order,_elem=result[0]\n   order -=1\n result.sort(reverse=True )\n return [elem for (k,order,elem)in result]\n \n \n \n \n\"\"\"\ntry:\n    from _heapq import *\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapreplace_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapify_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heappop_max\nexcept ImportError:\n    pass\n\"\"\"\n\nif __name__ ==\"__main__\":\n\n import doctest\n print(doctest.testmod())\n", ["doctest"]], "base64": [".py", "#! /usr/bin/env python3\n\n\"\"\"Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings\"\"\"\n\n\n\n\n\nimport re\nimport struct\nimport binascii\n\n\n__all__=[\n\n'encode','decode','encodebytes','decodebytes',\n\n'b64encode','b64decode','b32encode','b32decode',\n'b16encode','b16decode',\n\n'b85encode','b85decode','a85encode','a85decode',\n\n'standard_b64encode','standard_b64decode',\n\n\n\n\n'urlsafe_b64encode','urlsafe_b64decode',\n]\n\n\nbytes_types=(bytes,bytearray)\n\ndef _bytes_from_decode_data(s):\n if isinstance(s,str):\n  try :\n   return s.encode('ascii')\n  except UnicodeEncodeError:\n   raise ValueError('string argument should contain only ASCII characters')\n if isinstance(s,bytes_types):\n  return s\n try :\n  return memoryview(s).tobytes()\n except TypeError:\n  raise TypeError(\"argument should be a bytes-like object or ASCII \"\n  \"string, not %r\"%s.__class__.__name__)from None\n  \n  \n  \n  \ndef b64encode(s,altchars=None ):\n ''\n\n\n\n\n \n encoded=binascii.b2a_base64(s,newline=False )\n if altchars is not None :\n  assert len(altchars)==2,repr(altchars)\n  return encoded.translate(bytes.maketrans(b'+/',altchars))\n return encoded\n \n \ndef b64decode(s,altchars=None ,validate=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n s=_bytes_from_decode_data(s)\n if altchars is not None :\n  altchars=_bytes_from_decode_data(altchars)\n  assert len(altchars)==2,repr(altchars)\n  s=s.translate(bytes.maketrans(altchars,b'+/'))\n if validate and not re.match(b'^[A-Za-z0-9+/]*={0,2}$',s):\n  raise binascii.Error('Non-base64 digit found')\n return binascii.a2b_base64(s)\n \n \ndef standard_b64encode(s):\n ''\n\n\n \n return b64encode(s)\n \ndef standard_b64decode(s):\n ''\n\n\n\n\n\n \n return b64decode(s)\n \n \n_urlsafe_encode_translation=bytes.maketrans(b'+/',b'-_')\n_urlsafe_decode_translation=bytes.maketrans(b'-_',b'+/')\n\ndef urlsafe_b64encode(s):\n ''\n\n\n\n\n \n return b64encode(s).translate(_urlsafe_encode_translation)\n \ndef urlsafe_b64decode(s):\n ''\n\n\n\n\n\n\n\n\n \n s=_bytes_from_decode_data(s)\n s=s.translate(_urlsafe_decode_translation)\n return b64decode(s)\n \n \n \n \n_b32alphabet=b'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n_b32tab2=None\n_b32rev=None\n\ndef b32encode(s):\n ''\n \n global _b32tab2\n \n \n if _b32tab2 is None :\n  b32tab=[bytes((i,))for i in _b32alphabet]\n  _b32tab2=[a+b for a in b32tab for b in b32tab]\n  b32tab=None\n  \n if not isinstance(s,bytes_types):\n  s=memoryview(s).tobytes()\n leftover=len(s)%5\n \n if leftover:\n  s=s+b'\\0'*(5 -leftover)\n encoded=bytearray()\n from_bytes=int.from_bytes\n b32tab2=_b32tab2\n for i in range(0,len(s),5):\n  c=from_bytes(s[i:i+5],'big')\n  encoded +=(b32tab2[c >>30]+\n  b32tab2[(c >>20)&0x3ff]+\n  b32tab2[(c >>10)&0x3ff]+\n  b32tab2[c&0x3ff]\n  )\n  \n if leftover ==1:\n  encoded[-6:]=b'======'\n elif leftover ==2:\n  encoded[-4:]=b'===='\n elif leftover ==3:\n  encoded[-3:]=b'==='\n elif leftover ==4:\n  encoded[-1:]=b'='\n return bytes(encoded)\n \ndef b32decode(s,casefold=False ,map01=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _b32rev\n \n \n if _b32rev is None :\n  _b32rev={v:k for k,v in enumerate(_b32alphabet)}\n s=_bytes_from_decode_data(s)\n if len(s)%8:\n  raise binascii.Error('Incorrect padding')\n  \n  \n  \n if map01 is not None :\n  map01=_bytes_from_decode_data(map01)\n  assert len(map01)==1,repr(map01)\n  s=s.translate(bytes.maketrans(b'01',b'O'+map01))\n if casefold:\n  s=s.upper()\n  \n  \n  \n l=len(s)\n s=s.rstrip(b'=')\n padchars=l -len(s)\n \n decoded=bytearray()\n b32rev=_b32rev\n for i in range(0,len(s),8):\n  quanta=s[i:i+8]\n  acc=0\n  try :\n   for c in quanta:\n    acc=(acc <<5)+b32rev[c]\n  except KeyError:\n   raise binascii.Error('Non-base32 digit found')from None\n  decoded +=acc.to_bytes(5,'big')\n  \n if l %8 or padchars not in {0,1,3,4,6}:\n  raise binascii.Error('Incorrect padding')\n if padchars and decoded:\n  acc <<=5 *padchars\n  last=acc.to_bytes(5,'big')\n  leftover=(43 -5 *padchars)//8\n  decoded[-5:]=last[:leftover]\n return bytes(decoded)\n \n \n \n \n \ndef b16encode(s):\n ''\n \n return binascii.hexlify(s).upper()\n \n \ndef b16decode(s,casefold=False ):\n ''\n\n\n\n\n\n\n\n \n s=_bytes_from_decode_data(s)\n if casefold:\n  s=s.upper()\n if re.search(b'[^0-9A-F]',s):\n  raise binascii.Error('Non-base16 digit found')\n return binascii.unhexlify(s)\n \n \n \n \n \n_a85chars=None\n_a85chars2=None\n_A85START=b\"<~\"\n_A85END=b\"~>\"\n\ndef _85encode(b,chars,chars2,pad=False ,foldnuls=False ,foldspaces=False ):\n\n if not isinstance(b,bytes_types):\n  b=memoryview(b).tobytes()\n  \n padding=(-len(b))%4\n if padding:\n  b=b+b'\\0'*padding\n words=struct.Struct('!%dI'%(len(b)//4)).unpack(b)\n \n chunks=[b'z'if foldnuls and not word else\n b'y'if foldspaces and word ==0x20202020 else\n (chars2[word //614125]+\n chars2[word //85 %7225]+\n chars[word %85])\n for word in words]\n \n if padding and not pad:\n  if chunks[-1]==b'z':\n   chunks[-1]=chars[0]*5\n  chunks[-1]=chunks[-1][:-padding]\n  \n return b''.join(chunks)\n \ndef a85encode(b,*,foldspaces=False ,wrapcol=0,pad=False ,adobe=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _a85chars,_a85chars2\n \n \n if _a85chars is None :\n  _a85chars=[bytes((i,))for i in range(33,118)]\n  _a85chars2=[(a+b)for a in _a85chars for b in _a85chars]\n  \n result=_85encode(b,_a85chars,_a85chars2,pad,True ,foldspaces)\n \n if adobe:\n  result=_A85START+result\n if wrapcol:\n  wrapcol=max(2 if adobe else 1,wrapcol)\n  chunks=[result[i:i+wrapcol]\n  for i in range(0,len(result),wrapcol)]\n  if adobe:\n   if len(chunks[-1])+2 >wrapcol:\n    chunks.append(b'')\n  result=b'\\n'.join(chunks)\n if adobe:\n  result +=_A85END\n  \n return result\n \ndef a85decode(b,*,foldspaces=False ,adobe=False ,ignorechars=b' \\t\\n\\r\\v'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n b=_bytes_from_decode_data(b)\n if adobe:\n  if not b.endswith(_A85END):\n   raise ValueError(\n   \"Ascii85 encoded byte sequences must end \"\n   \"with {!r}\".format(_A85END)\n   )\n  if b.startswith(_A85START):\n   b=b[2:-2]\n  else :\n   b=b[:-2]\n   \n   \n   \n   \n packI=struct.Struct('!I').pack\n decoded=[]\n decoded_append=decoded.append\n curr=[]\n curr_append=curr.append\n curr_clear=curr.clear\n for x in b+b'u'*4:\n  if b'!'[0]<=x <=b'u'[0]:\n   curr_append(x)\n   if len(curr)==5:\n    acc=0\n    for x in curr:\n     acc=85 *acc+(x -33)\n    try :\n     decoded_append(packI(acc))\n    except struct.error:\n     raise ValueError('Ascii85 overflow')from None\n    curr_clear()\n  elif x ==b'z'[0]:\n   if curr:\n    raise ValueError('z inside Ascii85 5-tuple')\n   decoded_append(b'\\0\\0\\0\\0')\n  elif foldspaces and x ==b'y'[0]:\n   if curr:\n    raise ValueError('y inside Ascii85 5-tuple')\n   decoded_append(b'\\x20\\x20\\x20\\x20')\n  elif x in ignorechars:\n  \n   continue\n  else :\n   raise ValueError('Non-Ascii85 digit found: %c'%x)\n   \n result=b''.join(decoded)\n padding=4 -len(curr)\n if padding:\n \n  result=result[:-padding]\n return result\n \n \n \n_b85alphabet=(b\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nb\"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\")\n_b85chars=None\n_b85chars2=None\n_b85dec=None\n\ndef b85encode(b,pad=False ):\n ''\n\n\n\n \n global _b85chars,_b85chars2\n \n \n if _b85chars is None :\n  _b85chars=[bytes((i,))for i in _b85alphabet]\n  _b85chars2=[(a+b)for a in _b85chars for b in _b85chars]\n return _85encode(b,_b85chars,_b85chars2,pad)\n \ndef b85decode(b):\n ''\n\n\n \n global _b85dec\n \n \n if _b85dec is None :\n  _b85dec=[None ]*256\n  for i,c in enumerate(_b85alphabet):\n   _b85dec[c]=i\n   \n b=_bytes_from_decode_data(b)\n padding=(-len(b))%5\n b=b+b'~'*padding\n out=[]\n packI=struct.Struct('!I').pack\n for i in range(0,len(b),5):\n  chunk=b[i:i+5]\n  acc=0\n  try :\n   for c in chunk:\n    acc=acc *85+_b85dec[c]\n  except TypeError:\n   for j,c in enumerate(chunk):\n    if _b85dec[c]is None :\n     raise ValueError('bad base85 character at position %d'\n     %(i+j))from None\n   raise\n  try :\n   out.append(packI(acc))\n  except struct.error:\n   raise ValueError('base85 overflow in hunk starting at byte %d'\n   %i)from None\n   \n result=b''.join(out)\n if padding:\n  result=result[:-padding]\n return result\n \n \n \n \n \nMAXLINESIZE=76\nMAXBINSIZE=(MAXLINESIZE //4)*3\n\ndef encode(input,output):\n ''\n while True :\n  s=input.read(MAXBINSIZE)\n  if not s:\n   break\n  while len(s)<MAXBINSIZE:\n   ns=input.read(MAXBINSIZE -len(s))\n   if not ns:\n    break\n   s +=ns\n  line=binascii.b2a_base64(s)\n  output.write(line)\n  \n  \ndef decode(input,output):\n ''\n while True :\n  line=input.readline()\n  if not line:\n   break\n  s=binascii.a2b_base64(line)\n  output.write(s)\n  \ndef _input_type_check(s):\n try :\n  m=memoryview(s)\n except TypeError as err:\n  msg=\"expected bytes-like object, not %s\"%s.__class__.__name__\n  raise TypeError(msg)from err\n if m.format not in ('c','b','B'):\n  msg=(\"expected single byte elements, not %r from %s\"%\n  (m.format,s.__class__.__name__))\n  raise TypeError(msg)\n if m.ndim !=1:\n  msg=(\"expected 1-D data, not %d-D data from %s\"%\n  (m.ndim,s.__class__.__name__))\n  raise TypeError(msg)\n  \n  \ndef encodebytes(s):\n ''\n \n _input_type_check(s)\n pieces=[]\n for i in range(0,len(s),MAXBINSIZE):\n  chunk=s[i:i+MAXBINSIZE]\n  pieces.append(binascii.b2a_base64(chunk))\n return b\"\".join(pieces)\n \ndef encodestring(s):\n ''\n import warnings\n warnings.warn(\"encodestring() is a deprecated alias since 3.1, \"\n \"use encodebytes()\",\n DeprecationWarning,2)\n return encodebytes(s)\n \n \ndef decodebytes(s):\n ''\n _input_type_check(s)\n return binascii.a2b_base64(s)\n \ndef decodestring(s):\n ''\n import warnings\n warnings.warn(\"decodestring() is a deprecated alias since Python 3.1, \"\n \"use decodebytes()\",\n DeprecationWarning,2)\n return decodebytes(s)\n \n \n \ndef main():\n ''\n import sys,getopt\n try :\n  opts,args=getopt.getopt(sys.argv[1:],'deut')\n except getopt.error as msg:\n  sys.stdout=sys.stderr\n  print(msg)\n  print(\"\"\"usage: %s [-d|-e|-u|-t] [file|-]\n        -d, -u: decode\n        -e: encode (default)\n        -t: encode and decode string 'Aladdin:open sesame'\"\"\"%sys.argv[0])\n  sys.exit(2)\n func=encode\n for o,a in opts:\n  if o =='-e':func=encode\n  if o =='-d':func=decode\n  if o =='-u':func=decode\n  if o =='-t':test();return\n if args and args[0]!='-':\n  with open(args[0],'rb')as f:\n   func(f,sys.stdout.buffer)\n else :\n  func(sys.stdin.buffer,sys.stdout.buffer)\n  \n  \ndef test():\n s0=b\"Aladdin:open sesame\"\n print(repr(s0))\n s1=encodebytes(s0)\n print(repr(s1))\n s2=decodebytes(s1)\n print(repr(s2))\n assert s0 ==s2\n \n \nif __name__ =='__main__':\n main()\n", ["binascii", "getopt", "re", "struct", "sys", "warnings"]], "_operator": [".py", "''\n\n\ndef _compare_digest(a,b):\n ''\n\n\n\n\n\n\n\n\n \n if isinstance(a,str)and isinstance(b,str)and\\\n a.isascii()and b.isascii():\n  return a ==b\n elif isinstance(a,bytes)and isinstance(b,bytes):\n  return a ==b\n raise TypeError(\"unsupported operand types\")\n \n", []], "os": [".py", "''\n\n\n\nimport abc\nimport sys\n\nerror=OSError\nname='posix'\nlinesep='\\n'\n\nfrom posix import *\nimport posixpath as path\n\nsys.modules['os.path']=path\nfrom os.path import (curdir,pardir,sep,pathsep,defpath,extsep,altsep,\ndevnull)\n\nenviron={'HOME':__BRYTHON__.curdir,\n'PYTHONPATH':__BRYTHON__.brython_path\n}\n\n\nclass terminal_size:\n\n def __init__(self,fileno):\n  self.columns=120\n  self.lines=30\n  \ndef get_terminal_size(*args):\n return terminal_size(None )\n \ndef _get_exports_list(module):\n try :\n  return list(module.__all__)\n except AttributeError:\n  return [n for n in dir(module)if n[0]!='_']\n  \ndef getenv(key,default=None ):\n ''\n\n \n return environ.get(key,default)\n \nsupports_bytes_environ=True\n\ndef chdir(path):\n __BRYTHON__.curdir=path\n \ndef fsencode(filename):\n ''\n\n\n\n \n encoding=sys.getfilesystemencoding()\n errors='surrogateescape'\n if isinstance(filename,bytes):\n  return filename\n elif isinstance(filename,str):\n  return filename.encode(encoding,errors)\n else :\n  raise TypeError(\"expect bytes or str, not %s\"%type(filename).__name__)\n  \ndef fsdecode(filename):\n ''\n\n\n\n \n encoding=sys.getfilesystemencoding()\n errors='surrogateescape'\n if isinstance(filename,str):\n  return filename\n elif isinstance(filename,bytes):\n  return filename.decode(encoding,errors)\n else :\n  raise TypeError(\"expect bytes or str, not %s\"%type(filename).__name__)\n  \ndef fspath(path):\n return path\n \ndef getcwd():\n return __BRYTHON__.curdir\n \nclass PathLike(abc.ABC):\n\n ''\n \n @abc.abstractmethod\n def __fspath__(self):\n  ''\n  raise NotImplementedError\n  \n @classmethod\n def __subclasshook__(cls,subclass):\n  return hasattr(subclass,'__fspath__')\n  \n  \nif name =='nt':\n class _AddedDllDirectory:\n  def __init__(self,path,cookie,remove_dll_directory):\n   self.path=path\n   self._cookie=cookie\n   self._remove_dll_directory=remove_dll_directory\n  def close(self):\n   self._remove_dll_directory(self._cookie)\n   self.path=None\n  def __enter__(self):\n   return self\n  def __exit__(self,*args):\n   self.close()\n  def __repr__(self):\n   if self.path:\n    return \"<AddedDllDirectory({!r})>\".format(self.path)\n   return \"<AddedDllDirectory()>\"\n   \n def add_dll_directory(path):\n  ''\n\n\n\n\n\n\n\n  \n  import nt\n  cookie=nt._add_dll_directory(path)\n  return _AddedDllDirectory(\n  path,\n  cookie,\n  nt._remove_dll_directory\n  )\n  \n  \ndef scandir(*args,**kw):\n raise NotImplementedError\n \n_set=set()\n\nsupports_dir_fd=_set\n\nsupports_effective_ids=_set\n\nsupports_fd=_set\n\nsupports_follow_symlinks=_set\n\n", ["abc", "nt", "os.path", "posix", "posixpath", "sys"]], "_random": [".py", "from browser import window,alert\n\ndef _randint(a,b):\n return int(window.Math.random()*(b -a+1)+a)\n \ndef _rand_with_seed(x,rand_obj):\n\n\n degrees=rand_obj._state %360\n x=window.Math.sin(degrees /(2 *window.Math.PI))*10000\n \n \n \n \n \n if not hasattr(rand_obj,'incr'):\n  rand_obj.incr=1\n rand_obj._state +=rand_obj.incr\n return x -window.Math.floor(x)\n \ndef _urandom(n,rand_obj=None ):\n ''\n \n \n if rand_obj is None or rand_obj._state is None :\n  randbytes=[_randint(0,255)for i in range(n)]\n else :\n  randbytes=[]\n  for i in range(n):\n   randbytes.append(int(256 *_rand_with_seed(i,rand_obj)))\n return bytes(randbytes)\n \nclass Random:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n VERSION=3\n \n def __init__(self,x=None ):\n  ''\n\n\n  \n  \n  self._state=x\n  \n def seed(self,a=None ,version=2):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  self._state=a\n  self.gauss_next=None\n  \n def getstate(self):\n  ''\n  return self._state\n  \n def setstate(self,state):\n  ''\n  self._state=state\n  \n def random(self):\n  ''\n  return window.Math.random()\n  \n def getrandbits(self,k):\n  ''\n  if k <=0:\n   raise ValueError('number of bits must be greater than zero')\n  if k !=int(k):\n   raise TypeError('number of bits should be an integer')\n  numbytes=(k+7)//8\n  x=int.from_bytes(_urandom(numbytes,self),'big')\n  \n  return x >>(numbytes *8 -k)\n", ["browser"]], "glob": [".py", "''\n\nimport os\nimport re\nimport fnmatch\nimport sys\n\n__all__=[\"glob\",\"iglob\",\"escape\"]\n\ndef glob(pathname,*,recursive=False ):\n ''\n\n\n\n\n\n\n\n\n \n return list(iglob(pathname,recursive=recursive))\n \ndef iglob(pathname,*,recursive=False ):\n ''\n\n\n\n\n\n\n\n\n \n it=_iglob(pathname,recursive,False )\n if recursive and _isrecursive(pathname):\n  s=next(it)\n  assert not s\n return it\n \ndef _iglob(pathname,recursive,dironly):\n sys.audit(\"glob.glob\",pathname,recursive)\n dirname,basename=os.path.split(pathname)\n if not has_magic(pathname):\n  assert not dironly\n  if basename:\n   if os.path.lexists(pathname):\n    yield pathname\n  else :\n  \n   if os.path.isdir(dirname):\n    yield pathname\n  return\n if not dirname:\n  if recursive and _isrecursive(basename):\n   yield from _glob2(dirname,basename,dironly)\n  else :\n   yield from _glob1(dirname,basename,dironly)\n  return\n  \n  \n  \n if dirname !=pathname and has_magic(dirname):\n  dirs=_iglob(dirname,recursive,True )\n else :\n  dirs=[dirname]\n if has_magic(basename):\n  if recursive and _isrecursive(basename):\n   glob_in_dir=_glob2\n  else :\n   glob_in_dir=_glob1\n else :\n  glob_in_dir=_glob0\n for dirname in dirs:\n  for name in glob_in_dir(dirname,basename,dironly):\n   yield os.path.join(dirname,name)\n   \n   \n   \n   \n   \ndef _glob1(dirname,pattern,dironly):\n names=list(_iterdir(dirname,dironly))\n if not _ishidden(pattern):\n  names=(x for x in names if not _ishidden(x))\n return fnmatch.filter(names,pattern)\n \ndef _glob0(dirname,basename,dironly):\n if not basename:\n \n \n  if os.path.isdir(dirname):\n   return [basename]\n else :\n  if os.path.lexists(os.path.join(dirname,basename)):\n   return [basename]\n return []\n \n \n \ndef glob0(dirname,pattern):\n return _glob0(dirname,pattern,False )\n \ndef glob1(dirname,pattern):\n return _glob1(dirname,pattern,False )\n \n \n \n \ndef _glob2(dirname,pattern,dironly):\n assert _isrecursive(pattern)\n yield pattern[:0]\n yield from _rlistdir(dirname,dironly)\n \n \n \ndef _iterdir(dirname,dironly):\n if not dirname:\n  if isinstance(dirname,bytes):\n   dirname=bytes(os.curdir,'ASCII')\n  else :\n   dirname=os.curdir\n try :\n  with os.scandir(dirname)as it:\n   for entry in it:\n    try :\n     if not dironly or entry.is_dir():\n      yield entry.name\n    except OSError:\n     pass\n except OSError:\n  return\n  \n  \ndef _rlistdir(dirname,dironly):\n names=list(_iterdir(dirname,dironly))\n for x in names:\n  if not _ishidden(x):\n   yield x\n   path=os.path.join(dirname,x)if dirname else x\n   for y in _rlistdir(path,dironly):\n    yield os.path.join(x,y)\n    \n    \nmagic_check=re.compile('([*?[])')\nmagic_check_bytes=re.compile(b'([*?[])')\n\ndef has_magic(s):\n if isinstance(s,bytes):\n  match=magic_check_bytes.search(s)\n else :\n  match=magic_check.search(s)\n return match is not None\n \ndef _ishidden(path):\n return path[0]in ('.',b'.'[0])\n \ndef _isrecursive(pattern):\n if isinstance(pattern,bytes):\n  return pattern ==b'**'\n else :\n  return pattern =='**'\n  \ndef escape(pathname):\n ''\n \n \n \n drive,pathname=os.path.splitdrive(pathname)\n if isinstance(pathname,bytes):\n  pathname=magic_check_bytes.sub(br'[\\1]',pathname)\n else :\n  pathname=magic_check.sub(r'[\\1]',pathname)\n return drive+pathname\n", ["fnmatch", "os", "re", "sys"]], "warnings": [".py", "''\n\nimport sys\n\n\n__all__=[\"warn\",\"warn_explicit\",\"showwarning\",\n\"formatwarning\",\"filterwarnings\",\"simplefilter\",\n\"resetwarnings\",\"catch_warnings\"]\n\ndef showwarning(message,category,filename,lineno,file=None ,line=None ):\n ''\n msg=WarningMessage(message,category,filename,lineno,file,line)\n _showwarnmsg_impl(msg)\n \ndef formatwarning(message,category,filename,lineno,line=None ):\n ''\n msg=WarningMessage(message,category,filename,lineno,None ,line)\n return _formatwarnmsg_impl(msg)\n \ndef _showwarnmsg_impl(msg):\n file=msg.file\n if file is None :\n  file=sys.stderr\n  if file is None :\n  \n  \n   return\n text=_formatwarnmsg(msg)\n try :\n  file.write(text)\n except OSError:\n \n  pass\n  \ndef _formatwarnmsg_impl(msg):\n category=msg.category.__name__\n s=f\"{msg.filename}:{msg.lineno}: {category}: {msg.message}\\n\"\n \n if msg.line is None :\n  try :\n   import linecache\n   line=linecache.getline(msg.filename,msg.lineno)\n  except Exception:\n  \n  \n   line=None\n   linecache=None\n else :\n  line=msg.line\n if line:\n  line=line.strip()\n  s +=\"  %s\\n\"%line\n  \n if msg.source is not None :\n  try :\n   import tracemalloc\n   \n   \n  except Exception:\n  \n   tracing=True\n   tb=None\n  else :\n   tracing=tracemalloc.is_tracing()\n   try :\n    tb=tracemalloc.get_object_traceback(msg.source)\n   except Exception:\n   \n   \n    tb=None\n    \n  if tb is not None :\n   s +='Object allocated at (most recent call last):\\n'\n   for frame in tb:\n    s +=('  File \"%s\", lineno %s\\n'\n    %(frame.filename,frame.lineno))\n    \n    try :\n     if linecache is not None :\n      line=linecache.getline(frame.filename,frame.lineno)\n     else :\n      line=None\n    except Exception:\n     line=None\n    if line:\n     line=line.strip()\n     s +='    %s\\n'%line\n  elif not tracing:\n   s +=(f'{category}: Enable tracemalloc to get the object '\n   f'allocation traceback\\n')\n return s\n \n \n_showwarning_orig=showwarning\n\ndef _showwarnmsg(msg):\n ''\n try :\n  sw=showwarning\n except NameError:\n  pass\n else :\n  if sw is not _showwarning_orig:\n  \n   if not callable(sw):\n    raise TypeError(\"warnings.showwarning() must be set to a \"\n    \"function or method\")\n    \n   sw(msg.message,msg.category,msg.filename,msg.lineno,\n   msg.file,msg.line)\n   return\n _showwarnmsg_impl(msg)\n \n \n_formatwarning_orig=formatwarning\n\ndef _formatwarnmsg(msg):\n ''\n try :\n  fw=formatwarning\n except NameError:\n  pass\n else :\n  if fw is not _formatwarning_orig:\n  \n   return fw(msg.message,msg.category,\n   msg.filename,msg.lineno,msg.line)\n return _formatwarnmsg_impl(msg)\n \ndef filterwarnings(action,message=\"\",category=Warning,module=\"\",lineno=0,\nappend=False ):\n ''\n\n\n\n\n\n\n\n\n \n assert action in (\"error\",\"ignore\",\"always\",\"default\",\"module\",\n \"once\"),\"invalid action: %r\"%(action,)\n assert isinstance(message,str),\"message must be a string\"\n assert isinstance(category,type),\"category must be a class\"\n assert issubclass(category,Warning),\"category must be a Warning subclass\"\n assert isinstance(module,str),\"module must be a string\"\n assert isinstance(lineno,int)and lineno >=0,\\\n \"lineno must be an int >= 0\"\n \n if message or module:\n  import re\n  \n if message:\n  message=re.compile(message,re.I)\n else :\n  message=None\n if module:\n  module=re.compile(module)\n else :\n  module=None\n  \n _add_filter(action,message,category,module,lineno,append=append)\n \ndef simplefilter(action,category=Warning,lineno=0,append=False ):\n ''\n\n\n\n\n\n\n\n \n assert action in (\"error\",\"ignore\",\"always\",\"default\",\"module\",\n \"once\"),\"invalid action: %r\"%(action,)\n assert isinstance(lineno,int)and lineno >=0,\\\n \"lineno must be an int >= 0\"\n _add_filter(action,None ,category,None ,lineno,append=append)\n \ndef _add_filter(*item,append):\n\n\n if not append:\n  try :\n   filters.remove(item)\n  except ValueError:\n   pass\n  filters.insert(0,item)\n else :\n  if item not in filters:\n   filters.append(item)\n _filters_mutated()\n \ndef resetwarnings():\n ''\n filters[:]=[]\n _filters_mutated()\n \nclass _OptionError(Exception):\n ''\n pass\n \n \ndef _processoptions(args):\n for arg in args:\n  try :\n   _setoption(arg)\n  except _OptionError as msg:\n   print(\"Invalid -W option ignored:\",msg,file=sys.stderr)\n   \n   \ndef _setoption(arg):\n import re\n parts=arg.split(':')\n if len(parts)>5:\n  raise _OptionError(\"too many fields (max 5): %r\"%(arg,))\n while len(parts)<5:\n  parts.append('')\n action,message,category,module,lineno=[s.strip()\n for s in parts]\n action=_getaction(action)\n message=re.escape(message)\n category=_getcategory(category)\n module=re.escape(module)\n if module:\n  module=module+'$'\n if lineno:\n  try :\n   lineno=int(lineno)\n   if lineno <0:\n    raise ValueError\n  except (ValueError,OverflowError):\n   raise _OptionError(\"invalid lineno %r\"%(lineno,))from None\n else :\n  lineno=0\n filterwarnings(action,message,category,module,lineno)\n \n \ndef _getaction(action):\n if not action:\n  return \"default\"\n if action ==\"all\":return \"always\"\n for a in ('default','always','ignore','module','once','error'):\n  if a.startswith(action):\n   return a\n raise _OptionError(\"invalid action: %r\"%(action,))\n \n \ndef _getcategory(category):\n import re\n if not category:\n  return Warning\n if re.match(\"^[a-zA-Z0-9_]+$\",category):\n  try :\n   cat=eval(category)\n  except NameError:\n   raise _OptionError(\"unknown warning category: %r\"%(category,))from None\n else :\n  i=category.rfind(\".\")\n  module=category[:i]\n  klass=category[i+1:]\n  try :\n   m=__import__(module,None ,None ,[klass])\n  except ImportError:\n   raise _OptionError(\"invalid module name: %r\"%(module,))from None\n  try :\n   cat=getattr(m,klass)\n  except AttributeError:\n   raise _OptionError(\"unknown warning category: %r\"%(category,))from None\n if not issubclass(cat,Warning):\n  raise _OptionError(\"invalid warning category: %r\"%(category,))\n return cat\n \n \ndef _is_internal_frame(frame):\n ''\n filename=frame.f_code.co_filename\n return 'importlib'in filename and '_bootstrap'in filename\n \n \ndef _next_external_frame(frame):\n ''\n frame=frame.f_back\n while frame is not None and _is_internal_frame(frame):\n  frame=frame.f_back\n return frame\n \n \n \ndef warn(message,category=None ,stacklevel=1,source=None ):\n ''\n \n if isinstance(message,Warning):\n  category=message.__class__\n  \n if category is None :\n  category=UserWarning\n if not (isinstance(category,type)and issubclass(category,Warning)):\n  raise TypeError(\"category must be a Warning subclass, \"\n  \"not '{:s}'\".format(type(category).__name__))\n  \n try :\n  if stacklevel <=1 or _is_internal_frame(sys._getframe(1)):\n  \n  \n   frame=sys._getframe(stacklevel)\n  else :\n   frame=sys._getframe(1)\n   \n   for x in range(stacklevel -1):\n    frame=_next_external_frame(frame)\n    if frame is None :\n     raise ValueError\n except ValueError:\n  globals=sys.__dict__\n  filename=\"sys\"\n  lineno=1\n else :\n  globals=frame.f_globals\n  filename=frame.f_code.co_filename\n  lineno=frame.f_lineno\n if '__name__'in globals:\n  module=globals['__name__']\n else :\n  module=\"<string>\"\n registry=globals.setdefault(\"__warningregistry__\",{})\n warn_explicit(message,category,filename,lineno,module,registry,\n globals,source)\n \ndef warn_explicit(message,category,filename,lineno,\nmodule=None ,registry=None ,module_globals=None ,\nsource=None ):\n lineno=int(lineno)\n if module is None :\n  module=filename or \"<unknown>\"\n  if module[-3:].lower()==\".py\":\n   module=module[:-3]\n if registry is None :\n  registry={}\n if registry.get('version',0)!=_filters_version:\n  registry.clear()\n  registry['version']=_filters_version\n if isinstance(message,Warning):\n  text=str(message)\n  category=message.__class__\n else :\n  text=message\n  message=category(message)\n key=(text,category,lineno)\n \n if registry.get(key):\n  return\n  \n for item in filters:\n  action,msg,cat,mod,ln=item\n  if ((msg is None or msg.match(text))and\n  issubclass(category,cat)and\n  (mod is None or mod.match(module))and\n  (ln ==0 or lineno ==ln)):\n   break\n else :\n  action=defaultaction\n  \n if action ==\"ignore\":\n  return\n  \n  \n  \n import linecache\n linecache.getlines(filename,module_globals)\n \n if action ==\"error\":\n  raise message\n  \n if action ==\"once\":\n  registry[key]=1\n  oncekey=(text,category)\n  if onceregistry.get(oncekey):\n   return\n  onceregistry[oncekey]=1\n elif action ==\"always\":\n  pass\n elif action ==\"module\":\n  registry[key]=1\n  altkey=(text,category,0)\n  if registry.get(altkey):\n   return\n  registry[altkey]=1\n elif action ==\"default\":\n  registry[key]=1\n else :\n \n  raise RuntimeError(\n  \"Unrecognized action (%r) in warnings.filters:\\n %s\"%\n  (action,item))\n  \n msg=WarningMessage(message,category,filename,lineno,source)\n _showwarnmsg(msg)\n \n \nclass WarningMessage(object):\n\n _WARNING_DETAILS=(\"message\",\"category\",\"filename\",\"lineno\",\"file\",\n \"line\",\"source\")\n \n def __init__(self,message,category,filename,lineno,file=None ,\n line=None ,source=None ):\n  self.message=message\n  self.category=category\n  self.filename=filename\n  self.lineno=lineno\n  self.file=file\n  self.line=line\n  self.source=source\n  self._category_name=category.__name__ if category else None\n  \n def __str__(self):\n  return (\"{message : %r, category : %r, filename : %r, lineno : %s, \"\n  \"line : %r}\"%(self.message,self._category_name,\n  self.filename,self.lineno,self.line))\n  \n  \nclass catch_warnings(object):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*,record=False ,module=None ):\n  ''\n\n\n\n\n\n  \n  self._record=record\n  self._module=sys.modules['warnings']if module is None else module\n  self._entered=False\n  \n def __repr__(self):\n  args=[]\n  if self._record:\n   args.append(\"record=True\")\n  if self._module is not sys.modules['warnings']:\n   args.append(\"module=%r\"%self._module)\n  name=type(self).__name__\n  return \"%s(%s)\"%(name,\", \".join(args))\n  \n def __enter__(self):\n  if self._entered:\n   raise RuntimeError(\"Cannot enter %r twice\"%self)\n  self._entered=True\n  self._filters=self._module.filters\n  self._module.filters=self._filters[:]\n  self._module._filters_mutated()\n  self._showwarning=self._module.showwarning\n  self._showwarnmsg_impl=self._module._showwarnmsg_impl\n  if self._record:\n   log=[]\n   self._module._showwarnmsg_impl=log.append\n   \n   \n   self._module.showwarning=self._module._showwarning_orig\n   return log\n  else :\n   return None\n   \n def __exit__(self,*exc_info):\n  if not self._entered:\n   raise RuntimeError(\"Cannot exit %r without entering first\"%self)\n  self._module.filters=self._filters\n  self._module._filters_mutated()\n  self._module.showwarning=self._showwarning\n  self._module._showwarnmsg_impl=self._showwarnmsg_impl\n  \n  \n  \ndef _warn_unawaited_coroutine(coro):\n msg_lines=[\n f\"coroutine '{coro.__qualname__}' was never awaited\\n\"\n ]\n if coro.cr_origin is not None :\n  import linecache,traceback\n  def extract():\n   for filename,lineno,funcname in reversed(coro.cr_origin):\n    line=linecache.getline(filename,lineno)\n    yield (filename,lineno,funcname,line)\n  msg_lines.append(\"Coroutine created at (most recent call last)\\n\")\n  msg_lines +=traceback.format_list(list(extract()))\n msg=\"\".join(msg_lines).rstrip(\"\\n\")\n \n \n \n \n \n \n warn(msg,category=RuntimeWarning,stacklevel=2,source=coro)\n \n \n \n \n \n \n \n \n \n \ntry :\n from _warnings import (filters,_defaultaction,_onceregistry,\n warn,warn_explicit,_filters_mutated)\n defaultaction=_defaultaction\n onceregistry=_onceregistry\n _warnings_defaults=True\nexcept ImportError:\n filters=[]\n defaultaction=\"default\"\n onceregistry={}\n \n _filters_version=1\n \n def _filters_mutated():\n  global _filters_version\n  _filters_version +=1\n  \n _warnings_defaults=False\n \n \n \n_processoptions(sys.warnoptions)\nif not _warnings_defaults:\n\n if not hasattr(sys,'gettotalrefcount'):\n  filterwarnings(\"default\",category=DeprecationWarning,\n  module=\"__main__\",append=1)\n  simplefilter(\"ignore\",category=DeprecationWarning,append=1)\n  simplefilter(\"ignore\",category=PendingDeprecationWarning,append=1)\n  simplefilter(\"ignore\",category=ImportWarning,append=1)\n  simplefilter(\"ignore\",category=ResourceWarning,append=1)\n  \ndel _warnings_defaults\n", ["_warnings", "linecache", "re", "sys", "traceback", "tracemalloc"]], "stringprep": [".py", "\n''\n\n\n\n\n\nfrom unicodedata import ucd_3_2_0 as unicodedata\n\nassert unicodedata.unidata_version =='3.2.0'\n\ndef in_table_a1(code):\n if unicodedata.category(code)!='Cn':return False\n c=ord(code)\n if 0xFDD0 <=c <0xFDF0:return False\n return (c&0xFFFF)not in (0xFFFE,0xFFFF)\n \n \nb1_set=set([173,847,6150,6155,6156,6157,8203,8204,8205,8288,65279]+list(range(65024,65040)))\ndef in_table_b1(code):\n return ord(code)in b1_set\n \n \nb3_exceptions={\n0xb5:'\\u03bc',0xdf:'ss',0x130:'i\\u0307',0x149:'\\u02bcn',\n0x17f:'s',0x1f0:'j\\u030c',0x345:'\\u03b9',0x37a:' \\u03b9',\n0x390:'\\u03b9\\u0308\\u0301',0x3b0:'\\u03c5\\u0308\\u0301',0x3c2:'\\u03c3',0x3d0:'\\u03b2',\n0x3d1:'\\u03b8',0x3d2:'\\u03c5',0x3d3:'\\u03cd',0x3d4:'\\u03cb',\n0x3d5:'\\u03c6',0x3d6:'\\u03c0',0x3f0:'\\u03ba',0x3f1:'\\u03c1',\n0x3f2:'\\u03c3',0x3f5:'\\u03b5',0x587:'\\u0565\\u0582',0x1e96:'h\\u0331',\n0x1e97:'t\\u0308',0x1e98:'w\\u030a',0x1e99:'y\\u030a',0x1e9a:'a\\u02be',\n0x1e9b:'\\u1e61',0x1f50:'\\u03c5\\u0313',0x1f52:'\\u03c5\\u0313\\u0300',0x1f54:'\\u03c5\\u0313\\u0301',\n0x1f56:'\\u03c5\\u0313\\u0342',0x1f80:'\\u1f00\\u03b9',0x1f81:'\\u1f01\\u03b9',0x1f82:'\\u1f02\\u03b9',\n0x1f83:'\\u1f03\\u03b9',0x1f84:'\\u1f04\\u03b9',0x1f85:'\\u1f05\\u03b9',0x1f86:'\\u1f06\\u03b9',\n0x1f87:'\\u1f07\\u03b9',0x1f88:'\\u1f00\\u03b9',0x1f89:'\\u1f01\\u03b9',0x1f8a:'\\u1f02\\u03b9',\n0x1f8b:'\\u1f03\\u03b9',0x1f8c:'\\u1f04\\u03b9',0x1f8d:'\\u1f05\\u03b9',0x1f8e:'\\u1f06\\u03b9',\n0x1f8f:'\\u1f07\\u03b9',0x1f90:'\\u1f20\\u03b9',0x1f91:'\\u1f21\\u03b9',0x1f92:'\\u1f22\\u03b9',\n0x1f93:'\\u1f23\\u03b9',0x1f94:'\\u1f24\\u03b9',0x1f95:'\\u1f25\\u03b9',0x1f96:'\\u1f26\\u03b9',\n0x1f97:'\\u1f27\\u03b9',0x1f98:'\\u1f20\\u03b9',0x1f99:'\\u1f21\\u03b9',0x1f9a:'\\u1f22\\u03b9',\n0x1f9b:'\\u1f23\\u03b9',0x1f9c:'\\u1f24\\u03b9',0x1f9d:'\\u1f25\\u03b9',0x1f9e:'\\u1f26\\u03b9',\n0x1f9f:'\\u1f27\\u03b9',0x1fa0:'\\u1f60\\u03b9',0x1fa1:'\\u1f61\\u03b9',0x1fa2:'\\u1f62\\u03b9',\n0x1fa3:'\\u1f63\\u03b9',0x1fa4:'\\u1f64\\u03b9',0x1fa5:'\\u1f65\\u03b9',0x1fa6:'\\u1f66\\u03b9',\n0x1fa7:'\\u1f67\\u03b9',0x1fa8:'\\u1f60\\u03b9',0x1fa9:'\\u1f61\\u03b9',0x1faa:'\\u1f62\\u03b9',\n0x1fab:'\\u1f63\\u03b9',0x1fac:'\\u1f64\\u03b9',0x1fad:'\\u1f65\\u03b9',0x1fae:'\\u1f66\\u03b9',\n0x1faf:'\\u1f67\\u03b9',0x1fb2:'\\u1f70\\u03b9',0x1fb3:'\\u03b1\\u03b9',0x1fb4:'\\u03ac\\u03b9',\n0x1fb6:'\\u03b1\\u0342',0x1fb7:'\\u03b1\\u0342\\u03b9',0x1fbc:'\\u03b1\\u03b9',0x1fbe:'\\u03b9',\n0x1fc2:'\\u1f74\\u03b9',0x1fc3:'\\u03b7\\u03b9',0x1fc4:'\\u03ae\\u03b9',0x1fc6:'\\u03b7\\u0342',\n0x1fc7:'\\u03b7\\u0342\\u03b9',0x1fcc:'\\u03b7\\u03b9',0x1fd2:'\\u03b9\\u0308\\u0300',0x1fd3:'\\u03b9\\u0308\\u0301',\n0x1fd6:'\\u03b9\\u0342',0x1fd7:'\\u03b9\\u0308\\u0342',0x1fe2:'\\u03c5\\u0308\\u0300',0x1fe3:'\\u03c5\\u0308\\u0301',\n0x1fe4:'\\u03c1\\u0313',0x1fe6:'\\u03c5\\u0342',0x1fe7:'\\u03c5\\u0308\\u0342',0x1ff2:'\\u1f7c\\u03b9',\n0x1ff3:'\\u03c9\\u03b9',0x1ff4:'\\u03ce\\u03b9',0x1ff6:'\\u03c9\\u0342',0x1ff7:'\\u03c9\\u0342\\u03b9',\n0x1ffc:'\\u03c9\\u03b9',0x20a8:'rs',0x2102:'c',0x2103:'\\xb0c',\n0x2107:'\\u025b',0x2109:'\\xb0f',0x210b:'h',0x210c:'h',\n0x210d:'h',0x2110:'i',0x2111:'i',0x2112:'l',\n0x2115:'n',0x2116:'no',0x2119:'p',0x211a:'q',\n0x211b:'r',0x211c:'r',0x211d:'r',0x2120:'sm',\n0x2121:'tel',0x2122:'tm',0x2124:'z',0x2128:'z',\n0x212c:'b',0x212d:'c',0x2130:'e',0x2131:'f',\n0x2133:'m',0x213e:'\\u03b3',0x213f:'\\u03c0',0x2145:'d',\n0x3371:'hpa',0x3373:'au',0x3375:'ov',0x3380:'pa',\n0x3381:'na',0x3382:'\\u03bca',0x3383:'ma',0x3384:'ka',\n0x3385:'kb',0x3386:'mb',0x3387:'gb',0x338a:'pf',\n0x338b:'nf',0x338c:'\\u03bcf',0x3390:'hz',0x3391:'khz',\n0x3392:'mhz',0x3393:'ghz',0x3394:'thz',0x33a9:'pa',\n0x33aa:'kpa',0x33ab:'mpa',0x33ac:'gpa',0x33b4:'pv',\n0x33b5:'nv',0x33b6:'\\u03bcv',0x33b7:'mv',0x33b8:'kv',\n0x33b9:'mv',0x33ba:'pw',0x33bb:'nw',0x33bc:'\\u03bcw',\n0x33bd:'mw',0x33be:'kw',0x33bf:'mw',0x33c0:'k\\u03c9',\n0x33c1:'m\\u03c9',0x33c3:'bq',0x33c6:'c\\u2215kg',0x33c7:'co.',\n0x33c8:'db',0x33c9:'gy',0x33cb:'hp',0x33cd:'kk',\n0x33ce:'km',0x33d7:'ph',0x33d9:'ppm',0x33da:'pr',\n0x33dc:'sv',0x33dd:'wb',0xfb00:'ff',0xfb01:'fi',\n0xfb02:'fl',0xfb03:'ffi',0xfb04:'ffl',0xfb05:'st',\n0xfb06:'st',0xfb13:'\\u0574\\u0576',0xfb14:'\\u0574\\u0565',0xfb15:'\\u0574\\u056b',\n0xfb16:'\\u057e\\u0576',0xfb17:'\\u0574\\u056d',0x1d400:'a',0x1d401:'b',\n0x1d402:'c',0x1d403:'d',0x1d404:'e',0x1d405:'f',\n0x1d406:'g',0x1d407:'h',0x1d408:'i',0x1d409:'j',\n0x1d40a:'k',0x1d40b:'l',0x1d40c:'m',0x1d40d:'n',\n0x1d40e:'o',0x1d40f:'p',0x1d410:'q',0x1d411:'r',\n0x1d412:'s',0x1d413:'t',0x1d414:'u',0x1d415:'v',\n0x1d416:'w',0x1d417:'x',0x1d418:'y',0x1d419:'z',\n0x1d434:'a',0x1d435:'b',0x1d436:'c',0x1d437:'d',\n0x1d438:'e',0x1d439:'f',0x1d43a:'g',0x1d43b:'h',\n0x1d43c:'i',0x1d43d:'j',0x1d43e:'k',0x1d43f:'l',\n0x1d440:'m',0x1d441:'n',0x1d442:'o',0x1d443:'p',\n0x1d444:'q',0x1d445:'r',0x1d446:'s',0x1d447:'t',\n0x1d448:'u',0x1d449:'v',0x1d44a:'w',0x1d44b:'x',\n0x1d44c:'y',0x1d44d:'z',0x1d468:'a',0x1d469:'b',\n0x1d46a:'c',0x1d46b:'d',0x1d46c:'e',0x1d46d:'f',\n0x1d46e:'g',0x1d46f:'h',0x1d470:'i',0x1d471:'j',\n0x1d472:'k',0x1d473:'l',0x1d474:'m',0x1d475:'n',\n0x1d476:'o',0x1d477:'p',0x1d478:'q',0x1d479:'r',\n0x1d47a:'s',0x1d47b:'t',0x1d47c:'u',0x1d47d:'v',\n0x1d47e:'w',0x1d47f:'x',0x1d480:'y',0x1d481:'z',\n0x1d49c:'a',0x1d49e:'c',0x1d49f:'d',0x1d4a2:'g',\n0x1d4a5:'j',0x1d4a6:'k',0x1d4a9:'n',0x1d4aa:'o',\n0x1d4ab:'p',0x1d4ac:'q',0x1d4ae:'s',0x1d4af:'t',\n0x1d4b0:'u',0x1d4b1:'v',0x1d4b2:'w',0x1d4b3:'x',\n0x1d4b4:'y',0x1d4b5:'z',0x1d4d0:'a',0x1d4d1:'b',\n0x1d4d2:'c',0x1d4d3:'d',0x1d4d4:'e',0x1d4d5:'f',\n0x1d4d6:'g',0x1d4d7:'h',0x1d4d8:'i',0x1d4d9:'j',\n0x1d4da:'k',0x1d4db:'l',0x1d4dc:'m',0x1d4dd:'n',\n0x1d4de:'o',0x1d4df:'p',0x1d4e0:'q',0x1d4e1:'r',\n0x1d4e2:'s',0x1d4e3:'t',0x1d4e4:'u',0x1d4e5:'v',\n0x1d4e6:'w',0x1d4e7:'x',0x1d4e8:'y',0x1d4e9:'z',\n0x1d504:'a',0x1d505:'b',0x1d507:'d',0x1d508:'e',\n0x1d509:'f',0x1d50a:'g',0x1d50d:'j',0x1d50e:'k',\n0x1d50f:'l',0x1d510:'m',0x1d511:'n',0x1d512:'o',\n0x1d513:'p',0x1d514:'q',0x1d516:'s',0x1d517:'t',\n0x1d518:'u',0x1d519:'v',0x1d51a:'w',0x1d51b:'x',\n0x1d51c:'y',0x1d538:'a',0x1d539:'b',0x1d53b:'d',\n0x1d53c:'e',0x1d53d:'f',0x1d53e:'g',0x1d540:'i',\n0x1d541:'j',0x1d542:'k',0x1d543:'l',0x1d544:'m',\n0x1d546:'o',0x1d54a:'s',0x1d54b:'t',0x1d54c:'u',\n0x1d54d:'v',0x1d54e:'w',0x1d54f:'x',0x1d550:'y',\n0x1d56c:'a',0x1d56d:'b',0x1d56e:'c',0x1d56f:'d',\n0x1d570:'e',0x1d571:'f',0x1d572:'g',0x1d573:'h',\n0x1d574:'i',0x1d575:'j',0x1d576:'k',0x1d577:'l',\n0x1d578:'m',0x1d579:'n',0x1d57a:'o',0x1d57b:'p',\n0x1d57c:'q',0x1d57d:'r',0x1d57e:'s',0x1d57f:'t',\n0x1d580:'u',0x1d581:'v',0x1d582:'w',0x1d583:'x',\n0x1d584:'y',0x1d585:'z',0x1d5a0:'a',0x1d5a1:'b',\n0x1d5a2:'c',0x1d5a3:'d',0x1d5a4:'e',0x1d5a5:'f',\n0x1d5a6:'g',0x1d5a7:'h',0x1d5a8:'i',0x1d5a9:'j',\n0x1d5aa:'k',0x1d5ab:'l',0x1d5ac:'m',0x1d5ad:'n',\n0x1d5ae:'o',0x1d5af:'p',0x1d5b0:'q',0x1d5b1:'r',\n0x1d5b2:'s',0x1d5b3:'t',0x1d5b4:'u',0x1d5b5:'v',\n0x1d5b6:'w',0x1d5b7:'x',0x1d5b8:'y',0x1d5b9:'z',\n0x1d5d4:'a',0x1d5d5:'b',0x1d5d6:'c',0x1d5d7:'d',\n0x1d5d8:'e',0x1d5d9:'f',0x1d5da:'g',0x1d5db:'h',\n0x1d5dc:'i',0x1d5dd:'j',0x1d5de:'k',0x1d5df:'l',\n0x1d5e0:'m',0x1d5e1:'n',0x1d5e2:'o',0x1d5e3:'p',\n0x1d5e4:'q',0x1d5e5:'r',0x1d5e6:'s',0x1d5e7:'t',\n0x1d5e8:'u',0x1d5e9:'v',0x1d5ea:'w',0x1d5eb:'x',\n0x1d5ec:'y',0x1d5ed:'z',0x1d608:'a',0x1d609:'b',\n0x1d60a:'c',0x1d60b:'d',0x1d60c:'e',0x1d60d:'f',\n0x1d60e:'g',0x1d60f:'h',0x1d610:'i',0x1d611:'j',\n0x1d612:'k',0x1d613:'l',0x1d614:'m',0x1d615:'n',\n0x1d616:'o',0x1d617:'p',0x1d618:'q',0x1d619:'r',\n0x1d61a:'s',0x1d61b:'t',0x1d61c:'u',0x1d61d:'v',\n0x1d61e:'w',0x1d61f:'x',0x1d620:'y',0x1d621:'z',\n0x1d63c:'a',0x1d63d:'b',0x1d63e:'c',0x1d63f:'d',\n0x1d640:'e',0x1d641:'f',0x1d642:'g',0x1d643:'h',\n0x1d644:'i',0x1d645:'j',0x1d646:'k',0x1d647:'l',\n0x1d648:'m',0x1d649:'n',0x1d64a:'o',0x1d64b:'p',\n0x1d64c:'q',0x1d64d:'r',0x1d64e:'s',0x1d64f:'t',\n0x1d650:'u',0x1d651:'v',0x1d652:'w',0x1d653:'x',\n0x1d654:'y',0x1d655:'z',0x1d670:'a',0x1d671:'b',\n0x1d672:'c',0x1d673:'d',0x1d674:'e',0x1d675:'f',\n0x1d676:'g',0x1d677:'h',0x1d678:'i',0x1d679:'j',\n0x1d67a:'k',0x1d67b:'l',0x1d67c:'m',0x1d67d:'n',\n0x1d67e:'o',0x1d67f:'p',0x1d680:'q',0x1d681:'r',\n0x1d682:'s',0x1d683:'t',0x1d684:'u',0x1d685:'v',\n0x1d686:'w',0x1d687:'x',0x1d688:'y',0x1d689:'z',\n0x1d6a8:'\\u03b1',0x1d6a9:'\\u03b2',0x1d6aa:'\\u03b3',0x1d6ab:'\\u03b4',\n0x1d6ac:'\\u03b5',0x1d6ad:'\\u03b6',0x1d6ae:'\\u03b7',0x1d6af:'\\u03b8',\n0x1d6b0:'\\u03b9',0x1d6b1:'\\u03ba',0x1d6b2:'\\u03bb',0x1d6b3:'\\u03bc',\n0x1d6b4:'\\u03bd',0x1d6b5:'\\u03be',0x1d6b6:'\\u03bf',0x1d6b7:'\\u03c0',\n0x1d6b8:'\\u03c1',0x1d6b9:'\\u03b8',0x1d6ba:'\\u03c3',0x1d6bb:'\\u03c4',\n0x1d6bc:'\\u03c5',0x1d6bd:'\\u03c6',0x1d6be:'\\u03c7',0x1d6bf:'\\u03c8',\n0x1d6c0:'\\u03c9',0x1d6d3:'\\u03c3',0x1d6e2:'\\u03b1',0x1d6e3:'\\u03b2',\n0x1d6e4:'\\u03b3',0x1d6e5:'\\u03b4',0x1d6e6:'\\u03b5',0x1d6e7:'\\u03b6',\n0x1d6e8:'\\u03b7',0x1d6e9:'\\u03b8',0x1d6ea:'\\u03b9',0x1d6eb:'\\u03ba',\n0x1d6ec:'\\u03bb',0x1d6ed:'\\u03bc',0x1d6ee:'\\u03bd',0x1d6ef:'\\u03be',\n0x1d6f0:'\\u03bf',0x1d6f1:'\\u03c0',0x1d6f2:'\\u03c1',0x1d6f3:'\\u03b8',\n0x1d6f4:'\\u03c3',0x1d6f5:'\\u03c4',0x1d6f6:'\\u03c5',0x1d6f7:'\\u03c6',\n0x1d6f8:'\\u03c7',0x1d6f9:'\\u03c8',0x1d6fa:'\\u03c9',0x1d70d:'\\u03c3',\n0x1d71c:'\\u03b1',0x1d71d:'\\u03b2',0x1d71e:'\\u03b3',0x1d71f:'\\u03b4',\n0x1d720:'\\u03b5',0x1d721:'\\u03b6',0x1d722:'\\u03b7',0x1d723:'\\u03b8',\n0x1d724:'\\u03b9',0x1d725:'\\u03ba',0x1d726:'\\u03bb',0x1d727:'\\u03bc',\n0x1d728:'\\u03bd',0x1d729:'\\u03be',0x1d72a:'\\u03bf',0x1d72b:'\\u03c0',\n0x1d72c:'\\u03c1',0x1d72d:'\\u03b8',0x1d72e:'\\u03c3',0x1d72f:'\\u03c4',\n0x1d730:'\\u03c5',0x1d731:'\\u03c6',0x1d732:'\\u03c7',0x1d733:'\\u03c8',\n0x1d734:'\\u03c9',0x1d747:'\\u03c3',0x1d756:'\\u03b1',0x1d757:'\\u03b2',\n0x1d758:'\\u03b3',0x1d759:'\\u03b4',0x1d75a:'\\u03b5',0x1d75b:'\\u03b6',\n0x1d75c:'\\u03b7',0x1d75d:'\\u03b8',0x1d75e:'\\u03b9',0x1d75f:'\\u03ba',\n0x1d760:'\\u03bb',0x1d761:'\\u03bc',0x1d762:'\\u03bd',0x1d763:'\\u03be',\n0x1d764:'\\u03bf',0x1d765:'\\u03c0',0x1d766:'\\u03c1',0x1d767:'\\u03b8',\n0x1d768:'\\u03c3',0x1d769:'\\u03c4',0x1d76a:'\\u03c5',0x1d76b:'\\u03c6',\n0x1d76c:'\\u03c7',0x1d76d:'\\u03c8',0x1d76e:'\\u03c9',0x1d781:'\\u03c3',\n0x1d790:'\\u03b1',0x1d791:'\\u03b2',0x1d792:'\\u03b3',0x1d793:'\\u03b4',\n0x1d794:'\\u03b5',0x1d795:'\\u03b6',0x1d796:'\\u03b7',0x1d797:'\\u03b8',\n0x1d798:'\\u03b9',0x1d799:'\\u03ba',0x1d79a:'\\u03bb',0x1d79b:'\\u03bc',\n0x1d79c:'\\u03bd',0x1d79d:'\\u03be',0x1d79e:'\\u03bf',0x1d79f:'\\u03c0',\n0x1d7a0:'\\u03c1',0x1d7a1:'\\u03b8',0x1d7a2:'\\u03c3',0x1d7a3:'\\u03c4',\n0x1d7a4:'\\u03c5',0x1d7a5:'\\u03c6',0x1d7a6:'\\u03c7',0x1d7a7:'\\u03c8',\n0x1d7a8:'\\u03c9',0x1d7bb:'\\u03c3',}\n\ndef map_table_b3(code):\n r=b3_exceptions.get(ord(code))\n if r is not None :return r\n return code.lower()\n \n \ndef map_table_b2(a):\n al=map_table_b3(a)\n b=unicodedata.normalize(\"NFKC\",al)\n bl=\"\".join([map_table_b3(ch)for ch in b])\n c=unicodedata.normalize(\"NFKC\",bl)\n if b !=c:\n  return c\n else :\n  return al\n  \n  \ndef in_table_c11(code):\n return code ==\" \"\n \n \ndef in_table_c12(code):\n return unicodedata.category(code)==\"Zs\"and code !=\" \"\n \ndef in_table_c11_c12(code):\n return unicodedata.category(code)==\"Zs\"\n \n \ndef in_table_c21(code):\n return ord(code)<128 and unicodedata.category(code)==\"Cc\"\n \nc22_specials=set([1757,1807,6158,8204,8205,8232,8233,65279]+list(range(8288,8292))+list(range(8298,8304))+list(range(65529,65533))+list(range(119155,119163)))\ndef in_table_c22(code):\n c=ord(code)\n if c <128:return False\n if unicodedata.category(code)==\"Cc\":return True\n return c in c22_specials\n \ndef in_table_c21_c22(code):\n return unicodedata.category(code)==\"Cc\"or\\\n ord(code)in c22_specials\n \n \ndef in_table_c3(code):\n return unicodedata.category(code)==\"Co\"\n \n \ndef in_table_c4(code):\n c=ord(code)\n if c <0xFDD0:return False\n if c <0xFDF0:return True\n return (ord(code)&0xFFFF)in (0xFFFE,0xFFFF)\n \n \ndef in_table_c5(code):\n return unicodedata.category(code)==\"Cs\"\n \n \nc6_set=set(range(65529,65534))\ndef in_table_c6(code):\n return ord(code)in c6_set\n \n \nc7_set=set(range(12272,12284))\ndef in_table_c7(code):\n return ord(code)in c7_set\n \n \nc8_set=set([832,833,8206,8207]+list(range(8234,8239))+list(range(8298,8304)))\ndef in_table_c8(code):\n return ord(code)in c8_set\n \n \nc9_set=set([917505]+list(range(917536,917632)))\ndef in_table_c9(code):\n return ord(code)in c9_set\n \n \ndef in_table_d1(code):\n return unicodedata.bidirectional(code)in (\"R\",\"AL\")\n \n \ndef in_table_d2(code):\n return unicodedata.bidirectional(code)==\"L\"\n", ["unicodedata"]], "_abcoll": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nDON'T USE THIS MODULE DIRECTLY!  The classes here should be imported\nvia collections; they are defined here only to alleviate certain\nbootstrapping issues.  Unit tests are in test_collections.\n\"\"\"\n\n\n\n\nimport sys\n\n__all__=[\"Hashable\",\"Iterable\",\"Iterator\",\n\"Sized\",\"Container\",\"Callable\",\n\"Set\",\"MutableSet\",\n\"Mapping\",\"MutableMapping\",\n\"MappingView\",\"KeysView\",\"ItemsView\",\"ValuesView\",\n\"Sequence\",\"MutableSequence\",\n\"ByteString\",\n]\n\n\"\"\"\n### collection related types which are not exposed through builtin ###\n## iterators ##\n#fixme brython\n#bytes_iterator = type(iter(b''))\nbytes_iterator = type(iter(''))\n#fixme brython\n#bytearray_iterator = type(iter(bytearray()))\n#callable_iterator = ???\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n## views ##\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n## misc ##\ndict_proxy = type(type.__dict__)\n\"\"\"\n\ndef abstractmethod(self):\n return self\n \n \n \n \n \nclass Iterable:\n\n @abstractmethod\n def __iter__(self):\n  while False :\n   yield None\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Iterable:\n   if any(\"__iter__\"in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \nclass Sized:\n\n @abstractmethod\n def __len__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Sized:\n   if any(\"__len__\"in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \nclass Container:\n\n @abstractmethod\n def __contains__(self,x):\n  return False\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Container:\n   if any(\"__contains__\"in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \n  \nclass Mapping(Sized,Iterable,Container):\n\n @abstractmethod\n def __getitem__(self,key):\n  raise KeyError\n  \n def get(self,key,default=None ):\n  try :\n   return self[key]\n  except KeyError:\n   return default\n   \n def __contains__(self,key):\n  try :\n   self[key]\n  except KeyError:\n   return False\n  else :\n   return True\n   \n def keys(self):\n  return KeysView(self)\n  \n def items(self):\n  return ItemsView(self)\n  \n def values(self):\n  return ValuesView(self)\n  \n def __eq__(self,other):\n  if not isinstance(other,Mapping):\n   return NotImplemented\n  return dict(self.items())==dict(other.items())\n  \n def __ne__(self,other):\n  return not (self ==other)\n  \n  \nclass MutableMapping(Mapping):\n\n @abstractmethod\n def __setitem__(self,key,value):\n  raise KeyError\n  \n @abstractmethod\n def __delitem__(self,key):\n  raise KeyError\n  \n __marker=object()\n \n def pop(self,key,default=__marker):\n  try :\n   value=self[key]\n  except KeyError:\n   if default is self.__marker:\n    raise\n   return default\n  else :\n   del self[key]\n   return value\n   \n def popitem(self):\n  try :\n   key=next(iter(self))\n  except StopIteration:\n   raise KeyError\n  value=self[key]\n  del self[key]\n  return key,value\n  \n def clear(self):\n  try :\n   while True :\n    self.popitem()\n  except KeyError:\n   pass\n   \n def update(*args,**kwds):\n  if len(args)>2:\n   raise TypeError(\"update() takes at most 2 positional \"\n   \"arguments ({} given)\".format(len(args)))\n  elif not args:\n   raise TypeError(\"update() takes at least 1 argument (0 given)\")\n  self=args[0]\n  other=args[1]if len(args)>=2 else ()\n  \n  if isinstance(other,Mapping):\n   for key in other:\n    self[key]=other[key]\n  elif hasattr(other,\"keys\"):\n   for key in other.keys():\n    self[key]=other[key]\n  else :\n   for key,value in other:\n    self[key]=value\n  for key,value in kwds.items():\n   self[key]=value\n   \n def setdefault(self,key,default=None ):\n  try :\n   return self[key]\n  except KeyError:\n   self[key]=default\n  return default\n  \n  \n", ["sys"]], "types": [".py", "''\n\n\nimport sys\n\n\n\n\n\n\ndef _f():pass\nFunctionType=type(_f)\nLambdaType=type(lambda :None )\nCodeType=type(_f.__code__)\nMappingProxyType=type(type.__dict__)\nSimpleNamespace=type(sys.implementation)\n\ndef _cell_factory():\n a=1\n def f():\n  nonlocal a\n return f.__closure__[0]\nCellType=type(_cell_factory())\n\ndef _g():\n yield 1\nGeneratorType=type(_g())\n\nasync def _c():pass\n_c=_c()\nCoroutineType=type(_c)\n_c.close()\n\nasync def _ag():\n yield\n_ag=_ag()\nAsyncGeneratorType=type(_ag)\n\nclass _C:\n def _m(self):pass\nMethodType=type(_C()._m)\n\nBuiltinFunctionType=type(len)\nBuiltinMethodType=type([].append)\n\nWrapperDescriptorType=type(object.__init__)\nMethodWrapperType=type(object().__str__)\nMethodDescriptorType=type(str.join)\nClassMethodDescriptorType=type(dict.__dict__['fromkeys'])\n\nModuleType=type(sys)\n\ntry :\n raise TypeError\nexcept TypeError:\n tb=sys.exc_info()[2]\n TracebackType=type(tb)\n FrameType=type(tb.tb_frame)\n tb=None ;del tb\n \n \nGetSetDescriptorType=type(FunctionType.__code__)\nMemberDescriptorType=type(FunctionType.__globals__)\n\ndel sys,_f,_g,_C,_c,_ag\n\n\n\ndef new_class(name,bases=(),kwds=None ,exec_body=None ):\n ''\n resolved_bases=resolve_bases(bases)\n meta,ns,kwds=prepare_class(name,resolved_bases,kwds)\n if exec_body is not None :\n  exec_body(ns)\n if resolved_bases is not bases:\n  ns['__orig_bases__']=bases\n return meta(name,resolved_bases,ns,**kwds)\n \ndef resolve_bases(bases):\n ''\n new_bases=list(bases)\n updated=False\n shift=0\n for i,base in enumerate(bases):\n  if isinstance(base,type):\n   continue\n  if not hasattr(base,\"__mro_entries__\"):\n   continue\n  new_base=base.__mro_entries__(bases)\n  updated=True\n  if not isinstance(new_base,tuple):\n   raise TypeError(\"__mro_entries__ must return a tuple\")\n  else :\n   new_bases[i+shift:i+shift+1]=new_base\n   shift +=len(new_base)-1\n if not updated:\n  return bases\n return tuple(new_bases)\n \ndef prepare_class(name,bases=(),kwds=None ):\n ''\n\n\n\n\n\n\n\n\n \n if kwds is None :\n  kwds={}\n else :\n  kwds=dict(kwds)\n if 'metaclass'in kwds:\n  meta=kwds.pop('metaclass')\n else :\n  if bases:\n   meta=type(bases[0])\n  else :\n   meta=type\n if isinstance(meta,type):\n \n \n  meta=_calculate_meta(meta,bases)\n if hasattr(meta,'__prepare__'):\n  ns=meta.__prepare__(name,bases,**kwds)\n else :\n  ns={}\n return meta,ns,kwds\n \ndef _calculate_meta(meta,bases):\n ''\n winner=meta\n for base in bases:\n  base_meta=type(base)\n  if issubclass(winner,base_meta):\n   continue\n  if issubclass(base_meta,winner):\n   winner=base_meta\n   continue\n   \n  raise TypeError(\"metaclass conflict: \"\n  \"the metaclass of a derived class \"\n  \"must be a (non-strict) subclass \"\n  \"of the metaclasses of all its bases\")\n return winner\n \nclass DynamicClassAttribute:\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,fget=None ,fset=None ,fdel=None ,doc=None ):\n  self.fget=fget\n  self.fset=fset\n  self.fdel=fdel\n  \n  self.__doc__=doc or fget.__doc__\n  self.overwrite_doc=doc is None\n  \n  self.__isabstractmethod__=bool(getattr(fget,'__isabstractmethod__',False ))\n  \n def __get__(self,instance,ownerclass=None ):\n  if instance is None :\n   if self.__isabstractmethod__:\n    return self\n   raise AttributeError()\n  elif self.fget is None :\n   raise AttributeError(\"unreadable attribute\")\n  return self.fget(instance)\n  \n def __set__(self,instance,value):\n  if self.fset is None :\n   raise AttributeError(\"can't set attribute\")\n  self.fset(instance,value)\n  \n def __delete__(self,instance):\n  if self.fdel is None :\n   raise AttributeError(\"can't delete attribute\")\n  self.fdel(instance)\n  \n def getter(self,fget):\n  fdoc=fget.__doc__ if self.overwrite_doc else None\n  result=type(self)(fget,self.fset,self.fdel,fdoc or self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n def setter(self,fset):\n  result=type(self)(self.fget,fset,self.fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n def deleter(self,fdel):\n  result=type(self)(self.fget,self.fset,fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n  \nclass _GeneratorWrapper:\n\n def __init__(self,gen):\n  self.__wrapped=gen\n  self.__isgen=gen.__class__ is GeneratorType\n  self.__name__=getattr(gen,'__name__',None )\n  self.__qualname__=getattr(gen,'__qualname__',None )\n def send(self,val):\n  return self.__wrapped.send(val)\n def throw(self,tp,*rest):\n  return self.__wrapped.throw(tp,*rest)\n def close(self):\n  return self.__wrapped.close()\n @property\n def gi_code(self):\n  return self.__wrapped.gi_code\n @property\n def gi_frame(self):\n  return self.__wrapped.gi_frame\n @property\n def gi_running(self):\n  return self.__wrapped.gi_running\n @property\n def gi_yieldfrom(self):\n  return self.__wrapped.gi_yieldfrom\n cr_code=gi_code\n cr_frame=gi_frame\n cr_running=gi_running\n cr_await=gi_yieldfrom\n def __next__(self):\n  return next(self.__wrapped)\n def __iter__(self):\n  if self.__isgen:\n   return self.__wrapped\n  return self\n __await__=__iter__\n \ndef coroutine(func):\n ''\n \n if not callable(func):\n  raise TypeError('types.coroutine() expects a callable')\n  \n if (func.__class__ is FunctionType and\n getattr(func,'__code__',None ).__class__ is CodeType):\n \n  co_flags=func.__code__.co_flags\n  \n  \n  \n  if co_flags&0x180:\n   return func\n   \n   \n   \n  if co_flags&0x20:\n  \n   co=func.__code__\n   \n   func.__code__=co.replace(co_flags=co.co_flags |0x100)\n   return func\n   \n   \n   \n   \n   \n   \n import functools\n import _collections_abc\n @functools.wraps(func)\n def wrapped(*args,**kwargs):\n  coro=func(*args,**kwargs)\n  if (coro.__class__ is CoroutineType or\n  coro.__class__ is GeneratorType and coro.gi_code.co_flags&0x100):\n  \n   return coro\n  if (isinstance(coro,_collections_abc.Generator)and\n  not isinstance(coro,_collections_abc.Coroutine)):\n  \n  \n  \n   return _GeneratorWrapper(coro)\n   \n   \n  return coro\n  \n return wrapped\n \n \n__all__=[n for n in globals()if n[:1]!='_']\n", ["_collections_abc", "functools", "sys"]], "decimal": [".py", "\ntry :\n from _decimal import *\n from _decimal import __doc__\n from _decimal import __version__\n from _decimal import __libmpdec_version__\nexcept ImportError:\n from _pydecimal import *\n from _pydecimal import __doc__\n from _pydecimal import __version__\n from _pydecimal import __libmpdec_version__\n", ["_decimal", "_pydecimal"]], "numbers": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) for numbers, according to PEP 3141.\n\nTODO: Fill out more detailed documentation on the operators.\"\"\"\n\nfrom abc import ABCMeta,abstractmethod\n\n__all__=[\"Number\",\"Complex\",\"Real\",\"Rational\",\"Integral\"]\n\nclass Number(metaclass=ABCMeta):\n ''\n\n\n\n \n __slots__=()\n \n \n __hash__=None\n \n \n \n \n \n \n \n \n \n \nclass Complex(Number):\n ''\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __complex__(self):\n  ''\n  \n def __bool__(self):\n  ''\n  return self !=0\n  \n @property\n @abstractmethod\n def real(self):\n  ''\n\n\n  \n  raise NotImplementedError\n  \n @property\n @abstractmethod\n def imag(self):\n  ''\n\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __add__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __radd__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __neg__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __pos__(self):\n  ''\n  raise NotImplementedError\n  \n def __sub__(self,other):\n  ''\n  return self+-other\n  \n def __rsub__(self,other):\n  ''\n  return -self+other\n  \n @abstractmethod\n def __mul__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rmul__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __truediv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rtruediv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __pow__(self,exponent):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rpow__(self,base):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __abs__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def conjugate(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __eq__(self,other):\n  ''\n  raise NotImplementedError\n  \nComplex.register(complex)\n\n\nclass Real(Complex):\n ''\n\n\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __float__(self):\n  ''\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __trunc__(self):\n  ''\n\n\n\n\n\n\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __floor__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __ceil__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __round__(self,ndigits=None ):\n  ''\n\n\n\n  \n  raise NotImplementedError\n  \n def __divmod__(self,other):\n  ''\n\n\n\n  \n  return (self //other,self %other)\n  \n def __rdivmod__(self,other):\n  ''\n\n\n\n  \n  return (other //self,other %self)\n  \n @abstractmethod\n def __floordiv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rfloordiv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __mod__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rmod__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __lt__(self,other):\n  ''\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __le__(self,other):\n  ''\n  raise NotImplementedError\n  \n  \n def __complex__(self):\n  ''\n  return complex(float(self))\n  \n @property\n def real(self):\n  ''\n  return +self\n  \n @property\n def imag(self):\n  ''\n  return 0\n  \n def conjugate(self):\n  ''\n  return +self\n  \nReal.register(float)\n\n\nclass Rational(Real):\n ''\n \n __slots__=()\n \n @property\n @abstractmethod\n def numerator(self):\n  raise NotImplementedError\n  \n @property\n @abstractmethod\n def denominator(self):\n  raise NotImplementedError\n  \n  \n def __float__(self):\n  ''\n\n\n\n\n\n  \n  return self.numerator /self.denominator\n  \n  \nclass Integral(Rational):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __int__(self):\n  ''\n  raise NotImplementedError\n  \n def __index__(self):\n  ''\n  return int(self)\n  \n @abstractmethod\n def __pow__(self,exponent,modulus=None ):\n  ''\n\n\n\n\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __lshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rlshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rrshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __and__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rand__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __xor__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rxor__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __or__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __ror__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __invert__(self):\n  ''\n  raise NotImplementedError\n  \n  \n def __float__(self):\n  ''\n  return float(int(self))\n  \n @property\n def numerator(self):\n  ''\n  return +self\n  \n @property\n def denominator(self):\n  ''\n  return 1\n  \nIntegral.register(int)\n", ["abc"]], "weakref": [".py", "''\n\n\n\n\n\n\n\n\n\n\nfrom _weakref import (\ngetweakrefcount,\ngetweakrefs,\nref,\nproxy,\nCallableProxyType,\nProxyType,\nReferenceType,\n_remove_dead_weakref)\n\nfrom _weakrefset import WeakSet,_IterationGuard\n\nimport _collections_abc\nimport sys\nimport itertools\n\nProxyTypes=(ProxyType,CallableProxyType)\n\n__all__=[\"ref\",\"proxy\",\"getweakrefcount\",\"getweakrefs\",\n\"WeakKeyDictionary\",\"ReferenceType\",\"ProxyType\",\n\"CallableProxyType\",\"ProxyTypes\",\"WeakValueDictionary\",\n\"WeakSet\",\"WeakMethod\",\"finalize\"]\n\n\nclass WeakMethod(ref):\n ''\n\n\n \n \n __slots__=\"_func_ref\",\"_meth_type\",\"_alive\",\"__weakref__\"\n \n def __new__(cls,meth,callback=None ):\n  try :\n   obj=meth.__self__\n   func=meth.__func__\n  except AttributeError:\n   raise TypeError(\"argument should be a bound method, not {}\"\n   .format(type(meth)))from None\n  def _cb(arg):\n  \n  \n   self=self_wr()\n   if self._alive:\n    self._alive=False\n    if callback is not None :\n     callback(self)\n  self=ref.__new__(cls,obj,_cb)\n  self._func_ref=ref(func,_cb)\n  self._meth_type=type(meth)\n  self._alive=True\n  self_wr=ref(self)\n  return self\n  \n def __call__(self):\n  obj=super().__call__()\n  func=self._func_ref()\n  if obj is None or func is None :\n   return None\n  return self._meth_type(func,obj)\n  \n def __eq__(self,other):\n  if isinstance(other,WeakMethod):\n   if not self._alive or not other._alive:\n    return self is other\n   return ref.__eq__(self,other)and self._func_ref ==other._func_ref\n  return False\n  \n def __ne__(self,other):\n  if isinstance(other,WeakMethod):\n   if not self._alive or not other._alive:\n    return self is not other\n   return ref.__ne__(self,other)or self._func_ref !=other._func_ref\n  return True\n  \n __hash__=ref.__hash__\n \n \nclass WeakValueDictionary(_collections_abc.MutableMapping):\n ''\n\n\n\n \n \n \n \n \n \n \n def __init__(self,other=(),/,**kw):\n  def remove(wr,selfref=ref(self),_atomic_removal=_remove_dead_weakref):\n   self=selfref()\n   if self is not None :\n    if self._iterating:\n     self._pending_removals.append(wr.key)\n    else :\n    \n    \n     _atomic_removal(self.data,wr.key)\n  self._remove=remove\n  \n  self._pending_removals=[]\n  self._iterating=set()\n  self.data={}\n  self.update(other,**kw)\n  \n def _commit_removals(self):\n  l=self._pending_removals\n  d=self.data\n  \n  \n  while l:\n   key=l.pop()\n   _remove_dead_weakref(d,key)\n   \n def __getitem__(self,key):\n  if self._pending_removals:\n   self._commit_removals()\n  o=self.data[key]()\n  if o is None :\n   raise KeyError(key)\n  else :\n   return o\n   \n def __delitem__(self,key):\n  if self._pending_removals:\n   self._commit_removals()\n  del self.data[key]\n  \n def __len__(self):\n  if self._pending_removals:\n   self._commit_removals()\n  return len(self.data)\n  \n def __contains__(self,key):\n  if self._pending_removals:\n   self._commit_removals()\n  try :\n   o=self.data[key]()\n  except KeyError:\n   return False\n  return o is not None\n  \n def __repr__(self):\n  return \"<%s at %#x>\"%(self.__class__.__name__,id(self))\n  \n def __setitem__(self,key,value):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data[key]=KeyedRef(value,self._remove,key)\n  \n def copy(self):\n  if self._pending_removals:\n   self._commit_removals()\n  new=WeakValueDictionary()\n  with _IterationGuard(self):\n   for key,wr in self.data.items():\n    o=wr()\n    if o is not None :\n     new[key]=o\n  return new\n  \n __copy__=copy\n \n def __deepcopy__(self,memo):\n  from copy import deepcopy\n  if self._pending_removals:\n   self._commit_removals()\n  new=self.__class__()\n  with _IterationGuard(self):\n   for key,wr in self.data.items():\n    o=wr()\n    if o is not None :\n     new[deepcopy(key,memo)]=o\n  return new\n  \n def get(self,key,default=None ):\n  if self._pending_removals:\n   self._commit_removals()\n  try :\n   wr=self.data[key]\n  except KeyError:\n   return default\n  else :\n   o=wr()\n   if o is None :\n   \n    return default\n   else :\n    return o\n    \n def items(self):\n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   for k,wr in self.data.items():\n    v=wr()\n    if v is not None :\n     yield k,v\n     \n def keys(self):\n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   for k,wr in self.data.items():\n    if wr()is not None :\n     yield k\n     \n __iter__=keys\n \n def itervaluerefs(self):\n  ''\n\n\n\n\n\n\n\n  \n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   yield from self.data.values()\n   \n def values(self):\n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   for wr in self.data.values():\n    obj=wr()\n    if obj is not None :\n     yield obj\n     \n def popitem(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True :\n   key,wr=self.data.popitem()\n   o=wr()\n   if o is not None :\n    return key,o\n    \n def pop(self,key,*args):\n  if self._pending_removals:\n   self._commit_removals()\n  try :\n   o=self.data.pop(key)()\n  except KeyError:\n   o=None\n  if o is None :\n   if args:\n    return args[0]\n   else :\n    raise KeyError(key)\n  else :\n   return o\n   \n def setdefault(self,key,default=None ):\n  try :\n   o=self.data[key]()\n  except KeyError:\n   o=None\n  if o is None :\n   if self._pending_removals:\n    self._commit_removals()\n   self.data[key]=KeyedRef(default,self._remove,key)\n   return default\n  else :\n   return o\n   \n def update(self,other=None ,/,**kwargs):\n  if self._pending_removals:\n   self._commit_removals()\n  d=self.data\n  if other is not None :\n   if not hasattr(other,\"items\"):\n    other=dict(other)\n   for key,o in other.items():\n    d[key]=KeyedRef(o,self._remove,key)\n  for key,o in kwargs.items():\n   d[key]=KeyedRef(o,self._remove,key)\n   \n def valuerefs(self):\n  ''\n\n\n\n\n\n\n\n  \n  if self._pending_removals:\n   self._commit_removals()\n  return list(self.data.values())\n  \n  \nclass KeyedRef(ref):\n ''\n\n\n\n\n\n\n \n \n __slots__=\"key\",\n \n def __new__(type,ob,callback,key):\n  self=ref.__new__(type,ob,callback)\n  self.key=key\n  return self\n  \n def __init__(self,ob,callback,key):\n  super().__init__(ob,callback)\n  \n  \nclass WeakKeyDictionary(_collections_abc.MutableMapping):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,dict=None ):\n  self.data={}\n  def remove(k,selfref=ref(self)):\n   self=selfref()\n   if self is not None :\n    if self._iterating:\n     self._pending_removals.append(k)\n    else :\n     del self.data[k]\n  self._remove=remove\n  \n  self._pending_removals=[]\n  self._iterating=set()\n  self._dirty_len=False\n  if dict is not None :\n   self.update(dict)\n   \n def _commit_removals(self):\n \n \n \n \n  l=self._pending_removals\n  d=self.data\n  while l:\n   try :\n    del d[l.pop()]\n   except KeyError:\n    pass\n    \n def _scrub_removals(self):\n  d=self.data\n  self._pending_removals=[k for k in self._pending_removals if k in d]\n  self._dirty_len=False\n  \n def __delitem__(self,key):\n  self._dirty_len=True\n  del self.data[ref(key)]\n  \n def __getitem__(self,key):\n  return self.data[ref(key)]\n  \n def __len__(self):\n  if self._dirty_len and self._pending_removals:\n  \n  \n   self._scrub_removals()\n  return len(self.data)-len(self._pending_removals)\n  \n def __repr__(self):\n  return \"<%s at %#x>\"%(self.__class__.__name__,id(self))\n  \n def __setitem__(self,key,value):\n  self.data[ref(key,self._remove)]=value\n  \n def copy(self):\n  new=WeakKeyDictionary()\n  with _IterationGuard(self):\n   for key,value in self.data.items():\n    o=key()\n    if o is not None :\n     new[o]=value\n  return new\n  \n __copy__=copy\n \n def __deepcopy__(self,memo):\n  from copy import deepcopy\n  new=self.__class__()\n  with _IterationGuard(self):\n   for key,value in self.data.items():\n    o=key()\n    if o is not None :\n     new[o]=deepcopy(value,memo)\n  return new\n  \n def get(self,key,default=None ):\n  return self.data.get(ref(key),default)\n  \n def __contains__(self,key):\n  try :\n   wr=ref(key)\n  except TypeError:\n   return False\n  return wr in self.data\n  \n def items(self):\n  with _IterationGuard(self):\n   for wr,value in self.data.items():\n    key=wr()\n    if key is not None :\n     yield key,value\n     \n def keys(self):\n  with _IterationGuard(self):\n   for wr in self.data:\n    obj=wr()\n    if obj is not None :\n     yield obj\n     \n __iter__=keys\n \n def values(self):\n  with _IterationGuard(self):\n   for wr,value in self.data.items():\n    if wr()is not None :\n     yield value\n     \n def keyrefs(self):\n  ''\n\n\n\n\n\n\n\n  \n  return list(self.data)\n  \n def popitem(self):\n  self._dirty_len=True\n  while True :\n   key,value=self.data.popitem()\n   o=key()\n   if o is not None :\n    return o,value\n    \n def pop(self,key,*args):\n  self._dirty_len=True\n  return self.data.pop(ref(key),*args)\n  \n def setdefault(self,key,default=None ):\n  return self.data.setdefault(ref(key,self._remove),default)\n  \n def update(self,dict=None ,/,**kwargs):\n  d=self.data\n  if dict is not None :\n   if not hasattr(dict,\"items\"):\n    dict=type({})(dict)\n   for key,value in dict.items():\n    d[ref(key,self._remove)]=value\n  if len(kwargs):\n   self.update(kwargs)\n   \n   \nclass finalize:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n __slots__=()\n _registry={}\n _shutdown=False\n _index_iter=itertools.count()\n _dirty=False\n _registered_with_atexit=False\n \n class _Info:\n  __slots__=(\"weakref\",\"func\",\"args\",\"kwargs\",\"atexit\",\"index\")\n  \n def __init__(*args,**kwargs):\n  if len(args)>=3:\n   self,obj,func,*args=args\n  elif not args:\n   raise TypeError(\"descriptor '__init__' of 'finalize' object \"\n   \"needs an argument\")\n  else :\n   if 'func'not in kwargs:\n    raise TypeError('finalize expected at least 2 positional '\n    'arguments, got %d'%(len(args)-1))\n   func=kwargs.pop('func')\n   if len(args)>=2:\n    self,obj,*args=args\n    import warnings\n    warnings.warn(\"Passing 'func' as keyword argument is deprecated\",\n    DeprecationWarning,stacklevel=2)\n   else :\n    if 'obj'not in kwargs:\n     raise TypeError('finalize expected at least 2 positional '\n     'arguments, got %d'%(len(args)-1))\n    obj=kwargs.pop('obj')\n    self,*args=args\n    import warnings\n    warnings.warn(\"Passing 'obj' as keyword argument is deprecated\",\n    DeprecationWarning,stacklevel=2)\n  args=tuple(args)\n  \n  if not self._registered_with_atexit:\n  \n  \n   import atexit\n   atexit.register(self._exitfunc)\n   finalize._registered_with_atexit=True\n  info=self._Info()\n  info.weakref=ref(obj,self)\n  info.func=func\n  info.args=args\n  info.kwargs=kwargs or None\n  info.atexit=True\n  info.index=next(self._index_iter)\n  self._registry[self]=info\n  finalize._dirty=True\n __init__.__text_signature__='($self, obj, func, /, *args, **kwargs)'\n \n def __call__(self,_=None ):\n  ''\n  \n  info=self._registry.pop(self,None )\n  if info and not self._shutdown:\n   return info.func(*info.args,**(info.kwargs or {}))\n   \n def detach(self):\n  ''\n  \n  info=self._registry.get(self)\n  obj=info and info.weakref()\n  if obj is not None and self._registry.pop(self,None ):\n   return (obj,info.func,info.args,info.kwargs or {})\n   \n def peek(self):\n  ''\n  \n  info=self._registry.get(self)\n  obj=info and info.weakref()\n  if obj is not None :\n   return (obj,info.func,info.args,info.kwargs or {})\n   \n @property\n def alive(self):\n  ''\n  return self in self._registry\n  \n @property\n def atexit(self):\n  ''\n  info=self._registry.get(self)\n  return bool(info)and info.atexit\n  \n @atexit.setter\n def atexit(self,value):\n  info=self._registry.get(self)\n  if info:\n   info.atexit=bool(value)\n   \n def __repr__(self):\n  info=self._registry.get(self)\n  obj=info and info.weakref()\n  if obj is None :\n   return '<%s object at %#x; dead>'%(type(self).__name__,id(self))\n  else :\n   return '<%s object at %#x; for %r at %#x>'%\\\n   (type(self).__name__,id(self),type(obj).__name__,id(obj))\n   \n @classmethod\n def _select_for_exit(cls):\n \n  L=[(f,i)for (f,i)in cls._registry.items()if i.atexit]\n  L.sort(key=lambda item:item[1].index)\n  return [f for (f,i)in L]\n  \n @classmethod\n def _exitfunc(cls):\n \n \n \n  reenable_gc=False\n  try :\n   if cls._registry:\n    import gc\n    if gc.isenabled():\n     reenable_gc=True\n     gc.disable()\n    pending=None\n    while True :\n     if pending is None or finalize._dirty:\n      pending=cls._select_for_exit()\n      finalize._dirty=False\n     if not pending:\n      break\n     f=pending.pop()\n     try :\n     \n     \n     \n     \n      f()\n     except Exception:\n      sys.excepthook(*sys.exc_info())\n     assert f not in cls._registry\n  finally :\n  \n   finalize._shutdown=True\n   if reenable_gc:\n    gc.enable()\n", ["_collections_abc", "_weakref", "_weakrefset", "atexit", "copy", "gc", "itertools", "sys", "warnings"]], "_weakrefset": [".py", "\n\n\n\nfrom _weakref import ref\n\n__all__=['WeakSet']\n\n\nclass _IterationGuard:\n\n\n\n\n\n def __init__(self,weakcontainer):\n \n  self.weakcontainer=ref(weakcontainer)\n  \n def __enter__(self):\n  w=self.weakcontainer()\n  if w is not None :\n   w._iterating.add(self)\n  return self\n  \n def __exit__(self,e,t,b):\n  w=self.weakcontainer()\n  if w is not None :\n   s=w._iterating\n   s.remove(self)\n   if not s:\n    w._commit_removals()\n    \n    \nclass WeakSet:\n def __init__(self,data=None ):\n  self.data=set()\n  def _remove(item,selfref=ref(self)):\n   self=selfref()\n   if self is not None :\n    if self._iterating:\n     self._pending_removals.append(item)\n    else :\n     self.data.discard(item)\n  self._remove=_remove\n  \n  self._pending_removals=[]\n  self._iterating=set()\n  if data is not None :\n   self.update(data)\n   \n def _commit_removals(self):\n  l=self._pending_removals\n  discard=self.data.discard\n  while l:\n   discard(l.pop())\n   \n def __iter__(self):\n  with _IterationGuard(self):\n   for itemref in self.data:\n    item=itemref()\n    if item is not None :\n    \n    \n     yield item\n     \n def __len__(self):\n  return len(self.data)-len(self._pending_removals)\n  \n def __contains__(self,item):\n  try :\n   wr=ref(item)\n  except TypeError:\n   return False\n  return wr in self.data\n  \n def __reduce__(self):\n  return (self.__class__,(list(self),),\n  getattr(self,'__dict__',None ))\n  \n def add(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.add(ref(item,self._remove))\n  \n def clear(self):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.clear()\n  \n def copy(self):\n  return self.__class__(self)\n  \n def pop(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True :\n   try :\n    itemref=self.data.pop()\n   except KeyError:\n    raise KeyError('pop from empty WeakSet')from None\n   item=itemref()\n   if item is not None :\n    return item\n    \n def remove(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.remove(ref(item))\n  \n def discard(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.discard(ref(item))\n  \n def update(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  for element in other:\n   self.add(element)\n   \n def __ior__(self,other):\n  self.update(other)\n  return self\n  \n def difference(self,other):\n  newset=self.copy()\n  newset.difference_update(other)\n  return newset\n __sub__=difference\n \n def difference_update(self,other):\n  self.__isub__(other)\n def __isub__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else :\n   self.data.difference_update(ref(item)for item in other)\n  return self\n  \n def intersection(self,other):\n  return self.__class__(item for item in other if item in self)\n __and__=intersection\n \n def intersection_update(self,other):\n  self.__iand__(other)\n def __iand__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.intersection_update(ref(item)for item in other)\n  return self\n  \n def issubset(self,other):\n  return self.data.issubset(ref(item)for item in other)\n __le__=issubset\n \n def __lt__(self,other):\n  return self.data <set(map(ref,other))\n  \n def issuperset(self,other):\n  return self.data.issuperset(ref(item)for item in other)\n __ge__=issuperset\n \n def __gt__(self,other):\n  return self.data >set(map(ref,other))\n  \n def __eq__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.data ==set(map(ref,other))\n  \n def symmetric_difference(self,other):\n  newset=self.copy()\n  newset.symmetric_difference_update(other)\n  return newset\n __xor__=symmetric_difference\n \n def symmetric_difference_update(self,other):\n  self.__ixor__(other)\n def __ixor__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else :\n   self.data.symmetric_difference_update(ref(item,self._remove)for item in other)\n  return self\n  \n def union(self,other):\n  return self.__class__(e for s in (self,other)for e in s)\n __or__=union\n \n def isdisjoint(self,other):\n  return len(self.intersection(other))==0\n  \n def __repr__(self):\n  return repr(self.data)\n", ["_weakref"]], "_collections": [".py", "\n\n\n\n\n\n\n\n\n\nimport operator\n\n\n\ndef _thread_ident():\n return -1\n \n \nn=30\nLFTLNK=n\nRGTLNK=n+1\nBLOCKSIZ=n+2\n\n\n\n\n\n\n\n\nclass deque:\n\n def __new__(cls,iterable=(),*args,**kw):\n \n \n  self=object.__new__(cls,*args,**kw)\n  self.clear()\n  return self\n  \n def __init__(self,iterable=(),maxlen=None ):\n  object.__init__(self)\n  self.clear()\n  if maxlen is not None :\n   if maxlen <0:\n    raise ValueError(\"maxlen must be non-negative\")\n  self._maxlen=maxlen\n  add=self.append\n  for elem in iterable:\n   add(elem)\n   \n @property\n def maxlen(self):\n  return self._maxlen\n  \n def clear(self):\n  self.right=self.left=[None ]*BLOCKSIZ\n  self.rightndx=n //2\n  self.leftndx=n //2+1\n  self.length=0\n  self.state=0\n  \n def append(self,x):\n  self.state +=1\n  self.rightndx +=1\n  if self.rightndx ==n:\n   newblock=[None ]*BLOCKSIZ\n   self.right[RGTLNK]=newblock\n   newblock[LFTLNK]=self.right\n   self.right=newblock\n   self.rightndx=0\n  self.length +=1\n  self.right[self.rightndx]=x\n  if self.maxlen is not None and self.length >self.maxlen:\n   self.popleft()\n   \n def appendleft(self,x):\n  self.state +=1\n  self.leftndx -=1\n  if self.leftndx ==-1:\n   newblock=[None ]*BLOCKSIZ\n   self.left[LFTLNK]=newblock\n   newblock[RGTLNK]=self.left\n   self.left=newblock\n   self.leftndx=n -1\n  self.length +=1\n  self.left[self.leftndx]=x\n  if self.maxlen is not None and self.length >self.maxlen:\n   self.pop()\n   \n def extend(self,iterable):\n  if iterable is self:\n   iterable=list(iterable)\n  for elem in iterable:\n   self.append(elem)\n   \n def extendleft(self,iterable):\n  if iterable is self:\n   iterable=list(iterable)\n  for elem in iterable:\n   self.appendleft(elem)\n   \n def pop(self):\n  if self.left is self.right and self.leftndx >self.rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x=self.right[self.rightndx]\n  self.right[self.rightndx]=None\n  self.length -=1\n  self.rightndx -=1\n  self.state +=1\n  if self.rightndx ==-1:\n   prevblock=self.right[LFTLNK]\n   if prevblock is None :\n   \n    self.rightndx=n //2\n    self.leftndx=n //2+1\n   else :\n    prevblock[RGTLNK]=None\n    self.right[LFTLNK]=None\n    self.right=prevblock\n    self.rightndx=n -1\n  return x\n  \n def popleft(self):\n  if self.left is self.right and self.leftndx >self.rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x=self.left[self.leftndx]\n  self.left[self.leftndx]=None\n  self.length -=1\n  self.leftndx +=1\n  self.state +=1\n  if self.leftndx ==n:\n   prevblock=self.left[RGTLNK]\n   if prevblock is None :\n   \n    self.rightndx=n //2\n    self.leftndx=n //2+1\n   else :\n    prevblock[LFTLNK]=None\n    self.left[RGTLNK]=None\n    self.left=prevblock\n    self.leftndx=0\n  return x\n  \n def count(self,value):\n  c=0\n  for item in self:\n   if item ==value:\n    c +=1\n  return c\n  \n def remove(self,value):\n \n  for i in range(len(self)):\n   if self[i]==value:\n    del self[i]\n    return\n  raise ValueError(\"deque.remove(x): x not in deque\")\n  \n def rotate(self,n=1):\n  length=len(self)\n  if length ==0:\n   return\n  halflen=(length+1)>>1\n  if n >halflen or n <-halflen:\n   n %=length\n   if n >halflen:\n    n -=length\n   elif n <-halflen:\n    n +=length\n  while n >0:\n   self.appendleft(self.pop())\n   n -=1\n  while n <0:\n   self.append(self.popleft())\n   n +=1\n   \n def reverse(self):\n  ''\n  leftblock=self.left\n  rightblock=self.right\n  leftindex=self.leftndx\n  rightindex=self.rightndx\n  for i in range(self.length //2):\n  \n   assert leftblock !=rightblock or leftindex <rightindex\n   \n   \n   (rightblock[rightindex],leftblock[leftindex])=(\n   leftblock[leftindex],rightblock[rightindex])\n   \n   \n   leftindex +=1\n   if leftindex ==n:\n    leftblock=leftblock[RGTLNK]\n    assert leftblock is not None\n    leftindex=0\n    \n    \n   rightindex -=1\n   if rightindex ==-1:\n    rightblock=rightblock[LFTLNK]\n    assert rightblock is not None\n    rightindex=n -1\n    \n def __repr__(self):\n  threadlocalattr='__repr'+str(_thread_ident())\n  if threadlocalattr in self.__dict__:\n   return 'deque([...])'\n  else :\n   self.__dict__[threadlocalattr]=True\n   try :\n    if self.maxlen is not None :\n     return 'deque(%r, maxlen=%s)'%(list(self),self.maxlen)\n    else :\n     return 'deque(%r)'%(list(self),)\n   finally :\n    del self.__dict__[threadlocalattr]\n    \n def __iter__(self):\n  return deque_iterator(self,self._iter_impl)\n  \n def _iter_impl(self,original_state,giveup):\n  if self.state !=original_state:\n   giveup()\n  block=self.left\n  while block:\n   l,r=0,n\n   if block is self.left:\n    l=self.leftndx\n   if block is self.right:\n    r=self.rightndx+1\n   for elem in block[l:r]:\n    yield elem\n    if self.state !=original_state:\n     giveup()\n   block=block[RGTLNK]\n   \n def __reversed__(self):\n  return deque_iterator(self,self._reversed_impl)\n  \n def _reversed_impl(self,original_state,giveup):\n  if self.state !=original_state:\n   giveup()\n  block=self.right\n  while block:\n   l,r=0,n\n   if block is self.left:\n    l=self.leftndx\n   if block is self.right:\n    r=self.rightndx+1\n   for elem in reversed(block[l:r]):\n    yield elem\n    if self.state !=original_state:\n     giveup()\n   block=block[LFTLNK]\n   \n def __len__(self):\n \n \n \n \n \n \n  return self.length\n  \n def __getref(self,index):\n  if index >=0:\n   block=self.left\n   while block:\n    l,r=0,n\n    if block is self.left:\n     l=self.leftndx\n    if block is self.right:\n     r=self.rightndx+1\n    span=r -l\n    if index <span:\n     return block,l+index\n    index -=span\n    block=block[RGTLNK]\n  else :\n   block=self.right\n   while block:\n    l,r=0,n\n    if block is self.left:\n     l=self.leftndx\n    if block is self.right:\n     r=self.rightndx+1\n    negative_span=l -r\n    if index >=negative_span:\n     return block,r+index\n    index -=negative_span\n    block=block[LFTLNK]\n  raise IndexError(\"deque index out of range\")\n  \n def __getitem__(self,index):\n  block,index=self.__getref(index)\n  return block[index]\n  \n def __setitem__(self,index,value):\n  block,index=self.__getref(index)\n  block[index]=value\n  \n def __delitem__(self,index):\n  length=len(self)\n  if index >=0:\n   if index >=length:\n    raise IndexError(\"deque index out of range\")\n   self.rotate(-index)\n   self.popleft()\n   self.rotate(index)\n  else :\n  \n   index=index ^(2 **31)\n   if index >=length:\n    raise IndexError(\"deque index out of range\")\n   self.rotate(index)\n   self.pop()\n   self.rotate(-index)\n   \n def __reduce_ex__(self,proto):\n  return type(self),(list(self),self.maxlen)\n  \n def __hash__(self):\n \n  raise TypeError(\"deque objects are unhashable\")\n  \n def __copy__(self):\n  return self.__class__(self,self.maxlen)\n  \n  \n def __eq__(self,other):\n  if isinstance(other,deque):\n   return list(self)==list(other)\n  else :\n   return NotImplemented\n   \n def __ne__(self,other):\n  if isinstance(other,deque):\n   return list(self)!=list(other)\n  else :\n   return NotImplemented\n   \n def __lt__(self,other):\n  if isinstance(other,deque):\n   return list(self)<list(other)\n  else :\n   return NotImplemented\n   \n def __le__(self,other):\n  if isinstance(other,deque):\n   return list(self)<=list(other)\n  else :\n   return NotImplemented\n   \n def __gt__(self,other):\n  if isinstance(other,deque):\n   return list(self)>list(other)\n  else :\n   return NotImplemented\n   \n def __ge__(self,other):\n  if isinstance(other,deque):\n   return list(self)>=list(other)\n  else :\n   return NotImplemented\n   \n def __iadd__(self,other):\n  self.extend(other)\n  return self\n  \n  \nclass deque_iterator(object):\n\n def __init__(self,deq,itergen):\n  self.counter=len(deq)\n  def giveup():\n   self.counter=0\n   \n   raise RuntimeError(\"deque mutated during iteration\")\n  self._gen=itergen(deq.state,giveup)\n  \n def __next__(self):\n  res=self._gen.__next__()\n  self.counter -=1\n  return res\n  \n def __iter__(self):\n  return self\n  \nclass defaultdict(dict):\n\n def __init__(self,*args,**kwds):\n  if len(args)>0:\n   default_factory=args[0]\n   args=args[1:]\n   if not callable(default_factory)and default_factory is not None :\n    raise TypeError(\"first argument must be callable\")\n  else :\n   default_factory=None\n  dict.__init__(self,*args,**kwds)\n  self.default_factory=default_factory\n  self.update(*args,**kwds)\n  super(defaultdict,self).__init__(*args,**kwds)\n  \n def __missing__(self,key):\n \n  if self.default_factory is None :\n   raise KeyError(key)\n  self[key]=value=self.default_factory()\n  return value\n  \n def __repr__(self,recurse=set()):\n  if id(self)in recurse:\n   return \"defaultdict(...)\"\n  try :\n   recurse.add(id(self))\n   return \"defaultdict(%s, %s)\"%(repr(self.default_factory),super(defaultdict,self).__repr__())\n  finally :\n   recurse.remove(id(self))\n   \n def copy(self):\n  return type(self)(self.default_factory,self)\n  \n def __copy__(self):\n  return self.copy()\n  \n def __reduce__(self):\n \n \n \n \n \n \n \n \n \n \n \n  return (type(self),(self.default_factory,),None ,None ,self.items())\n  \nfrom operator import itemgetter as _itemgetter\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\n\ndef namedtuple(typename,field_names,verbose=False ,rename=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n if isinstance(field_names,str):\n  field_names=field_names.replace(',',' ').split()\n field_names=tuple(map(str,field_names))\n if rename:\n  names=list(field_names)\n  seen=set()\n  for i,name in enumerate(names):\n   if (not min(c.isalnum()or c =='_'for c in name)or _iskeyword(name)\n   or not name or name[0].isdigit()or name.startswith('_')\n   or name in seen):\n    names[i]='_%d'%i\n   seen.add(name)\n  field_names=tuple(names)\n for name in (typename,)+field_names:\n  if not min(c.isalnum()or c =='_'for c in name):\n   raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r'%name)\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a keyword: %r'%name)\n  if name[0].isdigit():\n   raise ValueError('Type names and field names cannot start with a number: %r'%name)\n seen_names=set()\n for name in field_names:\n  if name.startswith('_')and not rename:\n   raise ValueError('Field names cannot start with an underscore: %r'%name)\n  if name in seen_names:\n   raise ValueError('Encountered duplicate field name: %r'%name)\n  seen_names.add(name)\n  \n  \n numfields=len(field_names)\n argtxt=repr(field_names).replace(\"'\",\"\")[1:-1]\n reprtxt=', '.join('%s=%%r'%name for name in field_names)\n \n template='''class %(typename)s(tuple):\n        '%(typename)s(%(argtxt)s)' \\n\n        __slots__ = () \\n\n        _fields = %(field_names)r \\n\n        def __new__(_cls, %(argtxt)s):\n            return tuple.__new__(_cls, (%(argtxt)s)) \\n\n        @classmethod\n        def _make(cls, iterable, new=tuple.__new__, len=len):\n            'Make a new %(typename)s object from a sequence or iterable'\n            result = new(cls, iterable)\n            if len(result) != %(numfields)d:\n                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))\n            return result \\n\n        def __repr__(self):\n            return '%(typename)s(%(reprtxt)s)' %% self \\n\n        def _asdict(self):\n            'Return a new dict which maps field names to their values'\n            return dict(zip(self._fields, self)) \\n\n        def _replace(_self, **kwds):\n            'Return a new %(typename)s object replacing specified fields with new values'\n            result = _self._make(map(kwds.pop, %(field_names)r, _self))\n            if kwds:\n                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())\n            return result \\n\n        def __getnewargs__(self):\n            return tuple(self) \\n\\n'''%locals()\n for i,name in enumerate(field_names):\n  template +='        %s = _property(_itemgetter(%d))\\n'%(name,i)\n  \n if verbose:\n  print(template)\n  \n  \n namespace=dict(_itemgetter=_itemgetter,__name__='namedtuple_%s'%typename,\n _property=property,_tuple=tuple)\n try :\n  exec(template,namespace)\n except SyntaxError as e:\n  raise SyntaxError(e.message+':\\n'+template)\n result=namespace[typename]\n \n \n \n \n \n try :\n  result.__module__=_sys._getframe(1).f_globals.get('__name__','__main__')\n except (AttributeError,ValueError):\n  pass\n  \n return result\n \nif __name__ =='__main__':\n Point=namedtuple('Point',['x','y'])\n p=Point(11,y=22)\n print(p[0]+p[1])\n x,y=p\n print(x,y)\n print(p.x+p.y)\n print(p)\n", ["keyword", "operator", "sys"]], "traceback": [".py", "''\n\nimport collections\nimport itertools\nimport linecache\nimport sys\n\n__all__=['extract_stack','extract_tb','format_exception',\n'format_exception_only','format_list','format_stack',\n'format_tb','print_exc','format_exc','print_exception',\n'print_last','print_stack','print_tb','clear_frames',\n'FrameSummary','StackSummary','TracebackException',\n'walk_stack','walk_tb']\n\n\n\n\n\ndef print_list(extracted_list,file=None ):\n ''\n \n if file is None :\n  file=sys.stderr\n for item in StackSummary.from_list(extracted_list).format():\n  print(item,file=file,end=\"\")\n  \ndef format_list(extracted_list):\n ''\n\n\n\n\n\n\n\n\n\n \n return StackSummary.from_list(extracted_list).format()\n \n \n \n \n \ndef print_tb(tb,limit=None ,file=None ):\n ''\n\n\n\n\n\n \n print_list(extract_tb(tb,limit=limit),file=file)\n \ndef format_tb(tb,limit=None ):\n ''\n return extract_tb(tb,limit=limit).format()\n \ndef extract_tb(tb,limit=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n \n return StackSummary.extract(walk_tb(tb),limit=limit)\n \n \n \n \n \n_cause_message=(\n\"\\nThe above exception was the direct cause \"\n\"of the following exception:\\n\\n\")\n\n_context_message=(\n\"\\nDuring handling of the above exception, \"\n\"another exception occurred:\\n\\n\")\n\n\ndef print_exception(etype,value,tb,limit=None ,file=None ,chain=True ):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n if file is None :\n  file=sys.stderr\n for line in TracebackException(\n type(value),value,tb,limit=limit).format(chain=chain):\n  print(line,file=file,end=\"\")\n  \n  \ndef format_exception(etype,value,tb,limit=None ,chain=True ):\n ''\n\n\n\n\n\n\n \n \n \n \n return list(TracebackException(\n type(value),value,tb,limit=limit).format(chain=chain))\n \n \ndef format_exception_only(etype,value):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return list(TracebackException(etype,value,None ).format_exception_only())\n \n \n \n \ndef _format_final_exc_line(etype,value):\n valuestr=_some_str(value)\n if value is None or not valuestr:\n  line=\"%s\\n\"%etype\n else :\n  line=\"%s: %s\\n\"%(etype,valuestr)\n return line\n \ndef _some_str(value):\n try :\n  return str(value)\n except :\n  return '<unprintable %s object>'%type(value).__name__\n  \n  \n  \ndef print_exc(limit=None ,file=None ,chain=True ):\n ''\n print_exception(*sys.exc_info(),limit=limit,file=file,chain=chain)\n \ndef format_exc(limit=None ,chain=True ):\n ''\n return \"\".join(format_exception(*sys.exc_info(),limit=limit,chain=chain))\n \ndef print_last(limit=None ,file=None ,chain=True ):\n ''\n \n if not hasattr(sys,\"last_type\"):\n  raise ValueError(\"no last exception\")\n print_exception(sys.last_type,sys.last_value,sys.last_traceback,\n limit,file,chain)\n \n \n \n \n \ndef print_stack(f=None ,limit=None ,file=None ):\n ''\n\n\n\n\n \n if f is None :\n  f=sys._getframe().f_back\n print_list(extract_stack(f,limit=limit),file=file)\n \n \ndef format_stack(f=None ,limit=None ):\n ''\n if f is None :\n  f=sys._getframe().f_back\n return format_list(extract_stack(f,limit=limit))\n \n \ndef extract_stack(f=None ,limit=None ):\n ''\n\n\n\n\n\n\n \n if f is None :\n  f=sys._getframe().f_back\n stack=StackSummary.extract(walk_stack(f),limit=limit)\n stack.reverse()\n return stack\n \n \ndef clear_frames(tb):\n ''\n while tb is not None :\n  try :\n   tb.tb_frame.clear()\n  except RuntimeError:\n  \n   pass\n  tb=tb.tb_next\n  \n  \nclass FrameSummary:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('filename','lineno','name','_line','locals')\n \n def __init__(self,filename,lineno,name,*,lookup_line=True ,\n locals=None ,line=None ):\n  ''\n\n\n\n\n\n\n\n  \n  self.filename=filename\n  self.lineno=lineno\n  self.name=name\n  self._line=line\n  if lookup_line:\n   self.line\n  self.locals={k:repr(v)for k,v in locals.items()}if locals else None\n  \n def __eq__(self,other):\n  if isinstance(other,FrameSummary):\n   return (self.filename ==other.filename and\n   self.lineno ==other.lineno and\n   self.name ==other.name and\n   self.locals ==other.locals)\n  if isinstance(other,tuple):\n   return (self.filename,self.lineno,self.name,self.line)==other\n  return NotImplemented\n  \n def __getitem__(self,pos):\n  return (self.filename,self.lineno,self.name,self.line)[pos]\n  \n def __iter__(self):\n  return iter([self.filename,self.lineno,self.name,self.line])\n  \n def __repr__(self):\n  return \"<FrameSummary file {filename}, line {lineno} in {name}>\".format(\n  filename=self.filename,lineno=self.lineno,name=self.name)\n  \n def __len__(self):\n  return 4\n  \n @property\n def line(self):\n  if self._line is None :\n   self._line=linecache.getline(self.filename,self.lineno).strip()\n  return self._line\n  \n  \ndef walk_stack(f):\n ''\n\n\n\n \n if f is None :\n  f=sys._getframe().f_back.f_back\n while f is not None :\n  yield f,f.f_lineno\n  f=f.f_back\n  \n  \ndef walk_tb(tb):\n ''\n\n\n\n \n while tb is not None :\n  yield tb.tb_frame,tb.tb_lineno\n  tb=tb.tb_next\n  \n  \n_RECURSIVE_CUTOFF=3\n\nclass StackSummary(list):\n ''\n \n @classmethod\n def extract(klass,frame_gen,*,limit=None ,lookup_lines=True ,\n capture_locals=False ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if limit is None :\n   limit=getattr(sys,'tracebacklimit',None )\n   if limit is not None and limit <0:\n    limit=0\n  if limit is not None :\n   if limit >=0:\n    frame_gen=itertools.islice(frame_gen,limit)\n   else :\n    frame_gen=collections.deque(frame_gen,maxlen=-limit)\n    \n  result=klass()\n  fnames=set()\n  for f,lineno in frame_gen:\n   co=f.f_code\n   filename=co.co_filename\n   name=co.co_name\n   \n   fnames.add(filename)\n   linecache.lazycache(filename,f.f_globals)\n   \n   if capture_locals:\n    f_locals=f.f_locals\n   else :\n    f_locals=None\n   result.append(FrameSummary(\n   filename,lineno,name,lookup_line=False ,locals=f_locals))\n  for filename in fnames:\n   linecache.checkcache(filename)\n   \n  if lookup_lines:\n   for f in result:\n    f.line\n  return result\n  \n @classmethod\n def from_list(klass,a_list):\n  ''\n\n\n  \n  \n  \n  \n  \n  result=StackSummary()\n  for frame in a_list:\n   if isinstance(frame,FrameSummary):\n    result.append(frame)\n   else :\n    filename,lineno,name,line=frame\n    result.append(FrameSummary(filename,lineno,name,line=line))\n  return result\n  \n def format(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  result=[]\n  last_file=None\n  last_line=None\n  last_name=None\n  count=0\n  for frame in self:\n   if (last_file is None or last_file !=frame.filename or\n   last_line is None or last_line !=frame.lineno or\n   last_name is None or last_name !=frame.name):\n    if count >_RECURSIVE_CUTOFF:\n     count -=_RECURSIVE_CUTOFF\n     result.append(\n     f'  [Previous line repeated {count} more '\n     f'time{\"s\" if count > 1 else \"\"}]\\n'\n     )\n    last_file=frame.filename\n    last_line=frame.lineno\n    last_name=frame.name\n    count=0\n   count +=1\n   if count >_RECURSIVE_CUTOFF:\n    continue\n   row=[]\n   row.append('  File \"{}\", line {}, in {}\\n'.format(\n   frame.filename,frame.lineno,frame.name))\n   if frame.line:\n    row.append('    {}\\n'.format(frame.line.strip()))\n   if frame.locals:\n    for name,value in sorted(frame.locals.items()):\n     row.append('    {name} = {value}\\n'.format(name=name,value=value))\n   result.append(''.join(row))\n  if count >_RECURSIVE_CUTOFF:\n   count -=_RECURSIVE_CUTOFF\n   result.append(\n   f'  [Previous line repeated {count} more '\n   f'time{\"s\" if count > 1 else \"\"}]\\n'\n   )\n  return result\n  \n  \nclass TracebackException:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,exc_type,exc_value,exc_traceback,*,limit=None ,\n lookup_lines=True ,capture_locals=False ,_seen=None ):\n \n \n \n \n  if _seen is None :\n   _seen=set()\n  _seen.add(id(exc_value))\n  \n  \n  if (exc_value and exc_value.__cause__ is not None\n  and id(exc_value.__cause__)not in _seen):\n   cause=TracebackException(\n   type(exc_value.__cause__),\n   exc_value.__cause__,\n   exc_value.__cause__.__traceback__,\n   limit=limit,\n   lookup_lines=False ,\n   capture_locals=capture_locals,\n   _seen=_seen)\n  else :\n   cause=None\n  if (exc_value and exc_value.__context__ is not None\n  and id(exc_value.__context__)not in _seen):\n   context=TracebackException(\n   type(exc_value.__context__),\n   exc_value.__context__,\n   exc_value.__context__.__traceback__,\n   limit=limit,\n   lookup_lines=False ,\n   capture_locals=capture_locals,\n   _seen=_seen)\n  else :\n   context=None\n  self.exc_traceback=exc_traceback\n  self.__cause__=cause\n  self.__context__=context\n  self.__suppress_context__=\\\n  exc_value.__suppress_context__ if exc_value else False\n  \n  self.stack=StackSummary.extract(\n  walk_tb(exc_traceback),limit=limit,lookup_lines=lookup_lines,\n  capture_locals=capture_locals)\n  self.exc_type=exc_type\n  \n  \n  self._str=_some_str(exc_value)\n  if exc_type and issubclass(exc_type,SyntaxError):\n  \n   self.filename=exc_value.filename\n   self.lineno=str(exc_value.lineno)\n   self.text=exc_value.text\n   self.offset=exc_value.offset\n   self.msg=exc_value.msg\n  if lookup_lines:\n   self._load_lines()\n   \n @classmethod\n def from_exception(cls,exc,*args,**kwargs):\n  ''\n  return cls(type(exc),exc,exc.__traceback__,*args,**kwargs)\n  \n def _load_lines(self):\n  ''\n  for frame in self.stack:\n   frame.line\n  if self.__context__:\n   self.__context__._load_lines()\n  if self.__cause__:\n   self.__cause__._load_lines()\n   \n def __eq__(self,other):\n  return self.__dict__ ==other.__dict__\n  \n def __str__(self):\n  return self._str\n  \n def format_exception_only(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if self.exc_type is None :\n   yield _format_final_exc_line(None ,self._str)\n   return\n   \n  stype=self.exc_type.__qualname__\n  smod=self.exc_type.__module__\n  if smod not in (\"__main__\",\"builtins\"):\n   stype=smod+'.'+stype\n   \n  if not issubclass(self.exc_type,SyntaxError):\n   yield _format_final_exc_line(stype,self._str)\n   return\n   \n   \n  filename=self.filename or \"<string>\"\n  lineno=str(self.lineno)or '?'\n  yield '  File \"{}\", line {}\\n'.format(filename,lineno)\n  \n  badline=self.text\n  offset=self.offset\n  if badline is not None :\n   yield '    {}\\n'.format(badline.strip())\n   if offset is not None :\n    caretspace=badline.rstrip('\\n')\n    offset=min(len(caretspace),offset)-1\n    caretspace=caretspace[:offset].lstrip()\n    \n    caretspace=((c.isspace()and c or ' ')for c in caretspace)\n    yield '    {}^\\n'.format(''.join(caretspace))\n  msg=self.msg or \"<no detail available>\"\n  yield \"{}: {}\\n\".format(stype,msg)\n  \n def format(self,*,chain=True ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if chain:\n   if self.__cause__ is not None :\n    yield from self.__cause__.format(chain=chain)\n    yield _cause_message\n   elif (self.__context__ is not None and\n   not self.__suppress_context__):\n    yield from self.__context__.format(chain=chain)\n    yield _context_message\n  if self.exc_traceback is not None :\n   yield 'Traceback (most recent call last):\\n'\n  yield from self.stack.format()\n  yield from self.format_exception_only()\n", ["collections", "itertools", "linecache", "sys"]], "code": [".py", "''\n\n\n\n\n\n\nimport sys\nimport traceback\nfrom codeop import CommandCompiler,compile_command\n\n__all__=[\"InteractiveInterpreter\",\"InteractiveConsole\",\"interact\",\n\"compile_command\"]\n\nclass InteractiveInterpreter:\n ''\n\n\n\n\n\n \n \n def __init__(self,locals=None ):\n  ''\n\n\n\n\n\n\n  \n  if locals is None :\n   locals={\"__name__\":\"__console__\",\"__doc__\":None }\n  self.locals=locals\n  self.compile=CommandCompiler()\n  \n def runsource(self,source,filename=\"<input>\",symbol=\"single\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   code=self.compile(source,filename,symbol)\n  except (OverflowError,SyntaxError,ValueError):\n  \n   self.showsyntaxerror(filename)\n   return False\n   \n  if code is None :\n  \n   return True\n   \n   \n  self.runcode(code)\n  return False\n  \n def runcode(self,code):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  try :\n   exec(code,self.locals)\n  except SystemExit:\n   raise\n  except :\n   self.showtraceback()\n   \n def showsyntaxerror(self,filename=None ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  type,value,tb=sys.exc_info()\n  sys.last_type=type\n  sys.last_value=value\n  sys.last_traceback=tb\n  if filename and type is SyntaxError:\n  \n   try :\n    msg,(dummy_filename,lineno,offset,line)=value.args\n   except ValueError:\n   \n    pass\n   else :\n   \n    value=SyntaxError(msg,(filename,lineno,offset,line))\n    sys.last_value=value\n  if sys.excepthook is sys.__excepthook__:\n   lines=traceback.format_exception_only(type,value)\n   self.write(''.join(lines))\n  else :\n  \n  \n   sys.excepthook(type,value,tb)\n   \n def showtraceback(self):\n  ''\n\n\n\n\n\n  \n  sys.last_type,sys.last_value,last_tb=ei=sys.exc_info()\n  sys.last_traceback=last_tb\n  try :\n   lines=traceback.format_exception(ei[0],ei[1],last_tb.tb_next)\n   if sys.excepthook is sys.__excepthook__:\n    self.write(''.join(lines))\n   else :\n   \n   \n    sys.excepthook(ei[0],ei[1],last_tb)\n  finally :\n   last_tb=ei=None\n   \n def write(self,data):\n  ''\n\n\n\n\n  \n  sys.stderr.write(data)\n  \n  \nclass InteractiveConsole(InteractiveInterpreter):\n ''\n\n\n\n\n \n \n def __init__(self,locals=None ,filename=\"<console>\"):\n  ''\n\n\n\n\n\n\n\n  \n  InteractiveInterpreter.__init__(self,locals)\n  self.filename=filename\n  self.resetbuffer()\n  \n def resetbuffer(self):\n  ''\n  self.buffer=[]\n  \n def interact(self,banner=None ,exitmsg=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   sys.ps1\n  except AttributeError:\n   sys.ps1=\">>> \"\n  try :\n   sys.ps2\n  except AttributeError:\n   sys.ps2=\"... \"\n  cprt='Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.'\n  if banner is None :\n   self.write(\"Python %s on %s\\n%s\\n(%s)\\n\"%\n   (sys.version,sys.platform,cprt,\n   self.__class__.__name__))\n  elif banner:\n   self.write(\"%s\\n\"%str(banner))\n  more=0\n  while 1:\n   try :\n    if more:\n     prompt=sys.ps2\n    else :\n     prompt=sys.ps1\n    try :\n     line=self.raw_input(prompt)\n    except EOFError:\n     self.write(\"\\n\")\n     break\n    else :\n     more=self.push(line)\n   except KeyboardInterrupt:\n    self.write(\"\\nKeyboardInterrupt\\n\")\n    self.resetbuffer()\n    more=0\n  if exitmsg is None :\n   self.write('now exiting %s...\\n'%self.__class__.__name__)\n  elif exitmsg !='':\n   self.write('%s\\n'%exitmsg)\n   \n def push(self,line):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.buffer.append(line)\n  source=\"\\n\".join(self.buffer)\n  more=self.runsource(source,self.filename)\n  if not more:\n   self.resetbuffer()\n  return more\n  \n def raw_input(self,prompt=\"\"):\n  ''\n\n\n\n\n\n\n\n\n  \n  return input(prompt)\n  \n  \n  \ndef interact(banner=None ,readfunc=None ,local=None ,exitmsg=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n console=InteractiveConsole(local)\n if readfunc is not None :\n  console.raw_input=readfunc\n else :\n  try :\n   import readline\n  except ImportError:\n   pass\n console.interact(banner,exitmsg)\n \n \nif __name__ ==\"__main__\":\n import argparse\n \n parser=argparse.ArgumentParser()\n parser.add_argument('-q',action='store_true',\n help=\"don't print version and copyright messages\")\n args=parser.parse_args()\n if args.q or sys.flags.quiet:\n  banner=''\n else :\n  banner=None\n interact(banner)\n", ["argparse", "codeop", "readline", "sys", "traceback"]], "gc": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDEBUG_COLLECTABLE=2\n\nDEBUG_LEAK=38\n\nDEBUG_SAVEALL=32\n\nDEBUG_STATS=1\n\nDEBUG_UNCOLLECTABLE=4\n\nclass __loader__:\n pass\n \ncallbacks=[]\n\ndef collect(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef disable(*args,**kw):\n ''\n\n \n pass\n \ndef enable(*args,**kw):\n ''\n\n \n pass\n \ngarbage=[]\n\ndef get_count(*args,**kw):\n ''\n\n \n pass\n \ndef get_debug(*args,**kw):\n ''\n\n \n pass\n \ndef get_objects(*args,**kw):\n ''\n\n\n \n pass\n \ndef get_referents(*args,**kw):\n ''\n pass\n \ndef get_referrers(*args,**kw):\n ''\n pass\n \ndef get_threshold(*args,**kw):\n ''\n\n \n pass\n \ndef is_tracked(*args,**kw):\n ''\n\n\n \n pass\n \ndef isenabled(*args,**kw):\n ''\n\n \n pass\n \ndef set_debug(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef set_threshold(*args,**kw):\n ''\n\n\n \n pass\n", []], "_queue": [".py", "SimpleQueue=None\n\nclass Empty(Exception):\n ''\n pass\n", []], "keyword": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\"iskeyword\",\"kwlist\"]\n\nkwlist=[\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'async',\n'await',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield'\n]\n\niskeyword=frozenset(kwlist).__contains__\n", []], "copyreg": [".py", "''\n\n\n\n\n\n__all__=[\"pickle\",\"constructor\",\n\"add_extension\",\"remove_extension\",\"clear_extension_cache\"]\n\ndispatch_table={}\n\ndef pickle(ob_type,pickle_function,constructor_ob=None ):\n if not callable(pickle_function):\n  raise TypeError(\"reduction functions must be callable\")\n dispatch_table[ob_type]=pickle_function\n \n \n \n if constructor_ob is not None :\n  constructor(constructor_ob)\n  \ndef constructor(object):\n if not callable(object):\n  raise TypeError(\"constructors must be callable\")\n  \n  \n  \ntry :\n complex\nexcept NameError:\n pass\nelse :\n\n def pickle_complex(c):\n  return complex,(c.real,c.imag)\n  \n pickle(complex,pickle_complex,complex)\n \n \n \ndef _reconstructor(cls,base,state):\n if base is object:\n  obj=object.__new__(cls)\n else :\n  obj=base.__new__(cls,state)\n  if base.__init__ !=object.__init__:\n   base.__init__(obj,state)\n return obj\n \n_HEAPTYPE=1 <<9\n\n\n\ndef _reduce_ex(self,proto):\n assert proto <2\n cls=self.__class__\n for base in cls.__mro__:\n  if hasattr(base,'__flags__')and not base.__flags__&_HEAPTYPE:\n   break\n else :\n  base=object\n if base is object:\n  state=None\n else :\n  if base is cls:\n   raise TypeError(f\"cannot pickle {cls.__name__!r} object\")\n  state=base(self)\n args=(cls,base,state)\n try :\n  getstate=self.__getstate__\n except AttributeError:\n  if getattr(self,\"__slots__\",None ):\n   raise TypeError(f\"cannot pickle {cls.__name__!r} object: \"\n   f\"a class that defines __slots__ without \"\n   f\"defining __getstate__ cannot be pickled \"\n   f\"with protocol {proto}\")from None\n  try :\n   dict=self.__dict__\n  except AttributeError:\n   dict=None\n else :\n  dict=getstate()\n if dict:\n  return _reconstructor,args,dict\n else :\n  return _reconstructor,args\n  \n  \n  \ndef __newobj__(cls,*args):\n return cls.__new__(cls,*args)\n \ndef __newobj_ex__(cls,args,kwargs):\n ''\n\n \n return cls.__new__(cls,*args,**kwargs)\n \ndef _slotnames(cls):\n ''\n\n\n\n\n\n\n\n \n \n \n names=cls.__dict__.get(\"__slotnames__\")\n if names is not None :\n  return names\n  \n  \n names=[]\n if not hasattr(cls,\"__slots__\"):\n \n  pass\n else :\n \n  for c in cls.__mro__:\n   if \"__slots__\"in c.__dict__:\n    slots=c.__dict__['__slots__']\n    \n    if isinstance(slots,str):\n     slots=(slots,)\n    for name in slots:\n    \n     if name in (\"__dict__\",\"__weakref__\"):\n      continue\n      \n     elif name.startswith('__')and not name.endswith('__'):\n      stripped=c.__name__.lstrip('_')\n      if stripped:\n       names.append('_%s%s'%(stripped,name))\n      else :\n       names.append(name)\n     else :\n      names.append(name)\n      \n      \n try :\n  cls.__slotnames__=names\n except :\n  pass\n  \n return names\n \n \n \n \n \n \n \n \n \n \n_extension_registry={}\n_inverted_registry={}\n_extension_cache={}\n\n\n\ndef add_extension(module,name,code):\n ''\n code=int(code)\n if not 1 <=code <=0x7fffffff:\n  raise ValueError(\"code out of range\")\n key=(module,name)\n if (_extension_registry.get(key)==code and\n _inverted_registry.get(code)==key):\n  return\n if key in _extension_registry:\n  raise ValueError(\"key %s is already registered with code %s\"%\n  (key,_extension_registry[key]))\n if code in _inverted_registry:\n  raise ValueError(\"code %s is already in use for key %s\"%\n  (code,_inverted_registry[code]))\n _extension_registry[key]=code\n _inverted_registry[code]=key\n \ndef remove_extension(module,name,code):\n ''\n key=(module,name)\n if (_extension_registry.get(key)!=code or\n _inverted_registry.get(code)!=key):\n  raise ValueError(\"key %s is not registered with code %s\"%\n  (key,code))\n del _extension_registry[key]\n del _inverted_registry[code]\n if code in _extension_cache:\n  del _extension_cache[code]\n  \ndef clear_extension_cache():\n _extension_cache.clear()\n \n \n \n \n \n \n \n \n \n \n \n \n \n", []], "_testcapi": [".py", "\nCHAR_MAX=127\n\nCHAR_MIN=-128\n\nDBL_MAX=1.7976931348623157e+308\n\nDBL_MIN=2.2250738585072014e-308\n\nFLT_MAX=3.4028234663852886e+38\n\nFLT_MIN=1.1754943508222875e-38\n\nINT_MAX=2147483647\n\nINT_MIN=-2147483648\n\nLLONG_MAX=9223372036854775807\n\nLLONG_MIN=-9223372036854775808\n\nLONG_MAX=2147483647\n\nLONG_MIN=-2147483648\n\nPY_SSIZE_T_MAX=2147483647\n\nPY_SSIZE_T_MIN=-2147483648\n\nSHRT_MAX=32767\n\nSHRT_MIN=-32768\n\nSIZEOF_PYGC_HEAD=16\n\nUCHAR_MAX=255\n\nUINT_MAX=4294967295\n\nULLONG_MAX=18446744073709551615\n\nULONG_MAX=4294967295\n\nUSHRT_MAX=65535\n\n__loader__=\"<_frozen_importlib.ExtensionFileLoader object at 0x00C98DD0>\"\n\ndef _pending_threadfunc(*args,**kw):\n pass\n \nclass _test_structmembersType(object):\n pass\n \ndef _test_thread_state(*args,**kw):\n pass\n \ndef argparsing(*args,**kw):\n pass\n \ndef code_newempty(*args,**kw):\n pass\n \ndef codec_incrementaldecoder(*args,**kw):\n pass\n \ndef codec_incrementalencoder(*args,**kw):\n pass\n \ndef crash_no_current_thread(*args,**kw):\n pass\n \nclass error(Exception):\n pass\n \ndef exception_print(*args,**kw):\n pass\n \ndef getargs_B(*args,**kw):\n pass\n \ndef getargs_H(*args,**kw):\n pass\n \ndef getargs_I(*args,**kw):\n pass\n \ndef getargs_K(*args,**kw):\n pass\n \ndef getargs_L(*args,**kw):\n pass\n \ndef getargs_Z(*args,**kw):\n pass\n \ndef getargs_Z_hash(*args,**kw):\n pass\n \ndef getargs_b(*args,**kw):\n pass\n \ndef getargs_c(*args,**kw):\n pass\n \ndef getargs_h(*args,**kw):\n pass\n \ndef getargs_i(*args,**kw):\n pass\n \ndef getargs_k(*args,**kw):\n pass\n \ndef getargs_keyword_only(*args,**kw):\n pass\n \ndef getargs_keywords(*args,**kw):\n pass\n \ndef getargs_l(*args,**kw):\n pass\n \ndef getargs_n(*args,**kw):\n pass\n \ndef getargs_p(*args,**kw):\n pass\n \ndef getargs_s(*args,**kw):\n pass\n \ndef getargs_s_hash(*args,**kw):\n pass\n \ndef getargs_s_star(*args,**kw):\n pass\n \ndef getargs_tuple(*args,**kw):\n pass\n \ndef getargs_u(*args,**kw):\n pass\n \ndef getargs_u_hash(*args,**kw):\n pass\n \ndef getargs_w_star(*args,**kw):\n pass\n \ndef getargs_y(*args,**kw):\n pass\n \ndef getargs_y_hash(*args,**kw):\n pass\n \ndef getargs_y_star(*args,**kw):\n pass\n \ndef getargs_z(*args,**kw):\n pass\n \ndef getargs_z_hash(*args,**kw):\n pass\n \ndef getargs_z_star(*args,**kw):\n pass\n \nclass instancemethod(object):\n pass\n \ndef make_exception_with_doc(*args,**kw):\n pass\n \ndef make_memoryview_from_NULL_pointer(*args,**kw):\n pass\n \ndef parse_tuple_and_keywords(*args,**kw):\n pass\n \ndef pytime_object_to_time_t(*args,**kw):\n pass\n \ndef pytime_object_to_timespec(*args,**kw):\n pass\n \ndef pytime_object_to_timeval(*args,**kw):\n pass\n \ndef raise_exception(*args,**kw):\n pass\n \ndef raise_memoryerror(*args,**kw):\n pass\n \ndef run_in_subinterp(*args,**kw):\n pass\n \ndef set_exc_info(*args,**kw):\n pass\n \ndef test_L_code(*args,**kw):\n pass\n \ndef test_Z_code(*args,**kw):\n pass\n \ndef test_capsule(*args,**kw):\n pass\n \ndef test_config(*args,**kw):\n pass\n \ndef test_datetime_capi(*args,**kw):\n pass\n \ndef test_dict_iteration(*args,**kw):\n pass\n \ndef test_empty_argparse(*args,**kw):\n pass\n \ndef test_k_code(*args,**kw):\n pass\n \ndef test_lazy_hash_inheritance(*args,**kw):\n pass\n \ndef test_list_api(*args,**kw):\n pass\n \ndef test_long_and_overflow(*args,**kw):\n pass\n \ndef test_long_api(*args,**kw):\n pass\n \ndef test_long_as_double(*args,**kw):\n pass\n \ndef test_long_as_size_t(*args,**kw):\n pass\n \ndef test_long_long_and_overflow(*args,**kw):\n pass\n \ndef test_long_numbits(*args,**kw):\n pass\n \ndef test_longlong_api(*args,**kw):\n pass\n \ndef test_null_strings(*args,**kw):\n pass\n \ndef test_s_code(*args,**kw):\n pass\n \ndef test_string_from_format(*args,**kw):\n pass\n \ndef test_string_to_double(*args,**kw):\n pass\n \ndef test_u_code(*args,**kw):\n pass\n \ndef test_unicode_compare_with_ascii(*args,**kw):\n pass\n \ndef test_widechar(*args,**kw):\n pass\n \ndef test_with_docstring(*args,**kw):\n ''\n pass\n \ndef traceback_print(*args,**kw):\n pass\n \ndef unicode_aswidechar(*args,**kw):\n pass\n \ndef unicode_aswidecharstring(*args,**kw):\n pass\n \ndef unicode_encodedecimal(*args,**kw):\n pass\n \ndef unicode_transformdecimaltoascii(*args,**kw):\n pass\n", []], "codeop": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport __future__\n\n_features=[getattr(__future__,fname)\nfor fname in __future__.all_feature_names]\n\n__all__=[\"compile_command\",\"Compile\",\"CommandCompiler\"]\n\nPyCF_DONT_IMPLY_DEDENT=0x200\n\ndef _maybe_compile(compiler,source,filename,symbol):\n\n for line in source.split(\"\\n\"):\n  line=line.strip()\n  if line and line[0]!='#':\n   break\n else :\n  if symbol !=\"eval\":\n   source=\"pass\"\n   \n err=err1=err2=None\n code=code1=code2=None\n \n try :\n  code=compiler(source,filename,symbol)\n except SyntaxError as err:\n  pass\n  \n try :\n  code1=compiler(source+\"\\n\",filename,symbol)\n except SyntaxError as e:\n  err1=e\n  \n try :\n  code2=compiler(source+\"\\n\\n\",filename,symbol)\n except SyntaxError as e:\n  err2=e\n  \n if code:\n  return code\n if not code1 and repr(err1)==repr(err2):\n  raise err1\n  \ndef _compile(source,filename,symbol):\n return compile(source,filename,symbol,PyCF_DONT_IMPLY_DEDENT)\n \ndef compile_command(source,filename=\"<input>\",symbol=\"single\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return _maybe_compile(_compile,source,filename,symbol)\n \nclass Compile:\n ''\n\n\n \n def __init__(self):\n  self.flags=PyCF_DONT_IMPLY_DEDENT\n  \n def __call__(self,source,filename,symbol):\n  codeob=compile(source,filename,symbol,self.flags,1)\n  for feature in _features:\n   if codeob.co_flags&feature.compiler_flag:\n    self.flags |=feature.compiler_flag\n  return codeob\n  \nclass CommandCompiler:\n ''\n\n\n\n \n \n def __init__(self,):\n  self.compiler=Compile()\n  \n def __call__(self,source,filename=\"<input>\",symbol=\"single\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return _maybe_compile(self.compiler,source,filename,symbol)\n", ["__future__"]], "errno": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\nE2BIG=7\n\nEACCES=13\n\nEADDRINUSE=10048\n\nEADDRNOTAVAIL=10049\n\nEAFNOSUPPORT=10047\n\nEAGAIN=11\n\nEALREADY=10037\n\nEBADF=9\n\nEBADMSG=104\n\nEBUSY=16\n\nECANCELED=105\n\nECHILD=10\n\nECONNABORTED=10053\n\nECONNREFUSED=10061\n\nECONNRESET=10054\n\nEDEADLK=36\n\nEDEADLOCK=36\n\nEDESTADDRREQ=10039\n\nEDOM=33\n\nEDQUOT=10069\n\nEEXIST=17\n\nEFAULT=14\n\nEFBIG=27\n\nEHOSTDOWN=10064\n\nEHOSTUNREACH=10065\n\nEIDRM=111\n\nEILSEQ=42\n\nEINPROGRESS=10036\n\nEINTR=4\n\nEINVAL=22\n\nEIO=5\n\nEISCONN=10056\n\nEISDIR=21\n\nELOOP=10062\n\nEMFILE=24\n\nEMLINK=31\n\nEMSGSIZE=10040\n\nENAMETOOLONG=38\n\nENETDOWN=10050\n\nENETRESET=10052\n\nENETUNREACH=10051\n\nENFILE=23\n\nENOBUFS=10055\n\nENODATA=120\n\nENODEV=19\n\nENOENT=2\n\nENOEXEC=8\n\nENOLCK=39\n\nENOLINK=121\n\nENOMEM=12\n\nENOMSG=122\n\nENOPROTOOPT=10042\n\nENOSPC=28\n\nENOSR=124\n\nENOSTR=125\n\nENOSYS=40\n\nENOTCONN=10057\n\nENOTDIR=20\n\nENOTEMPTY=41\n\nENOTRECOVERABLE=127\n\nENOTSOCK=10038\n\nENOTSUP=129\n\nENOTTY=25\n\nENXIO=6\n\nEOPNOTSUPP=10045\n\nEOVERFLOW=132\n\nEOWNERDEAD=133\n\nEPERM=1\n\nEPFNOSUPPORT=10046\n\nEPIPE=32\n\nEPROTO=134\n\nEPROTONOSUPPORT=10043\n\nEPROTOTYPE=10041\n\nERANGE=34\n\nEREMOTE=10071\n\nEROFS=30\n\nESHUTDOWN=10058\n\nESOCKTNOSUPPORT=10044\n\nESPIPE=29\n\nESRCH=3\n\nESTALE=10070\n\nETIME=137\n\nETIMEDOUT=10060\n\nETOOMANYREFS=10059\n\nETXTBSY=139\n\nEUSERS=10068\n\nEWOULDBLOCK=10035\n\nEXDEV=18\n\nWSABASEERR=10000\n\nWSAEACCES=10013\n\nWSAEADDRINUSE=10048\n\nWSAEADDRNOTAVAIL=10049\n\nWSAEAFNOSUPPORT=10047\n\nWSAEALREADY=10037\n\nWSAEBADF=10009\n\nWSAECONNABORTED=10053\n\nWSAECONNREFUSED=10061\n\nWSAECONNRESET=10054\n\nWSAEDESTADDRREQ=10039\n\nWSAEDISCON=10101\n\nWSAEDQUOT=10069\n\nWSAEFAULT=10014\n\nWSAEHOSTDOWN=10064\n\nWSAEHOSTUNREACH=10065\n\nWSAEINPROGRESS=10036\n\nWSAEINTR=10004\n\nWSAEINVAL=10022\n\nWSAEISCONN=10056\n\nWSAELOOP=10062\n\nWSAEMFILE=10024\n\nWSAEMSGSIZE=10040\n\nWSAENAMETOOLONG=10063\n\nWSAENETDOWN=10050\n\nWSAENETRESET=10052\n\nWSAENETUNREACH=10051\n\nWSAENOBUFS=10055\n\nWSAENOPROTOOPT=10042\n\nWSAENOTCONN=10057\n\nWSAENOTEMPTY=10066\n\nWSAENOTSOCK=10038\n\nWSAEOPNOTSUPP=10045\n\nWSAEPFNOSUPPORT=10046\n\nWSAEPROCLIM=10067\n\nWSAEPROTONOSUPPORT=10043\n\nWSAEPROTOTYPE=10041\n\nWSAEREMOTE=10071\n\nWSAESHUTDOWN=10058\n\nWSAESOCKTNOSUPPORT=10044\n\nWSAESTALE=10070\n\nWSAETIMEDOUT=10060\n\nWSAETOOMANYREFS=10059\n\nWSAEUSERS=10068\n\nWSAEWOULDBLOCK=10035\n\nWSANOTINITIALISED=10093\n\nWSASYSNOTREADY=10091\n\nWSAVERNOTSUPPORTED=10092\n\nerrorcode={v:k for (k,v)in globals().items()if k ==k.upper()}\n", []], "sre_compile": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\nimport _sre\nimport sre_parse\nfrom sre_constants import *\n\nassert _sre.MAGIC ==MAGIC,\"SRE module mismatch\"\n\n_LITERAL_CODES={LITERAL,NOT_LITERAL}\n_REPEATING_CODES={REPEAT,MIN_REPEAT,MAX_REPEAT}\n_SUCCESS_CODES={SUCCESS,FAILURE}\n_ASSERT_CODES={ASSERT,ASSERT_NOT}\n_UNIT_CODES=_LITERAL_CODES |{ANY,IN}\n\n\n_equivalences=(\n\n(0x69,0x131),\n\n(0x73,0x17f),\n\n(0xb5,0x3bc),\n\n(0x345,0x3b9,0x1fbe),\n\n(0x390,0x1fd3),\n\n(0x3b0,0x1fe3),\n\n(0x3b2,0x3d0),\n\n(0x3b5,0x3f5),\n\n(0x3b8,0x3d1),\n\n(0x3ba,0x3f0),\n\n(0x3c0,0x3d6),\n\n(0x3c1,0x3f1),\n\n(0x3c2,0x3c3),\n\n(0x3c6,0x3d5),\n\n(0x1e61,0x1e9b),\n\n(0xfb05,0xfb06),\n)\n\n\n_ignorecase_fixes={i:tuple(j for j in t if i !=j)\nfor t in _equivalences for i in t}\n\ndef _combine_flags(flags,add_flags,del_flags,\nTYPE_FLAGS=sre_parse.TYPE_FLAGS):\n if add_flags&TYPE_FLAGS:\n  flags &=~TYPE_FLAGS\n return (flags |add_flags)&~del_flags\n \ndef _compile(code,pattern,flags):\n\n emit=code.append\n _len=len\n LITERAL_CODES=_LITERAL_CODES\n REPEATING_CODES=_REPEATING_CODES\n SUCCESS_CODES=_SUCCESS_CODES\n ASSERT_CODES=_ASSERT_CODES\n iscased=None\n tolower=None\n fixes=None\n if flags&SRE_FLAG_IGNORECASE and not flags&SRE_FLAG_LOCALE:\n  if flags&SRE_FLAG_UNICODE:\n   iscased=_sre.unicode_iscased\n   tolower=_sre.unicode_tolower\n   fixes=_ignorecase_fixes\n  else :\n   iscased=_sre.ascii_iscased\n   tolower=_sre.ascii_tolower\n for op,av in pattern:\n  if op in LITERAL_CODES:\n   if not flags&SRE_FLAG_IGNORECASE:\n    emit(op)\n    emit(av)\n   elif flags&SRE_FLAG_LOCALE:\n    emit(OP_LOCALE_IGNORE[op])\n    emit(av)\n   elif not iscased(av):\n    emit(op)\n    emit(av)\n   else :\n    lo=tolower(av)\n    if not fixes:\n     emit(OP_IGNORE[op])\n     emit(lo)\n    elif lo not in fixes:\n     emit(OP_UNICODE_IGNORE[op])\n     emit(lo)\n    else :\n     emit(IN_UNI_IGNORE)\n     skip=_len(code);emit(0)\n     if op is NOT_LITERAL:\n      emit(NEGATE)\n     for k in (lo,)+fixes[lo]:\n      emit(LITERAL)\n      emit(k)\n     emit(FAILURE)\n     code[skip]=_len(code)-skip\n  elif op is IN:\n   charset,hascased=_optimize_charset(av,iscased,tolower,fixes)\n   if flags&SRE_FLAG_IGNORECASE and flags&SRE_FLAG_LOCALE:\n    emit(IN_LOC_IGNORE)\n   elif not hascased:\n    emit(IN)\n   elif not fixes:\n    emit(IN_IGNORE)\n   else :\n    emit(IN_UNI_IGNORE)\n   skip=_len(code);emit(0)\n   _compile_charset(charset,flags,code)\n   code[skip]=_len(code)-skip\n  elif op is ANY:\n   if flags&SRE_FLAG_DOTALL:\n    emit(ANY_ALL)\n   else :\n    emit(ANY)\n  elif op in REPEATING_CODES:\n   if flags&SRE_FLAG_TEMPLATE:\n    raise error(\"internal: unsupported template operator %r\"%(op,))\n   if _simple(av[2]):\n    if op is MAX_REPEAT:\n     emit(REPEAT_ONE)\n    else :\n     emit(MIN_REPEAT_ONE)\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    emit(SUCCESS)\n    code[skip]=_len(code)-skip\n   else :\n    emit(REPEAT)\n    skip=_len(code);emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code,av[2],flags)\n    code[skip]=_len(code)-skip\n    if op is MAX_REPEAT:\n     emit(MAX_UNTIL)\n    else :\n     emit(MIN_UNTIL)\n  elif op is SUBPATTERN:\n   group,add_flags,del_flags,p=av\n   if group:\n    emit(MARK)\n    emit((group -1)*2)\n    \n   _compile(code,p,_combine_flags(flags,add_flags,del_flags))\n   if group:\n    emit(MARK)\n    emit((group -1)*2+1)\n  elif op in SUCCESS_CODES:\n   emit(op)\n  elif op in ASSERT_CODES:\n   emit(op)\n   skip=_len(code);emit(0)\n   if av[0]>=0:\n    emit(0)\n   else :\n    lo,hi=av[1].getwidth()\n    if lo !=hi:\n     raise error(\"look-behind requires fixed-width pattern\")\n    emit(lo)\n   _compile(code,av[1],flags)\n   emit(SUCCESS)\n   code[skip]=_len(code)-skip\n  elif op is CALL:\n   emit(op)\n   skip=_len(code);emit(0)\n   _compile(code,av,flags)\n   emit(SUCCESS)\n   code[skip]=_len(code)-skip\n  elif op is AT:\n   emit(op)\n   if flags&SRE_FLAG_MULTILINE:\n    av=AT_MULTILINE.get(av,av)\n   if flags&SRE_FLAG_LOCALE:\n    av=AT_LOCALE.get(av,av)\n   elif flags&SRE_FLAG_UNICODE:\n    av=AT_UNICODE.get(av,av)\n   emit(av)\n  elif op is BRANCH:\n   emit(op)\n   tail=[]\n   tailappend=tail.append\n   for av in av[1]:\n    skip=_len(code);emit(0)\n    \n    _compile(code,av,flags)\n    emit(JUMP)\n    tailappend(_len(code));emit(0)\n    code[skip]=_len(code)-skip\n   emit(FAILURE)\n   for tail in tail:\n    code[tail]=_len(code)-tail\n  elif op is CATEGORY:\n   emit(op)\n   if flags&SRE_FLAG_LOCALE:\n    av=CH_LOCALE[av]\n   elif flags&SRE_FLAG_UNICODE:\n    av=CH_UNICODE[av]\n   emit(av)\n  elif op is GROUPREF:\n   if not flags&SRE_FLAG_IGNORECASE:\n    emit(op)\n   elif flags&SRE_FLAG_LOCALE:\n    emit(GROUPREF_LOC_IGNORE)\n   elif not fixes:\n    emit(GROUPREF_IGNORE)\n   else :\n    emit(GROUPREF_UNI_IGNORE)\n   emit(av -1)\n  elif op is GROUPREF_EXISTS:\n   emit(op)\n   emit(av[0]-1)\n   skipyes=_len(code);emit(0)\n   _compile(code,av[1],flags)\n   if av[2]:\n    emit(JUMP)\n    skipno=_len(code);emit(0)\n    code[skipyes]=_len(code)-skipyes+1\n    _compile(code,av[2],flags)\n    code[skipno]=_len(code)-skipno\n   else :\n    code[skipyes]=_len(code)-skipyes+1\n  else :\n   raise error(\"internal: unsupported operand type %r\"%(op,))\n   \ndef _compile_charset(charset,flags,code):\n\n emit=code.append\n for op,av in charset:\n  emit(op)\n  if op is NEGATE:\n   pass\n  elif op is LITERAL:\n   emit(av)\n  elif op is RANGE or op is RANGE_UNI_IGNORE:\n   emit(av[0])\n   emit(av[1])\n  elif op is CHARSET:\n   code.extend(av)\n  elif op is BIGCHARSET:\n   code.extend(av)\n  elif op is CATEGORY:\n   if flags&SRE_FLAG_LOCALE:\n    emit(CH_LOCALE[av])\n   elif flags&SRE_FLAG_UNICODE:\n    emit(CH_UNICODE[av])\n   else :\n    emit(av)\n  else :\n   raise error(\"internal: unsupported set operator %r\"%(op,))\n emit(FAILURE)\n \ndef _optimize_charset(charset,iscased=None ,fixup=None ,fixes=None ):\n\n out=[]\n tail=[]\n charmap=bytearray(256)\n hascased=False\n for op,av in charset:\n  while True :\n   try :\n    if op is LITERAL:\n     if fixup:\n      lo=fixup(av)\n      charmap[lo]=1\n      if fixes and lo in fixes:\n       for k in fixes[lo]:\n        charmap[k]=1\n      if not hascased and iscased(av):\n       hascased=True\n     else :\n      charmap[av]=1\n    elif op is RANGE:\n     r=range(av[0],av[1]+1)\n     if fixup:\n      if fixes:\n       for i in map(fixup,r):\n        charmap[i]=1\n        if i in fixes:\n         for k in fixes[i]:\n          charmap[k]=1\n      else :\n       for i in map(fixup,r):\n        charmap[i]=1\n      if not hascased:\n       hascased=any(map(iscased,r))\n     else :\n      for i in r:\n       charmap[i]=1\n    elif op is NEGATE:\n     out.append((op,av))\n    else :\n     tail.append((op,av))\n   except IndexError:\n    if len(charmap)==256:\n    \n     charmap +=b'\\0'*0xff00\n     continue\n     \n    if fixup:\n     hascased=True\n     \n     \n     \n     if op is RANGE:\n      op=RANGE_UNI_IGNORE\n    tail.append((op,av))\n   break\n   \n   \n runs=[]\n q=0\n while True :\n  p=charmap.find(1,q)\n  if p <0:\n   break\n  if len(runs)>=2:\n   runs=None\n   break\n  q=charmap.find(0,p)\n  if q <0:\n   runs.append((p,len(charmap)))\n   break\n  runs.append((p,q))\n if runs is not None :\n \n  for p,q in runs:\n   if q -p ==1:\n    out.append((LITERAL,p))\n   else :\n    out.append((RANGE,(p,q -1)))\n  out +=tail\n  \n  if hascased or len(out)<len(charset):\n   return out,hascased\n   \n  return charset,hascased\n  \n  \n if len(charmap)==256:\n  data=_mk_bitmap(charmap)\n  out.append((CHARSET,data))\n  out +=tail\n  return out,hascased\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n charmap=bytes(charmap)\n comps={}\n mapping=bytearray(256)\n block=0\n data=bytearray()\n for i in range(0,65536,256):\n  chunk=charmap[i:i+256]\n  if chunk in comps:\n   mapping[i //256]=comps[chunk]\n  else :\n   mapping[i //256]=comps[chunk]=block\n   block +=1\n   data +=chunk\n data=_mk_bitmap(data)\n data[0:0]=[block]+_bytes_to_codes(mapping)\n out.append((BIGCHARSET,data))\n out +=tail\n return out,hascased\n \n_CODEBITS=_sre.CODESIZE *8\nMAXCODE=(1 <<_CODEBITS)-1\n_BITS_TRANS=b'0'+b'1'*255\ndef _mk_bitmap(bits,_CODEBITS=_CODEBITS,_int=int):\n s=bits.translate(_BITS_TRANS)[::-1]\n return [_int(s[i -_CODEBITS:i],2)\n for i in range(len(s),0,-_CODEBITS)]\n \ndef _bytes_to_codes(b):\n\n a=memoryview(b).cast('I')\n assert a.itemsize ==_sre.CODESIZE\n assert len(a)*a.itemsize ==len(b)\n return a.tolist()\n \ndef _simple(p):\n\n if len(p)!=1:\n  return False\n op,av=p[0]\n if op is SUBPATTERN:\n  return av[0]is None and _simple(av[-1])\n return op in _UNIT_CODES\n \ndef _generate_overlap_table(prefix):\n ''\n\n\n\n\n\n\n \n table=[0]*len(prefix)\n for i in range(1,len(prefix)):\n  idx=table[i -1]\n  while prefix[i]!=prefix[idx]:\n   if idx ==0:\n    table[i]=0\n    break\n   idx=table[idx -1]\n  else :\n   table[i]=idx+1\n return table\n \ndef _get_iscased(flags):\n if not flags&SRE_FLAG_IGNORECASE:\n  return None\n elif flags&SRE_FLAG_UNICODE:\n  return _sre.unicode_iscased\n else :\n  return _sre.ascii_iscased\n  \ndef _get_literal_prefix(pattern,flags):\n\n prefix=[]\n prefixappend=prefix.append\n prefix_skip=None\n iscased=_get_iscased(flags)\n for op,av in pattern.data:\n  if op is LITERAL:\n   if iscased and iscased(av):\n    break\n   prefixappend(av)\n  elif op is SUBPATTERN:\n   group,add_flags,del_flags,p=av\n   flags1=_combine_flags(flags,add_flags,del_flags)\n   if flags1&SRE_FLAG_IGNORECASE and flags1&SRE_FLAG_LOCALE:\n    break\n   prefix1,prefix_skip1,got_all=_get_literal_prefix(p,flags1)\n   if prefix_skip is None :\n    if group is not None :\n     prefix_skip=len(prefix)\n    elif prefix_skip1 is not None :\n     prefix_skip=len(prefix)+prefix_skip1\n   prefix.extend(prefix1)\n   if not got_all:\n    break\n  else :\n   break\n else :\n  return prefix,prefix_skip,True\n return prefix,prefix_skip,False\n \ndef _get_charset_prefix(pattern,flags):\n while True :\n  if not pattern.data:\n   return None\n  op,av=pattern.data[0]\n  if op is not SUBPATTERN:\n   break\n  group,add_flags,del_flags,pattern=av\n  flags=_combine_flags(flags,add_flags,del_flags)\n  if flags&SRE_FLAG_IGNORECASE and flags&SRE_FLAG_LOCALE:\n   return None\n   \n iscased=_get_iscased(flags)\n if op is LITERAL:\n  if iscased and iscased(av):\n   return None\n  return [(op,av)]\n elif op is BRANCH:\n  charset=[]\n  charsetappend=charset.append\n  for p in av[1]:\n   if not p:\n    return None\n   op,av=p[0]\n   if op is LITERAL and not (iscased and iscased(av)):\n    charsetappend((op,av))\n   else :\n    return None\n  return charset\n elif op is IN:\n  charset=av\n  if iscased:\n   for op,av in charset:\n    if op is LITERAL:\n     if iscased(av):\n      return None\n    elif op is RANGE:\n     if av[1]>0xffff:\n      return None\n     if any(map(iscased,range(av[0],av[1]+1))):\n      return None\n  return charset\n return None\n \ndef _compile_info(code,pattern,flags):\n\n\n\n lo,hi=pattern.getwidth()\n if hi >MAXCODE:\n  hi=MAXCODE\n if lo ==0:\n  code.extend([INFO,4,0,lo,hi])\n  return\n  \n prefix=[]\n prefix_skip=0\n charset=[]\n if not (flags&SRE_FLAG_IGNORECASE and flags&SRE_FLAG_LOCALE):\n \n  prefix,prefix_skip,got_all=_get_literal_prefix(pattern,flags)\n  \n  if not prefix:\n   charset=_get_charset_prefix(pattern,flags)\n   \n   \n   \n   \n   \n emit=code.append\n emit(INFO)\n skip=len(code);emit(0)\n \n mask=0\n if prefix:\n  mask=SRE_INFO_PREFIX\n  if prefix_skip is None and got_all:\n   mask=mask |SRE_INFO_LITERAL\n elif charset:\n  mask=mask |SRE_INFO_CHARSET\n emit(mask)\n \n if lo <MAXCODE:\n  emit(lo)\n else :\n  emit(MAXCODE)\n  prefix=prefix[:MAXCODE]\n emit(min(hi,MAXCODE))\n \n if prefix:\n  emit(len(prefix))\n  if prefix_skip is None :\n   prefix_skip=len(prefix)\n  emit(prefix_skip)\n  code.extend(prefix)\n  \n  code.extend(_generate_overlap_table(prefix))\n elif charset:\n  charset,hascased=_optimize_charset(charset)\n  assert not hascased\n  _compile_charset(charset,flags,code)\n code[skip]=len(code)-skip\n \ndef isstring(obj):\n return isinstance(obj,(str,bytes))\n \ndef _code(p,flags):\n\n flags=p.state.flags |flags\n code=[]\n \n \n _compile_info(code,p,flags)\n \n \n _compile(code,p.data,flags)\n \n code.append(SUCCESS)\n \n return code\n \ndef _hex_code(code):\n return '[%s]'%', '.join('%#0*x'%(_sre.CODESIZE *2+2,x)for x in code)\n \ndef dis(code):\n import sys\n \n labels=set()\n level=0\n offset_width=len(str(len(code)-1))\n \n def dis_(start,end):\n  def print_(*args,to=None ):\n   if to is not None :\n    labels.add(to)\n    args +=('(to %d)'%(to,),)\n   print('%*d%s '%(offset_width,start,':'if start in labels else '.'),\n   end='  '*(level -1))\n   print(*args)\n   \n  def print_2(*args):\n   print(end=' '*(offset_width+2 *level))\n   print(*args)\n   \n  nonlocal level\n  level +=1\n  i=start\n  while i <end:\n   start=i\n   op=code[i]\n   i +=1\n   op=OPCODES[op]\n   if op in (SUCCESS,FAILURE,ANY,ANY_ALL,\n   MAX_UNTIL,MIN_UNTIL,NEGATE):\n    print_(op)\n   elif op in (LITERAL,NOT_LITERAL,\n   LITERAL_IGNORE,NOT_LITERAL_IGNORE,\n   LITERAL_UNI_IGNORE,NOT_LITERAL_UNI_IGNORE,\n   LITERAL_LOC_IGNORE,NOT_LITERAL_LOC_IGNORE):\n    arg=code[i]\n    i +=1\n    print_(op,'%#02x (%r)'%(arg,chr(arg)))\n   elif op is AT:\n    arg=code[i]\n    i +=1\n    arg=str(ATCODES[arg])\n    assert arg[:3]=='AT_'\n    print_(op,arg[3:])\n   elif op is CATEGORY:\n    arg=code[i]\n    i +=1\n    arg=str(CHCODES[arg])\n    assert arg[:9]=='CATEGORY_'\n    print_(op,arg[9:])\n   elif op in (IN,IN_IGNORE,IN_UNI_IGNORE,IN_LOC_IGNORE):\n    skip=code[i]\n    print_(op,skip,to=i+skip)\n    dis_(i+1,i+skip)\n    i +=skip\n   elif op in (RANGE,RANGE_UNI_IGNORE):\n    lo,hi=code[i:i+2]\n    i +=2\n    print_(op,'%#02x %#02x (%r-%r)'%(lo,hi,chr(lo),chr(hi)))\n   elif op is CHARSET:\n    print_(op,_hex_code(code[i:i+256 //_CODEBITS]))\n    i +=256 //_CODEBITS\n   elif op is BIGCHARSET:\n    arg=code[i]\n    i +=1\n    mapping=list(b''.join(x.to_bytes(_sre.CODESIZE,sys.byteorder)\n    for x in code[i:i+256 //_sre.CODESIZE]))\n    print_(op,arg,mapping)\n    i +=256 //_sre.CODESIZE\n    level +=1\n    for j in range(arg):\n     print_2(_hex_code(code[i:i+256 //_CODEBITS]))\n     i +=256 //_CODEBITS\n    level -=1\n   elif op in (MARK,GROUPREF,GROUPREF_IGNORE,GROUPREF_UNI_IGNORE,\n   GROUPREF_LOC_IGNORE):\n    arg=code[i]\n    i +=1\n    print_(op,arg)\n   elif op is JUMP:\n    skip=code[i]\n    print_(op,skip,to=i+skip)\n    i +=1\n   elif op is BRANCH:\n    skip=code[i]\n    print_(op,skip,to=i+skip)\n    while skip:\n     dis_(i+1,i+skip)\n     i +=skip\n     start=i\n     skip=code[i]\n     if skip:\n      print_('branch',skip,to=i+skip)\n     else :\n      print_(FAILURE)\n    i +=1\n   elif op in (REPEAT,REPEAT_ONE,MIN_REPEAT_ONE):\n    skip,min,max=code[i:i+3]\n    if max ==MAXREPEAT:\n     max='MAXREPEAT'\n    print_(op,skip,min,max,to=i+skip)\n    dis_(i+3,i+skip)\n    i +=skip\n   elif op is GROUPREF_EXISTS:\n    arg,skip=code[i:i+2]\n    print_(op,arg,skip,to=i+skip)\n    i +=2\n   elif op in (ASSERT,ASSERT_NOT):\n    skip,arg=code[i:i+2]\n    print_(op,skip,arg,to=i+skip)\n    dis_(i+2,i+skip)\n    i +=skip\n   elif op is INFO:\n    skip,flags,min,max=code[i:i+4]\n    if max ==MAXREPEAT:\n     max='MAXREPEAT'\n    print_(op,skip,bin(flags),min,max,to=i+skip)\n    start=i+4\n    if flags&SRE_INFO_PREFIX:\n     prefix_len,prefix_skip=code[i+4:i+6]\n     print_2('  prefix_skip',prefix_skip)\n     start=i+6\n     prefix=code[start:start+prefix_len]\n     print_2('  prefix',\n     '[%s]'%', '.join('%#02x'%x for x in prefix),\n     '(%r)'%''.join(map(chr,prefix)))\n     start +=prefix_len\n     print_2('  overlap',code[start:start+prefix_len])\n     start +=prefix_len\n    if flags&SRE_INFO_CHARSET:\n     level +=1\n     print_2('in')\n     dis_(start,i+skip)\n     level -=1\n    i +=skip\n   else :\n    raise ValueError(op)\n    \n  level -=1\n  \n dis_(0,len(code))\n \n \ndef compile(p,flags=0):\n\n\n if isstring(p):\n  pattern=p\n  p=sre_parse.parse(p,flags)\n else :\n  pattern=None\n  \n code=_code(p,flags)\n \n if flags&SRE_FLAG_DEBUG:\n  print()\n  dis(code)\n  \n  \n groupindex=p.state.groupdict\n indexgroup=[None ]*p.state.groups\n for k,i in groupindex.items():\n  indexgroup[i]=k\n  \n return _sre.compile(\n pattern,flags |p.state.flags,code,\n p.state.groups -1,\n groupindex,tuple(indexgroup)\n )\n", ["_sre", "sre_constants", "sre_parse", "sys"]], "imp": [".py", "''\n\n\n\n\n\n\n\nfrom _imp import (lock_held,acquire_lock,release_lock,\nget_frozen_object,is_frozen_package,\ninit_frozen,is_builtin,is_frozen,\n_fix_co_filename)\ntry :\n from _imp import create_dynamic\nexcept ImportError:\n\n create_dynamic=None\n \nfrom importlib._bootstrap import _ERR_MSG,_exec,_load,_builtin_from_name\nfrom importlib._bootstrap_external import SourcelessFileLoader\n\nfrom importlib import machinery\nfrom importlib import util\nimport importlib\nimport os\nimport sys\nimport tokenize\nimport types\nimport warnings\n\nwarnings.warn(\"the imp module is deprecated in favour of importlib; \"\n\"see the module's documentation for alternative uses\",\nDeprecationWarning,stacklevel=2)\n\n\nSEARCH_ERROR=0\nPY_SOURCE=1\nPY_COMPILED=2\nC_EXTENSION=3\nPY_RESOURCE=4\nPKG_DIRECTORY=5\nC_BUILTIN=6\nPY_FROZEN=7\nPY_CODERESOURCE=8\nIMP_HOOK=9\n\n\ndef new_module(name):\n ''\n\n\n\n\n\n \n return types.ModuleType(name)\n \n \ndef get_magic():\n ''\n\n\n \n return util.MAGIC_NUMBER\n \n \ndef get_tag():\n ''\n return sys.implementation.cache_tag\n \n \ndef cache_from_source(path,debug_override=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n with warnings.catch_warnings():\n  warnings.simplefilter('ignore')\n  return util.cache_from_source(path,debug_override)\n  \n  \ndef source_from_cache(path):\n ''\n\n\n\n\n\n\n\n\n \n return util.source_from_cache(path)\n \n \ndef get_suffixes():\n ''\n extensions=[(s,'rb',C_EXTENSION)for s in machinery.EXTENSION_SUFFIXES]\n source=[(s,'r',PY_SOURCE)for s in machinery.SOURCE_SUFFIXES]\n bytecode=[(s,'rb',PY_COMPILED)for s in machinery.BYTECODE_SUFFIXES]\n \n return extensions+source+bytecode\n \n \nclass NullImporter:\n\n ''\n\n\n\n \n \n def __init__(self,path):\n  if path =='':\n   raise ImportError('empty pathname',path='')\n  elif os.path.isdir(path):\n   raise ImportError('existing directory',path=path)\n   \n def find_module(self,fullname):\n  ''\n  return None\n  \n  \nclass _HackedGetData:\n\n ''\n \n \n def __init__(self,fullname,path,file=None ):\n  super().__init__(fullname,path)\n  self.file=file\n  \n def get_data(self,path):\n  ''\n  if self.file and path ==self.path:\n  \n  \n   if not self.file.closed:\n    file=self.file\n    if 'b'not in file.mode:\n     file.close()\n   if self.file.closed:\n    self.file=file=open(self.path,'rb')\n    \n   with file:\n    return file.read()\n  else :\n   return super().get_data(path)\n   \n   \nclass _LoadSourceCompatibility(_HackedGetData,machinery.SourceFileLoader):\n\n ''\n \n \ndef load_source(name,pathname,file=None ):\n loader=_LoadSourceCompatibility(name,pathname,file)\n spec=util.spec_from_file_location(name,pathname,loader=loader)\n if name in sys.modules:\n  module=_exec(spec,sys.modules[name])\n else :\n  module=_load(spec)\n  \n  \n module.__loader__=machinery.SourceFileLoader(name,pathname)\n module.__spec__.loader=module.__loader__\n return module\n \n \nclass _LoadCompiledCompatibility(_HackedGetData,SourcelessFileLoader):\n\n ''\n \n \ndef load_compiled(name,pathname,file=None ):\n ''\n loader=_LoadCompiledCompatibility(name,pathname,file)\n spec=util.spec_from_file_location(name,pathname,loader=loader)\n if name in sys.modules:\n  module=_exec(spec,sys.modules[name])\n else :\n  module=_load(spec)\n  \n  \n module.__loader__=SourcelessFileLoader(name,pathname)\n module.__spec__.loader=module.__loader__\n return module\n \n \ndef load_package(name,path):\n ''\n if os.path.isdir(path):\n  extensions=(machinery.SOURCE_SUFFIXES[:]+\n  machinery.BYTECODE_SUFFIXES[:])\n  for extension in extensions:\n   init_path=os.path.join(path,'__init__'+extension)\n   if os.path.exists(init_path):\n    path=init_path\n    break\n  else :\n   raise ValueError('{!r} is not a package'.format(path))\n spec=util.spec_from_file_location(name,path,\n submodule_search_locations=[])\n if name in sys.modules:\n  return _exec(spec,sys.modules[name])\n else :\n  return _load(spec)\n  \n  \ndef load_module(name,file,filename,details):\n ''\n\n\n\n\n\n \n suffix,mode,type_=details\n if mode and (not mode.startswith(('r','U'))or '+'in mode):\n  raise ValueError('invalid file open mode {!r}'.format(mode))\n elif file is None and type_ in {PY_SOURCE,PY_COMPILED}:\n  msg='file object required for import (type code {})'.format(type_)\n  raise ValueError(msg)\n elif type_ ==PY_SOURCE:\n  return load_source(name,filename,file)\n elif type_ ==PY_COMPILED:\n  return load_compiled(name,filename,file)\n elif type_ ==C_EXTENSION and load_dynamic is not None :\n  if file is None :\n   with open(filename,'rb')as opened_file:\n    return load_dynamic(name,filename,opened_file)\n  else :\n   return load_dynamic(name,filename,file)\n elif type_ ==PKG_DIRECTORY:\n  return load_package(name,filename)\n elif type_ ==C_BUILTIN:\n  return init_builtin(name)\n elif type_ ==PY_FROZEN:\n  return init_frozen(name)\n else :\n  msg=\"Don't know how to import {} (type code {})\".format(name,type_)\n  raise ImportError(msg,name=name)\n  \n  \ndef find_module(name,path=None ):\n ''\n\n\n\n\n\n\n\n\n \n if not isinstance(name,str):\n  raise TypeError(\"'name' must be a str, not {}\".format(type(name)))\n elif not isinstance(path,(type(None ),list)):\n \n  raise RuntimeError(\"'path' must be None or a list, \"\n  \"not {}\".format(type(path)))\n  \n if path is None :\n  if is_builtin(name):\n   return None ,None ,('','',C_BUILTIN)\n  elif is_frozen(name):\n   return None ,None ,('','',PY_FROZEN)\n  else :\n   path=sys.path\n   \n for entry in path:\n  package_directory=os.path.join(entry,name)\n  for suffix in ['.py',machinery.BYTECODE_SUFFIXES[0]]:\n   package_file_name='__init__'+suffix\n   file_path=os.path.join(package_directory,package_file_name)\n   if os.path.isfile(file_path):\n    return None ,package_directory,('','',PKG_DIRECTORY)\n  for suffix,mode,type_ in get_suffixes():\n   file_name=name+suffix\n   file_path=os.path.join(entry,file_name)\n   if os.path.isfile(file_path):\n    break\n  else :\n   continue\n  break\n else :\n  raise ImportError(_ERR_MSG.format(name),name=name)\n  \n encoding=None\n if 'b'not in mode:\n  with open(file_path,'rb')as file:\n   encoding=tokenize.detect_encoding(file.readline)[0]\n file=open(file_path,mode,encoding=encoding)\n return file,file_path,(suffix,mode,type_)\n \n \ndef reload(module):\n ''\n\n\n\n\n\n \n return importlib.reload(module)\n \n \ndef init_builtin(name):\n ''\n\n\n\n \n try :\n  return _builtin_from_name(name)\n except ImportError:\n  return None\n  \n  \nif create_dynamic:\n def load_dynamic(name,path,file=None ):\n  ''\n\n\n  \n  import importlib.machinery\n  loader=importlib.machinery.ExtensionFileLoader(name,path)\n  \n  \n  \n  spec=importlib.machinery.ModuleSpec(\n  name=name,loader=loader,origin=path)\n  return _load(spec)\n  \nelse :\n load_dynamic=None\n", ["_imp", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "importlib.machinery", "importlib.util", "os", "sys", "tokenize", "types", "warnings"]], "site": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\nimport os\nimport builtins\nimport _sitebuiltins\nimport io\n\n\nPREFIXES=[sys.prefix,sys.exec_prefix]\n\n\nENABLE_USER_SITE=None\n\n\n\n\nUSER_SITE=None\nUSER_BASE=None\n\n\ndef makepath(*paths):\n dir=os.path.join(*paths)\n try :\n  dir=os.path.abspath(dir)\n except OSError:\n  pass\n return dir,os.path.normcase(dir)\n \n \ndef abs_paths():\n ''\n for m in set(sys.modules.values()):\n  if (getattr(getattr(m,'__loader__',None ),'__module__',None )not in\n  ('_frozen_importlib','_frozen_importlib_external')):\n   continue\n  try :\n   m.__file__=os.path.abspath(m.__file__)\n  except (AttributeError,OSError,TypeError):\n   pass\n  try :\n   m.__cached__=os.path.abspath(m.__cached__)\n  except (AttributeError,OSError,TypeError):\n   pass\n   \n   \ndef removeduppaths():\n ''\n \n \n \n L=[]\n known_paths=set()\n for dir in sys.path:\n \n \n \n  dir,dircase=makepath(dir)\n  if dircase not in known_paths:\n   L.append(dir)\n   known_paths.add(dircase)\n sys.path[:]=L\n return known_paths\n \n \ndef _init_pathinfo():\n ''\n d=set()\n for item in sys.path:\n  try :\n   if os.path.exists(item):\n    _,itemcase=makepath(item)\n    d.add(itemcase)\n  except TypeError:\n   continue\n return d\n \n \ndef addpackage(sitedir,name,known_paths):\n ''\n\n\n \n if known_paths is None :\n  known_paths=_init_pathinfo()\n  reset=True\n else :\n  reset=False\n fullname=os.path.join(sitedir,name)\n try :\n  f=io.TextIOWrapper(io.open_code(fullname))\n except OSError:\n  return\n with f:\n  for n,line in enumerate(f):\n   if line.startswith(\"#\"):\n    continue\n   try :\n    if line.startswith((\"import \",\"import\\t\")):\n     exec(line)\n     continue\n    line=line.rstrip()\n    dir,dircase=makepath(sitedir,line)\n    if not dircase in known_paths and os.path.exists(dir):\n     sys.path.append(dir)\n     known_paths.add(dircase)\n   except Exception:\n    print(\"Error processing line {:d} of {}:\\n\".format(n+1,fullname),\n    file=sys.stderr)\n    import traceback\n    for record in traceback.format_exception(*sys.exc_info()):\n     for line in record.splitlines():\n      print('  '+line,file=sys.stderr)\n    print(\"\\nRemainder of file ignored\",file=sys.stderr)\n    break\n if reset:\n  known_paths=None\n return known_paths\n \n \ndef addsitedir(sitedir,known_paths=None ):\n ''\n \n if known_paths is None :\n  known_paths=_init_pathinfo()\n  reset=True\n else :\n  reset=False\n sitedir,sitedircase=makepath(sitedir)\n if not sitedircase in known_paths:\n  sys.path.append(sitedir)\n  known_paths.add(sitedircase)\n try :\n  names=os.listdir(sitedir)\n except OSError:\n  return\n names=[name for name in names if name.endswith(\".pth\")]\n for name in sorted(names):\n  addpackage(sitedir,name,known_paths)\n if reset:\n  known_paths=None\n return known_paths\n \n \ndef check_enableusersite():\n ''\n\n\n\n\n\n\n\n \n if sys.flags.no_user_site:\n  return False\n  \n if hasattr(os,\"getuid\")and hasattr(os,\"geteuid\"):\n \n  if os.geteuid()!=os.getuid():\n   return None\n if hasattr(os,\"getgid\")and hasattr(os,\"getegid\"):\n \n  if os.getegid()!=os.getgid():\n   return None\n   \n return True\n \n \n \n \n \n \n \n \n \ndef _getuserbase():\n env_base=os.environ.get(\"PYTHONUSERBASE\",None )\n if env_base:\n  return env_base\n  \n def joinuser(*args):\n  return os.path.expanduser(os.path.join(*args))\n  \n if os.name ==\"nt\":\n  base=os.environ.get(\"APPDATA\")or \"~\"\n  return joinuser(base,\"Python\")\n  \n if sys.platform ==\"darwin\"and sys._framework:\n  return joinuser(\"~\",\"Library\",sys._framework,\n  \"%d.%d\"%sys.version_info[:2])\n  \n return joinuser(\"~\",\".local\")\n \n \n \ndef _get_path(userbase):\n version=sys.version_info\n \n if os.name =='nt':\n  return f'{userbase}\\\\Python{version[0]}{version[1]}\\\\site-packages'\n  \n if sys.platform =='darwin'and sys._framework:\n  return f'{userbase}/lib/python/site-packages'\n  \n return f'{userbase}/lib/python{version[0]}.{version[1]}/site-packages'\n \n \ndef getuserbase():\n ''\n\n\n\n\n \n global USER_BASE\n if USER_BASE is None :\n  USER_BASE=_getuserbase()\n return USER_BASE\n \n \ndef getusersitepackages():\n ''\n\n\n\n \n global USER_SITE\n userbase=getuserbase()\n \n if USER_SITE is None :\n  USER_SITE=_get_path(userbase)\n  \n return USER_SITE\n \ndef addusersitepackages(known_paths):\n ''\n\n\n\n \n \n \n user_site=getusersitepackages()\n \n if ENABLE_USER_SITE and os.path.isdir(user_site):\n  addsitedir(user_site,known_paths)\n return known_paths\n \ndef getsitepackages(prefixes=None ):\n ''\n\n\n\n\n \n sitepackages=[]\n seen=set()\n \n if prefixes is None :\n  prefixes=PREFIXES\n  \n for prefix in prefixes:\n  if not prefix or prefix in seen:\n   continue\n  seen.add(prefix)\n  \n  if os.sep =='/':\n   sitepackages.append(os.path.join(prefix,\"lib\",\n   \"python%d.%d\"%sys.version_info[:2],\n   \"site-packages\"))\n  else :\n   sitepackages.append(prefix)\n   sitepackages.append(os.path.join(prefix,\"lib\",\"site-packages\"))\n return sitepackages\n \ndef addsitepackages(known_paths,prefixes=None ):\n ''\n for sitedir in getsitepackages(prefixes):\n  if os.path.isdir(sitedir):\n   addsitedir(sitedir,known_paths)\n   \n return known_paths\n \ndef setquit():\n ''\n\n\n\n\n \n if os.sep =='\\\\':\n  eof='Ctrl-Z plus Return'\n else :\n  eof='Ctrl-D (i.e. EOF)'\n  \n builtins.quit=_sitebuiltins.Quitter('quit',eof)\n builtins.exit=_sitebuiltins.Quitter('exit',eof)\n \n \ndef setcopyright():\n ''\n builtins.copyright=_sitebuiltins._Printer(\"copyright\",sys.copyright)\n if sys.platform[:4]=='java':\n  builtins.credits=_sitebuiltins._Printer(\n  \"credits\",\n  \"Jython is maintained by the Jython developers (www.jython.org).\")\n else :\n  builtins.credits=_sitebuiltins._Printer(\"credits\",\"\"\"\\\n    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information.\"\"\")\n files,dirs=[],[]\n \n \n if hasattr(os,'__file__'):\n  here=os.path.dirname(os.__file__)\n  files.extend([\"LICENSE.txt\",\"LICENSE\"])\n  dirs.extend([os.path.join(here,os.pardir),here,os.curdir])\n builtins.license=_sitebuiltins._Printer(\n \"license\",\n \"See https://www.python.org/psf/license/\",\n files,dirs)\n \n \ndef sethelper():\n builtins.help=_sitebuiltins._Helper()\n \ndef enablerlcompleter():\n ''\n\n\n\n\n\n\n \n def register_readline():\n  import atexit\n  try :\n   import readline\n   import rlcompleter\n  except ImportError:\n   return\n   \n   \n   \n  readline_doc=getattr(readline,'__doc__','')\n  if readline_doc is not None and 'libedit'in readline_doc:\n   readline.parse_and_bind('bind ^I rl_complete')\n  else :\n   readline.parse_and_bind('tab: complete')\n   \n  try :\n   readline.read_init_file()\n  except OSError:\n  \n  \n  \n  \n   pass\n   \n  if readline.get_current_history_length()==0:\n  \n  \n  \n  \n  \n   history=os.path.join(os.path.expanduser('~'),\n   '.python_history')\n   try :\n    readline.read_history_file(history)\n   except OSError:\n    pass\n    \n   def write_history():\n    try :\n     readline.write_history_file(history)\n    except (FileNotFoundError,PermissionError):\n    \n    \n     pass\n     \n   atexit.register(write_history)\n   \n sys.__interactivehook__=register_readline\n \ndef venv(known_paths):\n global PREFIXES,ENABLE_USER_SITE\n \n env=os.environ\n if sys.platform =='darwin'and '__PYVENV_LAUNCHER__'in env:\n  executable=sys._base_executable=os.environ['__PYVENV_LAUNCHER__']\n else :\n  executable=sys.executable\n exe_dir,_=os.path.split(os.path.abspath(executable))\n site_prefix=os.path.dirname(exe_dir)\n sys._home=None\n conf_basename='pyvenv.cfg'\n candidate_confs=[\n conffile for conffile in (\n os.path.join(exe_dir,conf_basename),\n os.path.join(site_prefix,conf_basename)\n )\n if os.path.isfile(conffile)\n ]\n \n if candidate_confs:\n  virtual_conf=candidate_confs[0]\n  system_site=\"true\"\n  \n  \n  with open(virtual_conf,encoding='utf-8')as f:\n   for line in f:\n    if '='in line:\n     key,_,value=line.partition('=')\n     key=key.strip().lower()\n     value=value.strip()\n     if key =='include-system-site-packages':\n      system_site=value.lower()\n     elif key =='home':\n      sys._home=value\n      \n  sys.prefix=sys.exec_prefix=site_prefix\n  \n  \n  addsitepackages(known_paths,[sys.prefix])\n  \n  \n  \n  if system_site ==\"true\":\n   PREFIXES.insert(0,sys.prefix)\n  else :\n   PREFIXES=[sys.prefix]\n   ENABLE_USER_SITE=False\n   \n return known_paths\n \n \ndef execsitecustomize():\n ''\n try :\n  try :\n   import sitecustomize\n  except ImportError as exc:\n   if exc.name =='sitecustomize':\n    pass\n   else :\n    raise\n except Exception as err:\n  if sys.flags.verbose:\n   sys.excepthook(*sys.exc_info())\n  else :\n   sys.stderr.write(\n   \"Error in sitecustomize; set PYTHONVERBOSE for traceback:\\n\"\n   \"%s: %s\\n\"%\n   (err.__class__.__name__,err))\n   \n   \ndef execusercustomize():\n ''\n try :\n  try :\n   import usercustomize\n  except ImportError as exc:\n   if exc.name =='usercustomize':\n    pass\n   else :\n    raise\n except Exception as err:\n  if sys.flags.verbose:\n   sys.excepthook(*sys.exc_info())\n  else :\n   sys.stderr.write(\n   \"Error in usercustomize; set PYTHONVERBOSE for traceback:\\n\"\n   \"%s: %s\\n\"%\n   (err.__class__.__name__,err))\n   \n   \ndef main():\n ''\n\n\n\n \n global ENABLE_USER_SITE\n \n orig_path=sys.path[:]\n known_paths=removeduppaths()\n if orig_path !=sys.path:\n \n \n  abs_paths()\n  \n known_paths=venv(known_paths)\n if ENABLE_USER_SITE is None :\n  ENABLE_USER_SITE=check_enableusersite()\n known_paths=addusersitepackages(known_paths)\n known_paths=addsitepackages(known_paths)\n setquit()\n setcopyright()\n sethelper()\n if not sys.flags.isolated:\n  enablerlcompleter()\n execsitecustomize()\n if ENABLE_USER_SITE:\n  execusercustomize()\n  \n  \n  \nif not sys.flags.no_site:\n main()\n \ndef _script():\n help=\"\"\"\\\n    %s [--user-base] [--user-site]\n\n    Without arguments print some useful information\n    With arguments print the value of USER_BASE and/or USER_SITE separated\n    by '%s'.\n\n    Exit codes with --user-base or --user-site:\n      0 - user site directory is enabled\n      1 - user site directory is disabled by user\n      2 - uses site directory is disabled by super user\n          or for security reasons\n     >2 - unknown error\n    \"\"\"\n args=sys.argv[1:]\n if not args:\n  user_base=getuserbase()\n  user_site=getusersitepackages()\n  print(\"sys.path = [\")\n  for dir in sys.path:\n   print(\"    %r,\"%(dir,))\n  print(\"]\")\n  print(\"USER_BASE: %r (%s)\"%(user_base,\n  \"exists\"if os.path.isdir(user_base)else \"doesn't exist\"))\n  print(\"USER_SITE: %r (%s)\"%(user_site,\n  \"exists\"if os.path.isdir(user_site)else \"doesn't exist\"))\n  print(\"ENABLE_USER_SITE: %r\"%ENABLE_USER_SITE)\n  sys.exit(0)\n  \n buffer=[]\n if '--user-base'in args:\n  buffer.append(USER_BASE)\n if '--user-site'in args:\n  buffer.append(USER_SITE)\n  \n if buffer:\n  print(os.pathsep.join(buffer))\n  if ENABLE_USER_SITE:\n   sys.exit(0)\n  elif ENABLE_USER_SITE is False :\n   sys.exit(1)\n  elif ENABLE_USER_SITE is None :\n   sys.exit(2)\n  else :\n   sys.exit(3)\n else :\n  import textwrap\n  print(textwrap.dedent(help %(sys.argv[0],os.pathsep)))\n  sys.exit(10)\n  \nif __name__ =='__main__':\n _script()\n", ["_sitebuiltins", "atexit", "builtins", "io", "os", "readline", "rlcompleter", "sitecustomize", "sys", "textwrap", "traceback", "usercustomize"]], "py_compile": [".py", "''\n\n\n\n\nimport enum\nimport importlib._bootstrap_external\nimport importlib.machinery\nimport importlib.util\nimport os\nimport os.path\nimport sys\nimport traceback\n\n__all__=[\"compile\",\"main\",\"PyCompileError\",\"PycInvalidationMode\"]\n\n\nclass PyCompileError(Exception):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,exc_type,exc_value,file,msg=''):\n  exc_type_name=exc_type.__name__\n  if exc_type is SyntaxError:\n   tbtext=''.join(traceback.format_exception_only(\n   exc_type,exc_value))\n   errmsg=tbtext.replace('File \"<string>\"','File \"%s\"'%file)\n  else :\n   errmsg=\"Sorry: %s: %s\"%(exc_type_name,exc_value)\n   \n  Exception.__init__(self,msg or errmsg,exc_type_name,exc_value,file)\n  \n  self.exc_type_name=exc_type_name\n  self.exc_value=exc_value\n  self.file=file\n  self.msg=msg or errmsg\n  \n def __str__(self):\n  return self.msg\n  \n  \nclass PycInvalidationMode(enum.Enum):\n TIMESTAMP=1\n CHECKED_HASH=2\n UNCHECKED_HASH=3\n \n \ndef _get_default_invalidation_mode():\n if os.environ.get('SOURCE_DATE_EPOCH'):\n  return PycInvalidationMode.CHECKED_HASH\n else :\n  return PycInvalidationMode.TIMESTAMP\n  \n  \ndef compile(file,cfile=None ,dfile=None ,doraise=False ,optimize=-1,\ninvalidation_mode=None ,quiet=0):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if invalidation_mode is None :\n  invalidation_mode=_get_default_invalidation_mode()\n if cfile is None :\n  if optimize >=0:\n   optimization=optimize if optimize >=1 else ''\n   cfile=importlib.util.cache_from_source(file,\n   optimization=optimization)\n  else :\n   cfile=importlib.util.cache_from_source(file)\n if os.path.islink(cfile):\n  msg=('{} is a symlink and will be changed into a regular file if '\n  'import writes a byte-compiled file to it')\n  raise FileExistsError(msg.format(cfile))\n elif os.path.exists(cfile)and not os.path.isfile(cfile):\n  msg=('{} is a non-regular file and will be changed into a regular '\n  'one if import writes a byte-compiled file to it')\n  raise FileExistsError(msg.format(cfile))\n loader=importlib.machinery.SourceFileLoader('<py_compile>',file)\n source_bytes=loader.get_data(file)\n try :\n  code=loader.source_to_code(source_bytes,dfile or file,\n  _optimize=optimize)\n except Exception as err:\n  py_exc=PyCompileError(err.__class__,err,dfile or file)\n  if quiet <2:\n   if doraise:\n    raise py_exc\n   else :\n    sys.stderr.write(py_exc.msg+'\\n')\n  return\n try :\n  dirname=os.path.dirname(cfile)\n  if dirname:\n   os.makedirs(dirname)\n except FileExistsError:\n  pass\n if invalidation_mode ==PycInvalidationMode.TIMESTAMP:\n  source_stats=loader.path_stats(file)\n  bytecode=importlib._bootstrap_external._code_to_timestamp_pyc(\n  code,source_stats['mtime'],source_stats['size'])\n else :\n  source_hash=importlib.util.source_hash(source_bytes)\n  bytecode=importlib._bootstrap_external._code_to_hash_pyc(\n  code,\n  source_hash,\n  (invalidation_mode ==PycInvalidationMode.CHECKED_HASH),\n  )\n mode=importlib._bootstrap_external._calc_mode(file)\n importlib._bootstrap_external._write_atomic(cfile,bytecode,mode)\n return cfile\n \n \ndef main(args=None ):\n ''\n\n\n\n\n\n\n\n\n \n if args is None :\n  args=sys.argv[1:]\n rv=0\n if args ==['-']:\n  while True :\n   filename=sys.stdin.readline()\n   if not filename:\n    break\n   filename=filename.rstrip('\\n')\n   try :\n    compile(filename,doraise=True )\n   except PyCompileError as error:\n    rv=1\n    if quiet <2:\n     sys.stderr.write(\"%s\\n\"%error.msg)\n   except OSError as error:\n    rv=1\n    if quiet <2:\n     sys.stderr.write(\"%s\\n\"%error)\n else :\n  for filename in args:\n   try :\n    compile(filename,doraise=True )\n   except PyCompileError as error:\n   \n    rv=1\n    if quiet <2:\n     sys.stderr.write(\"%s\\n\"%error.msg)\n return rv\n \nif __name__ ==\"__main__\":\n sys.exit(main())\n", ["enum", "importlib._bootstrap_external", "importlib.machinery", "importlib.util", "os", "os.path", "sys", "traceback"]], "external_import": [".py", "import os\nfrom browser import doc\nimport urllib.request\n\n\n\n\n\nclass ModuleFinder:\n def __init__(self,path_entry):\n  print(\"external_import here..\")\n  \n  self._module=None\n  if path_entry.startswith('http://'):\n   self.path_entry=path_entry\n  else :\n   raise ImportError()\n   \n def __str__(self):\n  return '<%s for \"%s\">'%(self.__class__.__name__,self.path_entry)\n  \n def find_module(self,fullname,path=None ):\n  path=path or self.path_entry\n  \n  for _ext in ['js','pyj','py']:\n   _fp,_url,_headers=urllib.request.urlopen(path+'/'+'%s.%s'%(fullname,_ext))\n   self._module=_fp.read()\n   _fp.close()\n   if self._module is not None :\n    print(\"module found at %s:%s\"%(path,fullname))\n    return ModuleLoader(path,fullname,self._module)\n    \n  print('module %s not found'%fullname)\n  raise ImportError()\n  return None\n  \nclass ModuleLoader:\n ''\n \n def __init__(self,filepath,name,module_source):\n  self._filepath=filepath\n  self._name=name\n  self._module_source=module_source\n  \n def get_source(self):\n  return self._module_source\n  \n def is_package(self):\n  return '.'in self._name\n  \n def load_module(self):\n  if self._name in sys.modules:\n  \n   mod=sys.modules[self._name]\n   return mod\n   \n  _src=self.get_source()\n  if self._filepath.endswith('.js'):\n   mod=JSObject(import_js_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.py'):\n   mod=JSObject(import_py_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.pyj'):\n   mod=JSObject(import_pyj_module(_src,self._filepath,self._name))\n  else :\n   raise ImportError('Invalid Module: %s'%self._filepath)\n   \n   \n  mod.__file__=self._filepath\n  mod.__name__=self._name\n  mod.__path__=os.path.abspath(self._filepath)\n  mod.__loader__=self\n  mod.__package__='.'.join(self._name.split('.')[:-1])\n  \n  if self.is_package():\n   print('adding path for package')\n   \n   \n   mod.__path__=[self._filepath]\n  else :\n   print('imported as regular module')\n   \n  print('creating a new module object for \"%s\"'%self._name)\n  sys.modules.setdefault(self._name,mod)\n  JSObject(__BRYTHON__.imported)[self._name]=mod\n  \n  return mod\n", ["browser", "os", "urllib.request"]], "__future__": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nall_feature_names=[\n\"nested_scopes\",\n\"generators\",\n\"division\",\n\"absolute_import\",\n\"with_statement\",\n\"print_function\",\n\"unicode_literals\",\n\"barry_as_FLUFL\",\n\"generator_stop\",\n\"annotations\",\n]\n\n__all__=[\"all_feature_names\"]+all_feature_names\n\n\n\n\n\nCO_NESTED=0x0010\nCO_GENERATOR_ALLOWED=0\nCO_FUTURE_DIVISION=0x2000\nCO_FUTURE_ABSOLUTE_IMPORT=0x4000\nCO_FUTURE_WITH_STATEMENT=0x8000\nCO_FUTURE_PRINT_FUNCTION=0x10000\nCO_FUTURE_UNICODE_LITERALS=0x20000\nCO_FUTURE_BARRY_AS_BDFL=0x40000\nCO_FUTURE_GENERATOR_STOP=0x80000\nCO_FUTURE_ANNOTATIONS=0x100000\n\nclass _Feature:\n def __init__(self,optionalRelease,mandatoryRelease,compiler_flag):\n  self.optional=optionalRelease\n  self.mandatory=mandatoryRelease\n  self.compiler_flag=compiler_flag\n  \n def getOptionalRelease(self):\n  ''\n\n\n  \n  \n  return self.optional\n  \n def getMandatoryRelease(self):\n  ''\n\n\n\n  \n  \n  return self.mandatory\n  \n def __repr__(self):\n  return \"_Feature\"+repr((self.optional,\n  self.mandatory,\n  self.compiler_flag))\n  \nnested_scopes=_Feature((2,1,0,\"beta\",1),\n(2,2,0,\"alpha\",0),\nCO_NESTED)\n\ngenerators=_Feature((2,2,0,\"alpha\",1),\n(2,3,0,\"final\",0),\nCO_GENERATOR_ALLOWED)\n\ndivision=_Feature((2,2,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_DIVISION)\n\nabsolute_import=_Feature((2,5,0,\"alpha\",1),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_ABSOLUTE_IMPORT)\n\nwith_statement=_Feature((2,5,0,\"alpha\",1),\n(2,6,0,\"alpha\",0),\nCO_FUTURE_WITH_STATEMENT)\n\nprint_function=_Feature((2,6,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_PRINT_FUNCTION)\n\nunicode_literals=_Feature((2,6,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_UNICODE_LITERALS)\n\nbarry_as_FLUFL=_Feature((3,1,0,\"alpha\",2),\n(4,0,0,\"alpha\",0),\nCO_FUTURE_BARRY_AS_BDFL)\n\ngenerator_stop=_Feature((3,5,0,\"beta\",1),\n(3,7,0,\"alpha\",0),\nCO_FUTURE_GENERATOR_STOP)\n\nannotations=_Feature((3,7,0,\"beta\",1),\n(4,0,0,\"alpha\",0),\nCO_FUTURE_ANNOTATIONS)\n", []], "fnmatch": [".py", "''\n\n\n\n\n\n\n\n\n\n\nimport os\nimport posixpath\nimport re\nimport functools\n\n__all__=[\"filter\",\"fnmatch\",\"fnmatchcase\",\"translate\"]\n\ndef fnmatch(name,pat):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=os.path.normcase(name)\n pat=os.path.normcase(pat)\n return fnmatchcase(name,pat)\n \n@functools.lru_cache(maxsize=256,typed=True )\ndef _compile_pattern(pat):\n if isinstance(pat,bytes):\n  pat_str=str(pat,'ISO-8859-1')\n  res_str=translate(pat_str)\n  res=bytes(res_str,'ISO-8859-1')\n else :\n  res=translate(pat)\n return re.compile(res).match\n \ndef filter(names,pat):\n ''\n result=[]\n pat=os.path.normcase(pat)\n match=_compile_pattern(pat)\n if os.path is posixpath:\n \n  for name in names:\n   if match(name):\n    result.append(name)\n else :\n  for name in names:\n   if match(os.path.normcase(name)):\n    result.append(name)\n return result\n \ndef fnmatchcase(name,pat):\n ''\n\n\n\n \n match=_compile_pattern(pat)\n return match(name)is not None\n \n \ndef translate(pat):\n ''\n\n\n \n \n i,n=0,len(pat)\n res=''\n while i <n:\n  c=pat[i]\n  i=i+1\n  if c =='*':\n   res=res+'.*'\n  elif c =='?':\n   res=res+'.'\n  elif c =='[':\n   j=i\n   if j <n and pat[j]=='!':\n    j=j+1\n   if j <n and pat[j]==']':\n    j=j+1\n   while j <n and pat[j]!=']':\n    j=j+1\n   if j >=n:\n    res=res+'\\\\['\n   else :\n    stuff=pat[i:j]\n    if '--'not in stuff:\n     stuff=stuff.replace('\\\\',r'\\\\')\n    else :\n     chunks=[]\n     k=i+2 if pat[i]=='!'else i+1\n     while True :\n      k=pat.find('-',k,j)\n      if k <0:\n       break\n      chunks.append(pat[i:k])\n      i=k+1\n      k=k+3\n     chunks.append(pat[i:j])\n     \n     \n     stuff='-'.join(s.replace('\\\\',r'\\\\').replace('-',r'\\-')\n     for s in chunks)\n     \n    stuff=re.sub(r'([&~|])',r'\\\\\\1',stuff)\n    i=j+1\n    if stuff[0]=='!':\n     stuff='^'+stuff[1:]\n    elif stuff[0]in ('^','['):\n     stuff='\\\\'+stuff\n    res='%s[%s]'%(res,stuff)\n  else :\n   res=res+re.escape(c)\n return r'(?s:%s)\\Z'%res\n", ["functools", "os", "posixpath", "re"]], "token": [".py", "''\n\n\n__all__=['tok_name','ISTERMINAL','ISNONTERMINAL','ISEOF']\n\nENDMARKER=0\nNAME=1\nNUMBER=2\nSTRING=3\nNEWLINE=4\nINDENT=5\nDEDENT=6\nLPAR=7\nRPAR=8\nLSQB=9\nRSQB=10\nCOLON=11\nCOMMA=12\nSEMI=13\nPLUS=14\nMINUS=15\nSTAR=16\nSLASH=17\nVBAR=18\nAMPER=19\nLESS=20\nGREATER=21\nEQUAL=22\nDOT=23\nPERCENT=24\nLBRACE=25\nRBRACE=26\nEQEQUAL=27\nNOTEQUAL=28\nLESSEQUAL=29\nGREATEREQUAL=30\nTILDE=31\nCIRCUMFLEX=32\nLEFTSHIFT=33\nRIGHTSHIFT=34\nDOUBLESTAR=35\nPLUSEQUAL=36\nMINEQUAL=37\nSTAREQUAL=38\nSLASHEQUAL=39\nPERCENTEQUAL=40\nAMPEREQUAL=41\nVBAREQUAL=42\nCIRCUMFLEXEQUAL=43\nLEFTSHIFTEQUAL=44\nRIGHTSHIFTEQUAL=45\nDOUBLESTAREQUAL=46\nDOUBLESLASH=47\nDOUBLESLASHEQUAL=48\nAT=49\nATEQUAL=50\nRARROW=51\nELLIPSIS=52\nCOLONEQUAL=53\nOP=54\nAWAIT=55\nASYNC=56\nTYPE_IGNORE=57\nTYPE_COMMENT=58\n\nERRORTOKEN=59\nCOMMENT=60\nNL=61\nENCODING=62\nN_TOKENS=63\n\nNT_OFFSET=256\n\ntok_name={value:name\nfor name,value in globals().items()\nif isinstance(value,int)and not name.startswith('_')}\n__all__.extend(tok_name.values())\n\nEXACT_TOKEN_TYPES={\n'!=':NOTEQUAL,\n'%':PERCENT,\n'%=':PERCENTEQUAL,\n'&':AMPER,\n'&=':AMPEREQUAL,\n'(':LPAR,\n')':RPAR,\n'*':STAR,\n'**':DOUBLESTAR,\n'**=':DOUBLESTAREQUAL,\n'*=':STAREQUAL,\n'+':PLUS,\n'+=':PLUSEQUAL,\n',':COMMA,\n'-':MINUS,\n'-=':MINEQUAL,\n'->':RARROW,\n'.':DOT,\n'...':ELLIPSIS,\n'/':SLASH,\n'//':DOUBLESLASH,\n'//=':DOUBLESLASHEQUAL,\n'/=':SLASHEQUAL,\n':':COLON,\n':=':COLONEQUAL,\n';':SEMI,\n'<':LESS,\n'<<':LEFTSHIFT,\n'<<=':LEFTSHIFTEQUAL,\n'<=':LESSEQUAL,\n'=':EQUAL,\n'==':EQEQUAL,\n'>':GREATER,\n'>=':GREATEREQUAL,\n'>>':RIGHTSHIFT,\n'>>=':RIGHTSHIFTEQUAL,\n'@':AT,\n'@=':ATEQUAL,\n'[':LSQB,\n']':RSQB,\n'^':CIRCUMFLEX,\n'^=':CIRCUMFLEXEQUAL,\n'{':LBRACE,\n'|':VBAR,\n'|=':VBAREQUAL,\n'}':RBRACE,\n'~':TILDE,\n}\n\ndef ISTERMINAL(x):\n return x <NT_OFFSET\n \ndef ISNONTERMINAL(x):\n return x >=NT_OFFSET\n \ndef ISEOF(x):\n return x ==ENDMARKER\n", []], "sys": [".py", "\nfrom _sys import *\nimport javascript\n\n_getframe=Getframe\n\nabiflags=0\n\ndef audit(event,*args):\n ''\n pass\n \nbrython_debug_mode=__BRYTHON__.debug\n\nbase_exec_prefix=__BRYTHON__.brython_path\n\nbase_prefix=__BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ndont_write_bytecode=True\n\nexec_prefix=__BRYTHON__.brython_path\n\nexecutable=__BRYTHON__.brython_path+'/brython.js'\n\nargv=[__BRYTHON__.script_path]\n\n\ndef displayhook(value):\n if value is not None :\n  stdout.write(repr(value))\n  \ndef exit(i=None ):\n raise SystemExit('')\n \nclass flag_class:\n\n def __init__(self):\n  self.debug=0\n  self.inspect=0\n  self.interactive=0\n  self.optimize=0\n  self.dont_write_bytecode=0\n  self.no_user_site=0\n  self.no_site=0\n  self.ignore_environment=0\n  self.verbose=0\n  self.bytes_warning=0\n  self.quiet=0\n  self.hash_randomization=1\n  \nflags=flag_class()\n\nclass float_info:\n mant_dig=53\n max=javascript.Number.MAX_VALUE\n min=javascript.Number.MIN_VALUE\n radix=2\n \ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return 'utf-8'\n \ndef getfilesystemencodeerrors():\n return \"utf-8\"\n \ndef getrecursionlimit():\n return 200\n \ndef intern(string):\n return string\n \nclass int_info:\n bits_per_digit=30\n sizeof_digit=4\n \nmaxsize=2 **63 -1\n\nmaxunicode=1114111\n\nplatform=\"brython\"\n\nprefix=__BRYTHON__.brython_path\n\nversion='.'.join(str(x)for x in __BRYTHON__.version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"\\\n%__BRYTHON__.compiled_date\nhexversion=0x030800f0\n\nclass _version_info:\n\n def __init__(self,version_info):\n  self.version_info=version_info\n  self.major=version_info[0]\n  self.minor=version_info[1]\n  self.micro=version_info[2]\n  self.releaselevel=version_info[3]\n  self.serial=version_info[4]\n  \n def __getitem__(self,index):\n  if isinstance(self.version_info[index],list):\n   return tuple(self.version_info[index])\n  return self.version_info[index]\n  \n def hexversion(self):\n  try :\n   return '0%d0%d0%d'%(self.major,self.minor,self.micro)\n  finally :\n   return '0%d0000'%(self.major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', \"\\\n  \"serial=%d)\"\n  return _s %(self.major,self.minor,self.micro,\n  self.releaselevel,self.serial)\n  \n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)==other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)!=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=_version_info(__BRYTHON__.version_info)\n\nclass _implementation:\n\n def __init__(self):\n  self.name='brython'\n  self.version=_version_info(__BRYTHON__.implementation)\n  self.hexversion=self.version.hexversion()\n  self.cache_tag=None\n  \n def __repr__(self):\n  return \"namespace(name='%s' version=%s hexversion='%s')\"%(self.name,\n  self.version,self.hexversion)\n  \n def __str__(self):\n  return \"namespace(name='%s' version=%s hexversion='%s')\"%(self.name,\n  self.version,self.hexversion)\n  \nimplementation=_implementation()\n\nclass _hash_info:\n\n def __init__(self):\n  self.width=32\n  self.modulus=2147483647\n  self.inf=314159\n  self.nan=0\n  self.imag=1000003\n  self.algorithm='siphash24'\n  self.hash_bits=64\n  self.seed_bits=128\n  cutoff=0\n  \n def __repr__(self):\n \n  return \"sys.hash_info(width=32, modulus=2147483647, inf=314159, \"\\\n  \"nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, \"\\\n  \"seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nclass _float_info:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  self.dig=15\n  self.epsilon=2 **-52\n  self.mant_dig=53\n  self.max=javascript.Number.MAX_VALUE\n  self.max_exp=2 **10\n  self.max_10_exp=308\n  self.min=2 **(-1022)\n  self.min_exp=-1021\n  self.min_10_exp=-307\n  self.radix=2\n  self.rounds=1\n  self._tuple=(self.max,self.max_exp,self.max_10_exp,self.min,\n  self.min_exp,self.min_10_exp,self.dig,self.mant_dig,self.epsilon,\n  self.radix,self.rounds)\n  \n def __getitem__(self,k):\n  return self._tuple[k]\n  \n def __iter__(self):\n  return iter(self._tuple)\n  \nfloat_info=_float_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n \n \n__stdout__=__BRYTHON__.stdout\n__stderr__=__BRYTHON__.stderr\n__stdin__=__BRYTHON__.stdin\n\n__excepthook__=excepthook\n", ["_sys", "javascript"]], "tokenize": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__='Ka-Ping Yee <ping@lfw.org>'\n__credits__=('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup,BOM_UTF8\nimport collections\nfrom io import TextIOWrapper\nimport itertools as _itertools\nimport re\nimport sys\nfrom token import *\nfrom token import EXACT_TOKEN_TYPES\n\ncookie_re=re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)',re.ASCII)\nblank_re=re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)',re.ASCII)\n\nimport token\n__all__=token.__all__+[\"tokenize\",\"generate_tokens\",\"detect_encoding\",\n\"untokenize\",\"TokenInfo\"]\ndel token\n\nclass TokenInfo(collections.namedtuple('TokenInfo','type string start end line')):\n def __repr__(self):\n  annotated_type='%d (%s)'%(self.type,tok_name[self.type])\n  return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)'%\n  self._replace(type=annotated_type))\n  \n @property\n def exact_type(self):\n  if self.type ==OP and self.string in EXACT_TOKEN_TYPES:\n   return EXACT_TOKEN_TYPES[self.string]\n  else :\n   return self.type\n   \ndef group(*choices):return '('+'|'.join(choices)+')'\ndef any(*choices):return group(*choices)+'*'\ndef maybe(*choices):return group(*choices)+'?'\n\n\n\nWhitespace=r'[ \\f\\t]*'\nComment=r'#[^\\r\\n]*'\nIgnore=Whitespace+any(r'\\\\\\r?\\n'+Whitespace)+maybe(Comment)\nName=r'\\w+'\n\nHexnumber=r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber=r'0[bB](?:_?[01])+'\nOctnumber=r'0[oO](?:_?[0-7])+'\nDecnumber=r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber=group(Hexnumber,Binnumber,Octnumber,Decnumber)\nExponent=r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat=group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\nr'\\.[0-9](?:_?[0-9])*')+maybe(Exponent)\nExpfloat=r'[0-9](?:_?[0-9])*'+Exponent\nFloatnumber=group(Pointfloat,Expfloat)\nImagnumber=group(r'[0-9](?:_?[0-9])*[jJ]',Floatnumber+r'[jJ]')\nNumber=group(Imagnumber,Floatnumber,Intnumber)\n\n\ndef _all_string_prefixes():\n\n\n\n _valid_string_prefixes=['b','r','u','f','br','fr']\n \n result={''}\n for prefix in _valid_string_prefixes:\n  for t in _itertools.permutations(prefix):\n  \n  \n   for u in _itertools.product(*[(c,c.upper())for c in t]):\n    result.add(''.join(u))\n return result\n \ndef _compile(expr):\n return re.compile(expr,re.UNICODE)\n \n \n \nStringPrefix=group(*_all_string_prefixes())\n\n\nSingle=r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n\nDouble=r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n\nSingle3=r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n\nDouble3=r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple=group(StringPrefix+\"'''\",StringPrefix+'\"\"\"')\n\nString=group(StringPrefix+r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\nStringPrefix+r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n\n\n\n\nSpecial=group(*map(re.escape,sorted(EXACT_TOKEN_TYPES,reverse=True )))\nFunny=group(r'\\r?\\n',Special)\n\nPlainToken=group(Number,Funny,String,Name)\nToken=Ignore+PlainToken\n\n\nContStr=group(StringPrefix+r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\"+\ngroup(\"'\",r'\\\\\\r?\\n'),\nStringPrefix+r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*'+\ngroup('\"',r'\\\\\\r?\\n'))\nPseudoExtras=group(r'\\\\\\r?\\n|\\Z',Comment,Triple)\nPseudoToken=Whitespace+group(PseudoExtras,Number,Funny,ContStr,Name)\n\n\n\n\nendpats={}\nfor _prefix in _all_string_prefixes():\n endpats[_prefix+\"'\"]=Single\n endpats[_prefix+'\"']=Double\n endpats[_prefix+\"'''\"]=Single3\n endpats[_prefix+'\"\"\"']=Double3\n \n \n \nsingle_quoted=set()\ntriple_quoted=set()\nfor t in _all_string_prefixes():\n for u in (t+'\"',t+\"'\"):\n  single_quoted.add(u)\n for u in (t+'\"\"\"',t+\"'''\"):\n  triple_quoted.add(u)\n  \ntabsize=8\n\nclass TokenError(Exception):pass\n\nclass StopTokenizing(Exception):pass\n\n\nclass Untokenizer:\n\n def __init__(self):\n  self.tokens=[]\n  self.prev_row=1\n  self.prev_col=0\n  self.encoding=None\n  \n def add_whitespace(self,start):\n  row,col=start\n  if row <self.prev_row or row ==self.prev_row and col <self.prev_col:\n   raise ValueError(\"start ({},{}) precedes previous end ({},{})\"\n   .format(row,col,self.prev_row,self.prev_col))\n  row_offset=row -self.prev_row\n  if row_offset:\n   self.tokens.append(\"\\\\\\n\"*row_offset)\n   self.prev_col=0\n  col_offset=col -self.prev_col\n  if col_offset:\n   self.tokens.append(\" \"*col_offset)\n   \n def untokenize(self,iterable):\n  it=iter(iterable)\n  indents=[]\n  startline=False\n  for t in it:\n   if len(t)==2:\n    self.compat(t,it)\n    break\n   tok_type,token,start,end,line=t\n   if tok_type ==ENCODING:\n    self.encoding=token\n    continue\n   if tok_type ==ENDMARKER:\n    break\n   if tok_type ==INDENT:\n    indents.append(token)\n    continue\n   elif tok_type ==DEDENT:\n    indents.pop()\n    self.prev_row,self.prev_col=end\n    continue\n   elif tok_type in (NEWLINE,NL):\n    startline=True\n   elif startline and indents:\n    indent=indents[-1]\n    if start[1]>=len(indent):\n     self.tokens.append(indent)\n     self.prev_col=len(indent)\n    startline=False\n   self.add_whitespace(start)\n   self.tokens.append(token)\n   self.prev_row,self.prev_col=end\n   if tok_type in (NEWLINE,NL):\n    self.prev_row +=1\n    self.prev_col=0\n  return \"\".join(self.tokens)\n  \n def compat(self,token,iterable):\n  indents=[]\n  toks_append=self.tokens.append\n  startline=token[0]in (NEWLINE,NL)\n  prevstring=False\n  \n  for tok in _itertools.chain([token],iterable):\n   toknum,tokval=tok[:2]\n   if toknum ==ENCODING:\n    self.encoding=tokval\n    continue\n    \n   if toknum in (NAME,NUMBER):\n    tokval +=' '\n    \n    \n   if toknum ==STRING:\n    if prevstring:\n     tokval=' '+tokval\n    prevstring=True\n   else :\n    prevstring=False\n    \n   if toknum ==INDENT:\n    indents.append(tokval)\n    continue\n   elif toknum ==DEDENT:\n    indents.pop()\n    continue\n   elif toknum in (NEWLINE,NL):\n    startline=True\n   elif startline and indents:\n    toks_append(indents[-1])\n    startline=False\n   toks_append(tokval)\n   \n   \ndef untokenize(iterable):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n ut=Untokenizer()\n out=ut.untokenize(iterable)\n if ut.encoding is not None :\n  out=out.encode(ut.encoding)\n return out\n \n \ndef _get_normal_name(orig_enc):\n ''\n \n enc=orig_enc[:12].lower().replace(\"_\",\"-\")\n if enc ==\"utf-8\"or enc.startswith(\"utf-8-\"):\n  return \"utf-8\"\n if enc in (\"latin-1\",\"iso-8859-1\",\"iso-latin-1\")or\\\n enc.startswith((\"latin-1-\",\"iso-8859-1-\",\"iso-latin-1-\")):\n  return \"iso-8859-1\"\n return orig_enc\n \ndef detect_encoding(readline):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  filename=readline.__self__.name\n except AttributeError:\n  filename=None\n bom_found=False\n encoding=None\n default='utf-8'\n def read_or_stop():\n  try :\n   return readline()\n  except StopIteration:\n   return b''\n   \n def find_cookie(line):\n  try :\n  \n  \n  \n   line_string=line.decode('utf-8')\n  except UnicodeDecodeError:\n   msg=\"invalid or missing encoding declaration\"\n   if filename is not None :\n    msg='{} for {!r}'.format(msg,filename)\n   raise SyntaxError(msg)\n   \n  match=cookie_re.match(line_string)\n  if not match:\n   return None\n  encoding=_get_normal_name(match.group(1))\n  try :\n   codec=lookup(encoding)\n  except LookupError:\n  \n   if filename is None :\n    msg=\"unknown encoding: \"+encoding\n   else :\n    msg=\"unknown encoding for {!r}: {}\".format(filename,\n    encoding)\n   raise SyntaxError(msg)\n   \n  if bom_found:\n   if encoding !='utf-8':\n   \n    if filename is None :\n     msg='encoding problem: utf-8'\n    else :\n     msg='encoding problem for {!r}: utf-8'.format(filename)\n    raise SyntaxError(msg)\n   encoding +='-sig'\n  return encoding\n  \n first=read_or_stop()\n if first.startswith(BOM_UTF8):\n  bom_found=True\n  first=first[3:]\n  default='utf-8-sig'\n if not first:\n  return default,[]\n  \n encoding=find_cookie(first)\n if encoding:\n  return encoding,[first]\n if not blank_re.match(first):\n  return default,[first]\n  \n second=read_or_stop()\n if not second:\n  return default,[first]\n  \n encoding=find_cookie(second)\n if encoding:\n  return encoding,[first,second]\n  \n return default,[first,second]\n \n \ndef open(filename):\n ''\n\n \n buffer=_builtin_open(filename,'rb')\n try :\n  encoding,lines=detect_encoding(buffer.readline)\n  buffer.seek(0)\n  text=TextIOWrapper(buffer,encoding,line_buffering=True )\n  text.mode='r'\n  return text\n except :\n  buffer.close()\n  raise\n  \n  \ndef tokenize(readline):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n encoding,consumed=detect_encoding(readline)\n empty=_itertools.repeat(b\"\")\n rl_gen=_itertools.chain(consumed,iter(readline,b\"\"),empty)\n return _tokenize(rl_gen.__next__,encoding)\n \n \ndef _tokenize(readline,encoding):\n lnum=parenlev=continued=0\n numchars='0123456789'\n contstr,needcont='',0\n contline=None\n indents=[0]\n \n if encoding is not None :\n  if encoding ==\"utf-8-sig\":\n  \n   encoding=\"utf-8\"\n  yield TokenInfo(ENCODING,encoding,(0,0),(0,0),'')\n last_line=b''\n line=b''\n while True :\n  try :\n  \n  \n  \n  \n   last_line=line\n   line=readline()\n  except StopIteration:\n   line=b''\n   \n  if encoding is not None :\n   line=line.decode(encoding)\n  lnum +=1\n  pos,max=0,len(line)\n  \n  if contstr:\n   if not line:\n    raise TokenError(\"EOF in multi-line string\",strstart)\n   endmatch=endprog.match(line)\n   if endmatch:\n    pos=end=endmatch.end(0)\n    yield TokenInfo(STRING,contstr+line[:end],\n    strstart,(lnum,end),contline+line)\n    contstr,needcont='',0\n    contline=None\n   elif needcont and line[-2:]!='\\\\\\n'and line[-3:]!='\\\\\\r\\n':\n    yield TokenInfo(ERRORTOKEN,contstr+line,\n    strstart,(lnum,len(line)),contline)\n    contstr=''\n    contline=None\n    continue\n   else :\n    contstr=contstr+line\n    contline=contline+line\n    continue\n    \n  elif parenlev ==0 and not continued:\n   if not line:break\n   column=0\n   while pos <max:\n    if line[pos]==' ':\n     column +=1\n    elif line[pos]=='\\t':\n     column=(column //tabsize+1)*tabsize\n    elif line[pos]=='\\f':\n     column=0\n    else :\n     break\n    pos +=1\n   if pos ==max:\n    break\n    \n   if line[pos]in '#\\r\\n':\n    if line[pos]=='#':\n     comment_token=line[pos:].rstrip('\\r\\n')\n     yield TokenInfo(COMMENT,comment_token,\n     (lnum,pos),(lnum,pos+len(comment_token)),line)\n     pos +=len(comment_token)\n     \n    yield TokenInfo(NL,line[pos:],\n    (lnum,pos),(lnum,len(line)),line)\n    continue\n    \n   if column >indents[-1]:\n    indents.append(column)\n    yield TokenInfo(INDENT,line[:pos],(lnum,0),(lnum,pos),line)\n   while column <indents[-1]:\n    if column not in indents:\n     raise IndentationError(\n     \"unindent does not match any outer indentation level\",\n     (\"<tokenize>\",lnum,pos,line))\n    indents=indents[:-1]\n    \n    yield TokenInfo(DEDENT,'',(lnum,pos),(lnum,pos),line)\n    \n  else :\n   if not line:\n    raise TokenError(\"EOF in multi-line statement\",(lnum,0))\n   continued=0\n   \n  while pos <max:\n   pseudomatch=_compile(PseudoToken).match(line,pos)\n   if pseudomatch:\n    start,end=pseudomatch.span(1)\n    spos,epos,pos=(lnum,start),(lnum,end),end\n    if start ==end:\n     continue\n    token,initial=line[start:end],line[start]\n    \n    if (initial in numchars or\n    (initial =='.'and token !='.'and token !='...')):\n     yield TokenInfo(NUMBER,token,spos,epos,line)\n    elif initial in '\\r\\n':\n     if parenlev >0:\n      yield TokenInfo(NL,token,spos,epos,line)\n     else :\n      yield TokenInfo(NEWLINE,token,spos,epos,line)\n      \n    elif initial =='#':\n     assert not token.endswith(\"\\n\")\n     yield TokenInfo(COMMENT,token,spos,epos,line)\n     \n    elif token in triple_quoted:\n     endprog=_compile(endpats[token])\n     endmatch=endprog.match(line,pos)\n     if endmatch:\n      pos=endmatch.end(0)\n      token=line[start:pos]\n      yield TokenInfo(STRING,token,spos,(lnum,pos),line)\n     else :\n      strstart=(lnum,start)\n      contstr=line[start:]\n      contline=line\n      break\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    elif (initial in single_quoted or\n    token[:2]in single_quoted or\n    token[:3]in single_quoted):\n     if token[-1]=='\\n':\n      strstart=(lnum,start)\n      \n      \n      \n      \n      \n      \n      endprog=_compile(endpats.get(initial)or\n      endpats.get(token[1])or\n      endpats.get(token[2]))\n      contstr,needcont=line[start:],1\n      contline=line\n      break\n     else :\n      yield TokenInfo(STRING,token,spos,epos,line)\n      \n    elif initial.isidentifier():\n     yield TokenInfo(NAME,token,spos,epos,line)\n    elif initial =='\\\\':\n     continued=1\n    else :\n     if initial in '([{':\n      parenlev +=1\n     elif initial in ')]}':\n      parenlev -=1\n     yield TokenInfo(OP,token,spos,epos,line)\n   else :\n    yield TokenInfo(ERRORTOKEN,line[pos],\n    (lnum,pos),(lnum,pos+1),line)\n    pos +=1\n    \n    \n if last_line and last_line[-1]not in '\\r\\n':\n  yield TokenInfo(NEWLINE,'',(lnum -1,len(last_line)),(lnum -1,len(last_line)+1),'')\n for indent in indents[1:]:\n  yield TokenInfo(DEDENT,'',(lnum,0),(lnum,0),'')\n yield TokenInfo(ENDMARKER,'',(lnum,0),(lnum,0),'')\n \n \ndef generate_tokens(readline):\n ''\n\n\n\n \n return _tokenize(readline,None )\n \ndef main():\n import argparse\n \n \n def perror(message):\n  sys.stderr.write(message)\n  sys.stderr.write('\\n')\n  \n def error(message,filename=None ,location=None ):\n  if location:\n   args=(filename,)+location+(message,)\n   perror(\"%s:%d:%d: error: %s\"%args)\n  elif filename:\n   perror(\"%s: error: %s\"%(filename,message))\n  else :\n   perror(\"error: %s\"%message)\n  sys.exit(1)\n  \n  \n parser=argparse.ArgumentParser(prog='python -m tokenize')\n parser.add_argument(dest='filename',nargs='?',\n metavar='filename.py',\n help='the file to tokenize; defaults to stdin')\n parser.add_argument('-e','--exact',dest='exact',action='store_true',\n help='display token names using the exact type')\n args=parser.parse_args()\n \n try :\n \n  if args.filename:\n   filename=args.filename\n   with _builtin_open(filename,'rb')as f:\n    tokens=list(tokenize(f.readline))\n  else :\n   filename=\"<stdin>\"\n   tokens=_tokenize(sys.stdin.readline,None )\n   \n   \n  for token in tokens:\n   token_type=token.type\n   if args.exact:\n    token_type=token.exact_type\n   token_range=\"%d,%d-%d,%d:\"%(token.start+token.end)\n   print(\"%-20s%-15s%-15r\"%\n   (token_range,tok_name[token_type],token.string))\n except IndentationError as err:\n  line,column=err.args[1][1:3]\n  error(err.args[0],filename,(line,column))\n except TokenError as err:\n  line,column=err.args[1]\n  error(err.args[0],filename,(line,column))\n except SyntaxError as err:\n  error(err,filename)\n except OSError as err:\n  error(err)\n except KeyboardInterrupt:\n  print(\"interrupted\\n\")\n except Exception as err:\n  perror(\"unexpected error: %s\"%err)\n  raise\n  \nif __name__ ==\"__main__\":\n main()\n", ["argparse", "builtins", "codecs", "collections", "io", "itertools", "re", "sys", "token"]], "_dummy_thread": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['error','start_new_thread','exit','get_ident','allocate_lock',\n'interrupt_main','LockType','RLock']\n\n\nTIMEOUT_MAX=2 **31\n\n\n\n\n\n\nerror=RuntimeError\n\ndef start_new_thread(function,args,kwargs={}):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if type(args)!=type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs)!=type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main=False\n try :\n  function(*args,**kwargs)\n except SystemExit:\n  pass\n except :\n  import traceback\n  traceback.print_exc()\n _main=True\n global _interrupt\n if _interrupt:\n  _interrupt=False\n  raise KeyboardInterrupt\n  \ndef exit():\n ''\n raise SystemExit\n \ndef get_ident():\n ''\n\n\n\n\n \n return 1\n \ndef allocate_lock():\n ''\n return LockType()\n \ndef stack_size(size=None ):\n ''\n if size is not None :\n  raise error(\"setting thread stack size not supported\")\n return 0\n \ndef _set_sentinel():\n ''\n return LockType()\n \nclass LockType(object):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self):\n  self.locked_status=False\n  \n def acquire(self,waitflag=None ,timeout=-1):\n  ''\n\n\n\n\n\n\n\n\n  \n  if waitflag is None or waitflag:\n   self.locked_status=True\n   return True\n  else :\n   if not self.locked_status:\n    self.locked_status=True\n    return True\n   else :\n    if timeout >0:\n     import time\n     time.sleep(timeout)\n    return False\n    \n __enter__=acquire\n \n def __exit__(self,typ,val,tb):\n  self.release()\n  \n def release(self):\n  ''\n  \n  \n  if not self.locked_status:\n   raise error\n  self.locked_status=False\n  return True\n  \n def locked(self):\n  return self.locked_status\n  \n def __repr__(self):\n  return \"<%s %s.%s object at %s>\"%(\n  \"locked\"if self.locked_status else \"unlocked\",\n  self.__class__.__module__,\n  self.__class__.__qualname__,\n  hex(id(self))\n  )\n  \n  \nclass RLock(LockType):\n ''\n\n\n\n\n\n \n def __init__(self):\n  super().__init__()\n  self._levels=0\n  \n def acquire(self,waitflag=None ,timeout=-1):\n  ''\n  \n  locked=super().acquire(waitflag,timeout)\n  if locked:\n   self._levels +=1\n  return locked\n  \n def release(self):\n  ''\n  \n  if self._levels ==0:\n   raise error\n  if self._levels ==1:\n   super().release()\n  self._levels -=1\n  \n  \n_interrupt=False\n\n_main=True\n\ndef interrupt_main():\n ''\n \n if _main:\n  raise KeyboardInterrupt\n else :\n  global _interrupt\n  _interrupt=True\n", ["time", "traceback"]], "pwd": [".py", "\ndef getpwuid():\n pass\n", []], "io": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__=(\"Guido van Rossum <guido@python.org>, \"\n\"Mike Verdone <mike.verdone@gmail.com>, \"\n\"Mark Russell <mark.russell@zen.co.uk>, \"\n\"Antoine Pitrou <solipsis@pitrou.net>, \"\n\"Amaury Forgeot d'Arc <amauryfa@gmail.com>, \"\n\"Benjamin Peterson <benjamin@python.org>\")\n\n__all__=[\"BlockingIOError\",\"open\",\"open_code\",\"IOBase\",\"RawIOBase\",\n\"FileIO\",\"BytesIO\",\"StringIO\",\"BufferedIOBase\",\n\"BufferedReader\",\"BufferedWriter\",\"BufferedRWPair\",\n\"BufferedRandom\",\"TextIOBase\",\"TextIOWrapper\",\n\"UnsupportedOperation\",\"SEEK_SET\",\"SEEK_CUR\",\"SEEK_END\"]\n\n\nimport _io\nimport abc\n\nfrom _io import (DEFAULT_BUFFER_SIZE,BlockingIOError,UnsupportedOperation,\nopen,open_code,FileIO,BytesIO,StringIO,BufferedReader,\nBufferedWriter,BufferedRWPair,BufferedRandom,\nIncrementalNewlineDecoder,TextIOWrapper)\n\nOpenWrapper=_io.open\n\n\nUnsupportedOperation.__module__=\"io\"\n\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\n\n\n\nclass IOBase(_io._IOBase,metaclass=abc.ABCMeta):\n __doc__=_io._IOBase.__doc__\n \nclass RawIOBase(_io._RawIOBase,IOBase):\n __doc__=_io._RawIOBase.__doc__\n \nclass BufferedIOBase(_io._BufferedIOBase,IOBase):\n __doc__=_io._BufferedIOBase.__doc__\n \nclass TextIOBase(_io._TextIOBase,IOBase):\n __doc__=_io._TextIOBase.__doc__\n \nRawIOBase.register(FileIO)\n\nfor klass in (BytesIO,BufferedReader,BufferedWriter,BufferedRandom,\nBufferedRWPair):\n BufferedIOBase.register(klass)\n \nfor klass in (StringIO,TextIOWrapper):\n TextIOBase.register(klass)\ndel klass\n\ntry :\n from _io import _WindowsConsoleIO\nexcept ImportError:\n pass\nelse :\n RawIOBase.register(_WindowsConsoleIO)\n", ["_io", "abc"]], "copy": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport types\nimport weakref\nfrom copyreg import dispatch_table\n\nclass Error(Exception):\n pass\nerror=Error\n\ntry :\n from org.python.core import PyStringMap\nexcept ImportError:\n PyStringMap=None\n \n__all__=[\"Error\",\"copy\",\"deepcopy\"]\n\ndef copy(x):\n ''\n\n\n \n \n cls=type(x)\n \n copier=_copy_dispatch.get(cls)\n if copier:\n  return copier(x)\n  \n if issubclass(cls,type):\n \n  return _copy_immutable(x)\n  \n copier=getattr(cls,\"__copy__\",None )\n if copier is not None :\n  return copier(x)\n  \n reductor=dispatch_table.get(cls)\n if reductor is not None :\n  rv=reductor(x)\n else :\n  reductor=getattr(x,\"__reduce_ex__\",None )\n  if reductor is not None :\n   rv=reductor(4)\n  else :\n   reductor=getattr(x,\"__reduce__\",None )\n   if reductor:\n    rv=reductor()\n   else :\n    raise Error(\"un(shallow)copyable object of type %s\"%cls)\n    \n if isinstance(rv,str):\n  return x\n return _reconstruct(x,None ,*rv)\n \n \n_copy_dispatch=d={}\n\ndef _copy_immutable(x):\n return x\nfor t in (type(None ),int,float,bool,complex,str,tuple,\nbytes,frozenset,type,range,slice,\ntypes.BuiltinFunctionType,type(Ellipsis),type(NotImplemented),\ntypes.FunctionType,weakref.ref):\n d[t]=_copy_immutable\nt=getattr(types,\"CodeType\",None )\nif t is not None :\n d[t]=_copy_immutable\n \nd[list]=list.copy\nd[dict]=dict.copy\nd[set]=set.copy\nd[bytearray]=bytearray.copy\n\nif PyStringMap is not None :\n d[PyStringMap]=PyStringMap.copy\n \ndel d,t\n\ndef deepcopy(x,memo=None ,_nil=[]):\n ''\n\n\n \n \n if memo is None :\n  memo={}\n  \n d=id(x)\n y=memo.get(d,_nil)\n if y is not _nil:\n  return y\n  \n cls=type(x)\n \n copier=_deepcopy_dispatch.get(cls)\n if copier is not None :\n  y=copier(x,memo)\n else :\n  if issubclass(cls,type):\n   y=_deepcopy_atomic(x,memo)\n  else :\n   copier=getattr(x,\"__deepcopy__\",None )\n   if copier is not None :\n    y=copier(memo)\n   else :\n    reductor=dispatch_table.get(cls)\n    if reductor:\n     rv=reductor(x)\n    else :\n     reductor=getattr(x,\"__reduce_ex__\",None )\n     if reductor is not None :\n      rv=reductor(4)\n     else :\n      reductor=getattr(x,\"__reduce__\",None )\n      if reductor:\n       rv=reductor()\n      else :\n       raise Error(\n       \"un(deep)copyable object of type %s\"%cls)\n    if isinstance(rv,str):\n     y=x\n    else :\n     y=_reconstruct(x,memo,*rv)\n     \n     \n if y is not x:\n  memo[d]=y\n  _keep_alive(x,memo)\n return y\n \n_deepcopy_dispatch=d={}\n\ndef _deepcopy_atomic(x,memo):\n return x\nd[type(None )]=_deepcopy_atomic\nd[type(Ellipsis)]=_deepcopy_atomic\nd[type(NotImplemented)]=_deepcopy_atomic\nd[int]=_deepcopy_atomic\nd[float]=_deepcopy_atomic\nd[bool]=_deepcopy_atomic\nd[complex]=_deepcopy_atomic\nd[bytes]=_deepcopy_atomic\nd[str]=_deepcopy_atomic\nd[types.CodeType]=_deepcopy_atomic\nd[type]=_deepcopy_atomic\nd[types.BuiltinFunctionType]=_deepcopy_atomic\nd[types.FunctionType]=_deepcopy_atomic\nd[weakref.ref]=_deepcopy_atomic\n\ndef _deepcopy_list(x,memo,deepcopy=deepcopy):\n y=[]\n memo[id(x)]=y\n append=y.append\n for a in x:\n  append(deepcopy(a,memo))\n return y\nd[list]=_deepcopy_list\n\ndef _deepcopy_tuple(x,memo,deepcopy=deepcopy):\n y=[deepcopy(a,memo)for a in x]\n \n \n try :\n  return memo[id(x)]\n except KeyError:\n  pass\n for k,j in zip(x,y):\n  if k is not j:\n   y=tuple(y)\n   break\n else :\n  y=x\n return y\nd[tuple]=_deepcopy_tuple\n\ndef _deepcopy_dict(x,memo,deepcopy=deepcopy):\n y={}\n memo[id(x)]=y\n for key,value in x.items():\n  y[deepcopy(key,memo)]=deepcopy(value,memo)\n return y\nd[dict]=_deepcopy_dict\nif PyStringMap is not None :\n d[PyStringMap]=_deepcopy_dict\n \ndef _deepcopy_method(x,memo):\n return type(x)(x.__func__,deepcopy(x.__self__,memo))\nd[types.MethodType]=_deepcopy_method\n\ndel d\n\ndef _keep_alive(x,memo):\n ''\n\n\n\n\n\n\n\n \n try :\n  memo[id(memo)].append(x)\n except KeyError:\n \n  memo[id(memo)]=[x]\n  \ndef _reconstruct(x,memo,func,args,\nstate=None ,listiter=None ,dictiter=None ,\ndeepcopy=deepcopy):\n deep=memo is not None\n if deep and args:\n  args=(deepcopy(arg,memo)for arg in args)\n y=func(*args)\n if deep:\n  memo[id(x)]=y\n  \n if state is not None :\n  if deep:\n   state=deepcopy(state,memo)\n  if hasattr(y,'__setstate__'):\n   y.__setstate__(state)\n  else :\n   if isinstance(state,tuple)and len(state)==2:\n    state,slotstate=state\n   else :\n    slotstate=None\n   if state is not None :\n    y.__dict__.update(state)\n   if slotstate is not None :\n    for key,value in slotstate.items():\n     setattr(y,key,value)\n     \n if listiter is not None :\n  if deep:\n   for item in listiter:\n    item=deepcopy(item,memo)\n    y.append(item)\n  else :\n   for item in listiter:\n    y.append(item)\n if dictiter is not None :\n  if deep:\n   for key,value in dictiter:\n    key=deepcopy(key,memo)\n    value=deepcopy(value,memo)\n    y[key]=value\n  else :\n   for key,value in dictiter:\n    y[key]=value\n return y\n \ndel types,weakref,PyStringMap\n", ["copyreg", "org.python.core", "types", "weakref"]], "_thread": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['error','start_new_thread','exit','get_ident','allocate_lock',\n'interrupt_main','LockType']\n\n\nTIMEOUT_MAX=2 **31\n\n\n\n\n\n\nerror=RuntimeError\n\ndef _set_sentinel(*args,**kw):\n return LockType()\n \ndef start_new_thread(function,args,kwargs={}):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if type(args)!=type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs)!=type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main=False\n try :\n  function(*args,**kwargs)\n except SystemExit:\n  pass\n except :\n  import traceback\n  traceback.print_exc()\n _main=True\n global _interrupt\n if _interrupt:\n  _interrupt=False\n  raise KeyboardInterrupt\n  \ndef exit():\n ''\n raise SystemExit\n \ndef get_ident():\n ''\n\n\n\n\n \n return -1\n \ndef allocate_lock():\n ''\n return LockType()\n \ndef stack_size(size=None ):\n ''\n if size is not None :\n  raise error(\"setting thread stack size not supported\")\n return 0\n \nclass LockType(object):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self):\n  self.locked_status=False\n  \n def acquire(self,waitflag=None ,timeout=-1):\n  ''\n\n\n\n\n\n\n\n\n  \n  if waitflag is None or waitflag:\n   self.locked_status=True\n   return True\n  else :\n   if not self.locked_status:\n    self.locked_status=True\n    return True\n   else :\n    if timeout >0:\n     import time\n     time.sleep(timeout)\n    return False\n    \n __enter__=acquire\n \n def __exit__(self,typ,val,tb):\n  self.release()\n  \n def release(self):\n  ''\n  \n  \n  if not self.locked_status:\n   raise error\n  self.locked_status=False\n  return True\n  \n def locked(self):\n  return self.locked_status\n  \n  \n_interrupt=False\n\n_main=True\n\ndef interrupt_main():\n ''\n \n if _main:\n  raise KeyboardInterrupt\n else :\n  global _interrupt\n  _interrupt=True\n  \n  \nclass _local:\n pass\n \nRLock=LockType\n", ["time", "traceback"]], "_py_abc": [".py", "from _weakrefset import WeakSet\n\n\ndef get_cache_token():\n ''\n\n\n\n\n \n return ABCMeta._abc_invalidation_counter\n \n \nclass ABCMeta(type):\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n _abc_invalidation_counter=0\n \n def __new__(mcls,name,bases,namespace,/,**kwargs):\n  cls=super().__new__(mcls,name,bases,namespace,**kwargs)\n  \n  abstracts={name\n  for name,value in namespace.items()\n  if getattr(value,\"__isabstractmethod__\",False )}\n  for base in bases:\n   for name in getattr(base,\"__abstractmethods__\",set()):\n    value=getattr(cls,name,None )\n    if getattr(value,\"__isabstractmethod__\",False ):\n     abstracts.add(name)\n  cls.__abstractmethods__=frozenset(abstracts)\n  \n  cls._abc_registry=WeakSet()\n  cls._abc_cache=WeakSet()\n  cls._abc_negative_cache=WeakSet()\n  cls._abc_negative_cache_version=ABCMeta._abc_invalidation_counter\n  return cls\n  \n def register(cls,subclass):\n  ''\n\n\n  \n  if not isinstance(subclass,type):\n   raise TypeError(\"Can only register classes\")\n  if issubclass(subclass,cls):\n   return subclass\n   \n   \n  if issubclass(cls,subclass):\n  \n   raise RuntimeError(\"Refusing to create an inheritance cycle\")\n  cls._abc_registry.add(subclass)\n  ABCMeta._abc_invalidation_counter +=1\n  return subclass\n  \n def _dump_registry(cls,file=None ):\n  ''\n  print(f\"Class: {cls.__module__}.{cls.__qualname__}\",file=file)\n  print(f\"Inv. counter: {get_cache_token()}\",file=file)\n  for name in cls.__dict__:\n   if name.startswith(\"_abc_\"):\n    value=getattr(cls,name)\n    if isinstance(value,WeakSet):\n     value=set(value)\n    print(f\"{name}: {value!r}\",file=file)\n    \n def _abc_registry_clear(cls):\n  ''\n  cls._abc_registry.clear()\n  \n def _abc_caches_clear(cls):\n  ''\n  cls._abc_cache.clear()\n  cls._abc_negative_cache.clear()\n  \n def __instancecheck__(cls,instance):\n  ''\n  \n  subclass=instance.__class__\n  if subclass in cls._abc_cache:\n   return True\n  subtype=type(instance)\n  if subtype is subclass:\n   if (cls._abc_negative_cache_version ==\n   ABCMeta._abc_invalidation_counter and\n   subclass in cls._abc_negative_cache):\n    return False\n    \n   return cls.__subclasscheck__(subclass)\n  return any(cls.__subclasscheck__(c)for c in (subclass,subtype))\n  \n def __subclasscheck__(cls,subclass):\n  ''\n  if not isinstance(subclass,type):\n   raise TypeError('issubclass() arg 1 must be a class')\n   \n  if subclass in cls._abc_cache:\n   return True\n   \n  if cls._abc_negative_cache_version <ABCMeta._abc_invalidation_counter:\n  \n   cls._abc_negative_cache=WeakSet()\n   cls._abc_negative_cache_version=ABCMeta._abc_invalidation_counter\n  elif subclass in cls._abc_negative_cache:\n   return False\n   \n  ok=cls.__subclasshook__(subclass)\n  if ok is not NotImplemented:\n   assert isinstance(ok,bool)\n   if ok:\n    cls._abc_cache.add(subclass)\n   else :\n    cls._abc_negative_cache.add(subclass)\n   return ok\n   \n  if cls in getattr(subclass,'__mro__',()):\n   cls._abc_cache.add(subclass)\n   return True\n   \n  for rcls in cls._abc_registry:\n   if issubclass(subclass,rcls):\n    cls._abc_cache.add(subclass)\n    return True\n    \n  for scls in cls.__subclasses__():\n   if issubclass(subclass,scls):\n    cls._abc_cache.add(subclass)\n    return True\n    \n  cls._abc_negative_cache.add(subclass)\n  return False\n", ["_weakrefset"]], "reprlib": [".py", "''\n\n__all__=[\"Repr\",\"repr\",\"recursive_repr\"]\n\nimport builtins\nfrom itertools import islice\nfrom _thread import get_ident\n\ndef recursive_repr(fillvalue='...'):\n ''\n \n def decorating_function(user_function):\n  repr_running=set()\n  \n  def wrapper(self):\n   key=id(self),get_ident()\n   if key in repr_running:\n    return fillvalue\n   repr_running.add(key)\n   try :\n    result=user_function(self)\n   finally :\n    repr_running.discard(key)\n   return result\n   \n   \n  wrapper.__module__=getattr(user_function,'__module__')\n  wrapper.__doc__=getattr(user_function,'__doc__')\n  wrapper.__name__=getattr(user_function,'__name__')\n  wrapper.__qualname__=getattr(user_function,'__qualname__')\n  wrapper.__annotations__=getattr(user_function,'__annotations__',{})\n  return wrapper\n  \n return decorating_function\n \nclass Repr:\n\n def __init__(self):\n  self.maxlevel=6\n  self.maxtuple=6\n  self.maxlist=6\n  self.maxarray=5\n  self.maxdict=4\n  self.maxset=6\n  self.maxfrozenset=6\n  self.maxdeque=6\n  self.maxstring=30\n  self.maxlong=40\n  self.maxother=30\n  \n def repr(self,x):\n  return self.repr1(x,self.maxlevel)\n  \n def repr1(self,x,level):\n  typename=type(x).__name__\n  if ' 'in typename:\n   parts=typename.split()\n   typename='_'.join(parts)\n  if hasattr(self,'repr_'+typename):\n   return getattr(self,'repr_'+typename)(x,level)\n  else :\n   return self.repr_instance(x,level)\n   \n def _repr_iterable(self,x,level,left,right,maxiter,trail=''):\n  n=len(x)\n  if level <=0 and n:\n   s='...'\n  else :\n   newlevel=level -1\n   repr1=self.repr1\n   pieces=[repr1(elem,newlevel)for elem in islice(x,maxiter)]\n   if n >maxiter:pieces.append('...')\n   s=', '.join(pieces)\n   if n ==1 and trail:right=trail+right\n  return '%s%s%s'%(left,s,right)\n  \n def repr_tuple(self,x,level):\n  return self._repr_iterable(x,level,'(',')',self.maxtuple,',')\n  \n def repr_list(self,x,level):\n  return self._repr_iterable(x,level,'[',']',self.maxlist)\n  \n def repr_array(self,x,level):\n  if not x:\n   return \"array('%s')\"%x.typecode\n  header=\"array('%s', [\"%x.typecode\n  return self._repr_iterable(x,level,header,'])',self.maxarray)\n  \n def repr_set(self,x,level):\n  if not x:\n   return 'set()'\n  x=_possibly_sorted(x)\n  return self._repr_iterable(x,level,'{','}',self.maxset)\n  \n def repr_frozenset(self,x,level):\n  if not x:\n   return 'frozenset()'\n  x=_possibly_sorted(x)\n  return self._repr_iterable(x,level,'frozenset({','})',\n  self.maxfrozenset)\n  \n def repr_deque(self,x,level):\n  return self._repr_iterable(x,level,'deque([','])',self.maxdeque)\n  \n def repr_dict(self,x,level):\n  n=len(x)\n  if n ==0:return '{}'\n  if level <=0:return '{...}'\n  newlevel=level -1\n  repr1=self.repr1\n  pieces=[]\n  for key in islice(_possibly_sorted(x),self.maxdict):\n   keyrepr=repr1(key,newlevel)\n   valrepr=repr1(x[key],newlevel)\n   pieces.append('%s: %s'%(keyrepr,valrepr))\n  if n >self.maxdict:pieces.append('...')\n  s=', '.join(pieces)\n  return '{%s}'%(s,)\n  \n def repr_str(self,x,level):\n  s=builtins.repr(x[:self.maxstring])\n  if len(s)>self.maxstring:\n   i=max(0,(self.maxstring -3)//2)\n   j=max(0,self.maxstring -3 -i)\n   s=builtins.repr(x[:i]+x[len(x)-j:])\n   s=s[:i]+'...'+s[len(s)-j:]\n  return s\n  \n def repr_int(self,x,level):\n  s=builtins.repr(x)\n  if len(s)>self.maxlong:\n   i=max(0,(self.maxlong -3)//2)\n   j=max(0,self.maxlong -3 -i)\n   s=s[:i]+'...'+s[len(s)-j:]\n  return s\n  \n def repr_instance(self,x,level):\n  try :\n   s=builtins.repr(x)\n   \n   \n  except Exception:\n   return '<%s instance at %#x>'%(x.__class__.__name__,id(x))\n  if len(s)>self.maxother:\n   i=max(0,(self.maxother -3)//2)\n   j=max(0,self.maxother -3 -i)\n   s=s[:i]+'...'+s[len(s)-j:]\n  return s\n  \n  \ndef _possibly_sorted(x):\n\n\n\n try :\n  return sorted(x)\n except Exception:\n  return list(x)\n  \naRepr=Repr()\nrepr=aRepr.repr\n", ["_thread", "builtins", "itertools"]], "string": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\"ascii_letters\",\"ascii_lowercase\",\"ascii_uppercase\",\"capwords\",\n\"digits\",\"hexdigits\",\"octdigits\",\"printable\",\"punctuation\",\n\"whitespace\",\"Formatter\",\"Template\"]\n\nimport _string\n\n\nwhitespace=' \\t\\n\\r\\v\\f'\nascii_lowercase='abcdefghijklmnopqrstuvwxyz'\nascii_uppercase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nascii_letters=ascii_lowercase+ascii_uppercase\ndigits='0123456789'\nhexdigits=digits+'abcdef'+'ABCDEF'\noctdigits='01234567'\npunctuation=r\"\"\"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\"\"\nprintable=digits+ascii_letters+punctuation+whitespace\n\n\n\n\ndef capwords(s,sep=None ):\n ''\n\n\n\n\n\n\n\n\n \n return (sep or ' ').join(x.capitalize()for x in s.split(sep))\n \n \n \nimport re as _re\nfrom collections import ChainMap as _ChainMap\n\nclass _TemplateMetaclass(type):\n pattern=r\"\"\"\n    %(delim)s(?:\n      (?P<escaped>%(delim)s) |   # Escape sequence of two delimiters\n      (?P<named>%(id)s)      |   # delimiter and a Python identifier\n      {(?P<braced>%(bid)s)}  |   # delimiter and a braced identifier\n      (?P<invalid>)              # Other ill-formed delimiter exprs\n    )\n    \"\"\"\n \n def __init__(cls,name,bases,dct):\n  super(_TemplateMetaclass,cls).__init__(name,bases,dct)\n  if 'pattern'in dct:\n   pattern=cls.pattern\n  else :\n   pattern=_TemplateMetaclass.pattern %{\n   'delim':_re.escape(cls.delimiter),\n   'id':cls.idpattern,\n   'bid':cls.braceidpattern or cls.idpattern,\n   }\n  cls.pattern=_re.compile(pattern,cls.flags |_re.VERBOSE)\n  \n  \nclass Template(metaclass=_TemplateMetaclass):\n ''\n \n delimiter='$'\n \n \n \n \n idpattern=r'(?a:[_a-z][_a-z0-9]*)'\n braceidpattern=None\n flags=_re.IGNORECASE\n \n def __init__(self,template):\n  self.template=template\n  \n  \n  \n def _invalid(self,mo):\n  i=mo.start('invalid')\n  lines=self.template[:i].splitlines(keepends=True )\n  if not lines:\n   colno=1\n   lineno=1\n  else :\n   colno=i -len(''.join(lines[:-1]))\n   lineno=len(lines)\n  raise ValueError('Invalid placeholder in string: line %d, col %d'%\n  (lineno,colno))\n  \n def substitute(*args,**kws):\n  if not args:\n   raise TypeError(\"descriptor 'substitute' of 'Template' object \"\n   \"needs an argument\")\n  self,*args=args\n  if len(args)>1:\n   raise TypeError('Too many positional arguments')\n  if not args:\n   mapping=kws\n  elif kws:\n   mapping=_ChainMap(kws,args[0])\n  else :\n   mapping=args[0]\n   \n  def convert(mo):\n  \n   named=mo.group('named')or mo.group('braced')\n   if named is not None :\n    return str(mapping[named])\n   if mo.group('escaped')is not None :\n    return self.delimiter\n   if mo.group('invalid')is not None :\n    self._invalid(mo)\n   raise ValueError('Unrecognized named group in pattern',\n   self.pattern)\n  return self.pattern.sub(convert,self.template)\n  \n def safe_substitute(*args,**kws):\n  if not args:\n   raise TypeError(\"descriptor 'safe_substitute' of 'Template' object \"\n   \"needs an argument\")\n  self,*args=args\n  if len(args)>1:\n   raise TypeError('Too many positional arguments')\n  if not args:\n   mapping=kws\n  elif kws:\n   mapping=_ChainMap(kws,args[0])\n  else :\n   mapping=args[0]\n   \n  def convert(mo):\n   named=mo.group('named')or mo.group('braced')\n   if named is not None :\n    try :\n     return str(mapping[named])\n    except KeyError:\n     return mo.group()\n   if mo.group('escaped')is not None :\n    return self.delimiter\n   if mo.group('invalid')is not None :\n    return mo.group()\n   raise ValueError('Unrecognized named group in pattern',\n   self.pattern)\n  return self.pattern.sub(convert,self.template)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass Formatter:\n def format(*args,**kwargs):\n  if not args:\n   raise TypeError(\"descriptor 'format' of 'Formatter' object \"\n   \"needs an argument\")\n  self,*args=args\n  try :\n   format_string,*args=args\n  except ValueError:\n   raise TypeError(\"format() missing 1 required positional \"\n   \"argument: 'format_string'\")from None\n  return self.vformat(format_string,args,kwargs)\n  \n def vformat(self,format_string,args,kwargs):\n  used_args=set()\n  result,_=self._vformat(format_string,args,kwargs,used_args,2)\n  self.check_unused_args(used_args,args,kwargs)\n  return result\n  \n def _vformat(self,format_string,args,kwargs,used_args,recursion_depth,\n auto_arg_index=0):\n  if recursion_depth <0:\n   raise ValueError('Max string recursion exceeded')\n  result=[]\n  for literal_text,field_name,format_spec,conversion in\\\n  self.parse(format_string):\n  \n  \n   if literal_text:\n    result.append(literal_text)\n    \n    \n   if field_name is not None :\n   \n   \n   \n   \n    if field_name =='':\n     if auto_arg_index is False :\n      raise ValueError('cannot switch from manual field '\n      'specification to automatic field '\n      'numbering')\n     field_name=str(auto_arg_index)\n     auto_arg_index +=1\n    elif field_name.isdigit():\n     if auto_arg_index:\n      raise ValueError('cannot switch from manual field '\n      'specification to automatic field '\n      'numbering')\n      \n      \n     auto_arg_index=False\n     \n     \n     \n    obj,arg_used=self.get_field(field_name,args,kwargs)\n    used_args.add(arg_used)\n    \n    \n    obj=self.convert_field(obj,conversion)\n    \n    \n    format_spec,auto_arg_index=self._vformat(\n    format_spec,args,kwargs,\n    used_args,recursion_depth -1,\n    auto_arg_index=auto_arg_index)\n    \n    \n    result.append(self.format_field(obj,format_spec))\n    \n  return ''.join(result),auto_arg_index\n  \n  \n def get_value(self,key,args,kwargs):\n  if isinstance(key,int):\n   return args[key]\n  else :\n   return kwargs[key]\n   \n   \n def check_unused_args(self,used_args,args,kwargs):\n  pass\n  \n  \n def format_field(self,value,format_spec):\n  return format(value,format_spec)\n  \n  \n def convert_field(self,value,conversion):\n \n  if conversion is None :\n   return value\n  elif conversion =='s':\n   return str(value)\n  elif conversion =='r':\n   return repr(value)\n  elif conversion =='a':\n   return ascii(value)\n  raise ValueError(\"Unknown conversion specifier {0!s}\".format(conversion))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def parse(self,format_string):\n  return _string.formatter_parser(format_string)\n  \n  \n  \n  \n  \n  \n  \n def get_field(self,field_name,args,kwargs):\n  first,rest=_string.formatter_field_name_split(field_name)\n  \n  obj=self.get_value(first,args,kwargs)\n  \n  \n  \n  for is_attr,i in rest:\n   if is_attr:\n    obj=getattr(obj,i)\n   else :\n    obj=obj[i]\n    \n  return obj,first\n", ["_string", "collections", "re"]], "_collections_abc": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nUnit tests are in test_collections.\n\"\"\"\n\nfrom abc import ABCMeta,abstractmethod\nimport sys\n\n__all__=[\"Awaitable\",\"Coroutine\",\n\"AsyncIterable\",\"AsyncIterator\",\"AsyncGenerator\",\n\"Hashable\",\"Iterable\",\"Iterator\",\"Generator\",\"Reversible\",\n\"Sized\",\"Container\",\"Callable\",\"Collection\",\n\"Set\",\"MutableSet\",\n\"Mapping\",\"MutableMapping\",\n\"MappingView\",\"KeysView\",\"ItemsView\",\"ValuesView\",\n\"Sequence\",\"MutableSequence\",\n\"ByteString\",\n]\n\n\n\n\n\n__name__=\"collections.abc\"\n\n\n\n\n\n\n\n\nbytes_iterator=type(iter(b''))\nbytearray_iterator=type(iter(bytearray()))\n\ndict_keyiterator=type(iter({}.keys()))\ndict_valueiterator=type(iter({}.values()))\ndict_itemiterator=type(iter({}.items()))\nlist_iterator=type(iter([]))\nlist_reverseiterator=type(iter(reversed([])))\nrange_iterator=type(iter(range(0)))\nlongrange_iterator=type(iter(range(1 <<1000)))\nset_iterator=type(iter(set()))\nstr_iterator=type(iter(\"\"))\ntuple_iterator=type(iter(()))\nzip_iterator=type(iter(zip()))\n\ndict_keys=type({}.keys())\ndict_values=type({}.values())\ndict_items=type({}.items())\n\nmappingproxy=type(type.__dict__)\ngenerator=type((lambda :(yield ))())\n\nasync def _coro():pass\n_coro=_coro()\ncoroutine=type(_coro)\n_coro.close()\ndel _coro\n\nasync def _ag():yield\n_ag=_ag()\nasync_generator=type(_ag)\ndel _ag\n\n\n\n\ndef _check_methods(C,*methods):\n mro=C.__mro__\n for method in methods:\n  for B in mro:\n   if method in B.__dict__:\n    if B.__dict__[method]is None :\n     return NotImplemented\n    break\n  else :\n   return NotImplemented\n return True\n \nclass Hashable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __hash__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Hashable:\n   return _check_methods(C,\"__hash__\")\n  return NotImplemented\n  \n  \nclass Awaitable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __await__(self):\n  yield\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Awaitable:\n   return _check_methods(C,\"__await__\")\n  return NotImplemented\n  \n  \nclass Coroutine(Awaitable):\n\n __slots__=()\n \n @abstractmethod\n def send(self,value):\n  ''\n\n  \n  raise StopIteration\n  \n @abstractmethod\n def throw(self,typ,val=None ,tb=None ):\n  ''\n\n  \n  if val is None :\n   if tb is None :\n    raise typ\n   val=typ()\n  if tb is not None :\n   val=val.with_traceback(tb)\n  raise val\n  \n def close(self):\n  ''\n  \n  try :\n   self.throw(GeneratorExit)\n  except (GeneratorExit,StopIteration):\n   pass\n  else :\n   raise RuntimeError(\"coroutine ignored GeneratorExit\")\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Coroutine:\n   return _check_methods(C,'__await__','send','throw','close')\n  return NotImplemented\n  \n  \nCoroutine.register(coroutine)\n\n\nclass AsyncIterable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __aiter__(self):\n  return AsyncIterator()\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is AsyncIterable:\n   return _check_methods(C,\"__aiter__\")\n  return NotImplemented\n  \n  \nclass AsyncIterator(AsyncIterable):\n\n __slots__=()\n \n @abstractmethod\n async def __anext__(self):\n  ''\n  raise StopAsyncIteration\n  \n def __aiter__(self):\n  return self\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is AsyncIterator:\n   return _check_methods(C,\"__anext__\",\"__aiter__\")\n  return NotImplemented\n  \n  \nclass AsyncGenerator(AsyncIterator):\n\n __slots__=()\n \n async def __anext__(self):\n  ''\n\n  \n  return await self.asend(None )\n  \n @abstractmethod\n async def asend(self,value):\n  ''\n\n  \n  raise StopAsyncIteration\n  \n @abstractmethod\n async def athrow(self,typ,val=None ,tb=None ):\n  ''\n\n  \n  if val is None :\n   if tb is None :\n    raise typ\n   val=typ()\n  if tb is not None :\n   val=val.with_traceback(tb)\n  raise val\n  \n async def aclose(self):\n  ''\n  \n  try :\n   await self.athrow(GeneratorExit)\n  except (GeneratorExit,StopAsyncIteration):\n   pass\n  else :\n   raise RuntimeError(\"asynchronous generator ignored GeneratorExit\")\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is AsyncGenerator:\n   return _check_methods(C,'__aiter__','__anext__',\n   'asend','athrow','aclose')\n  return NotImplemented\n  \n  \nAsyncGenerator.register(async_generator)\n\n\nclass Iterable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __iter__(self):\n  while False :\n   yield None\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Iterable:\n   return _check_methods(C,\"__iter__\")\n  return NotImplemented\n  \n  \nclass Iterator(Iterable):\n\n __slots__=()\n \n @abstractmethod\n def __next__(self):\n  ''\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Iterator:\n   return _check_methods(C,'__iter__','__next__')\n  return NotImplemented\n  \nIterator.register(bytes_iterator)\nIterator.register(bytearray_iterator)\n\nIterator.register(dict_keyiterator)\nIterator.register(dict_valueiterator)\nIterator.register(dict_itemiterator)\nIterator.register(list_iterator)\nIterator.register(list_reverseiterator)\nIterator.register(range_iterator)\nIterator.register(longrange_iterator)\nIterator.register(set_iterator)\nIterator.register(str_iterator)\nIterator.register(tuple_iterator)\nIterator.register(zip_iterator)\n\n\nclass Reversible(Iterable):\n\n __slots__=()\n \n @abstractmethod\n def __reversed__(self):\n  while False :\n   yield None\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Reversible:\n   return _check_methods(C,\"__reversed__\",\"__iter__\")\n  return NotImplemented\n  \n  \nclass Generator(Iterator):\n\n __slots__=()\n \n def __next__(self):\n  ''\n\n  \n  return self.send(None )\n  \n @abstractmethod\n def send(self,value):\n  ''\n\n  \n  raise StopIteration\n  \n @abstractmethod\n def throw(self,typ,val=None ,tb=None ):\n  ''\n\n  \n  if val is None :\n   if tb is None :\n    raise typ\n   val=typ()\n  if tb is not None :\n   val=val.with_traceback(tb)\n  raise val\n  \n def close(self):\n  ''\n  \n  try :\n   self.throw(GeneratorExit)\n  except (GeneratorExit,StopIteration):\n   pass\n  else :\n   raise RuntimeError(\"generator ignored GeneratorExit\")\n   \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Generator:\n   return _check_methods(C,'__iter__','__next__',\n   'send','throw','close')\n  return NotImplemented\n  \nGenerator.register(generator)\n\n\nclass Sized(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __len__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Sized:\n   return _check_methods(C,\"__len__\")\n  return NotImplemented\n  \n  \nclass Container(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __contains__(self,x):\n  return False\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Container:\n   return _check_methods(C,\"__contains__\")\n  return NotImplemented\n  \nclass Collection(Sized,Iterable,Container):\n\n __slots__=()\n \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Collection:\n   return _check_methods(C,\"__len__\",\"__iter__\",\"__contains__\")\n  return NotImplemented\n  \nclass Callable(metaclass=ABCMeta):\n\n __slots__=()\n \n @abstractmethod\n def __call__(self,*args,**kwds):\n  return False\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is Callable:\n   return _check_methods(C,\"__call__\")\n  return NotImplemented\n  \n  \n  \n  \n  \nclass Set(Collection):\n\n ''\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n def __le__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  if len(self)>len(other):\n   return False\n  for elem in self:\n   if elem not in other:\n    return False\n  return True\n  \n def __lt__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return len(self)<len(other)and self.__le__(other)\n  \n def __gt__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return len(self)>len(other)and self.__ge__(other)\n  \n def __ge__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  if len(self)<len(other):\n   return False\n  for elem in other:\n   if elem not in self:\n    return False\n  return True\n  \n def __eq__(self,other):\n  if not isinstance(other,Set):\n   return NotImplemented\n  return len(self)==len(other)and self.__le__(other)\n  \n @classmethod\n def _from_iterable(cls,it):\n  ''\n\n\n\n  \n  return cls(it)\n  \n def __and__(self,other):\n  if not isinstance(other,Iterable):\n   return NotImplemented\n  return self._from_iterable(value for value in other if value in self)\n  \n __rand__=__and__\n \n def isdisjoint(self,other):\n  ''\n  for value in other:\n   if value in self:\n    return False\n  return True\n  \n def __or__(self,other):\n  if not isinstance(other,Iterable):\n   return NotImplemented\n  chain=(e for s in (self,other)for e in s)\n  return self._from_iterable(chain)\n  \n __ror__=__or__\n \n def __sub__(self,other):\n  if not isinstance(other,Set):\n   if not isinstance(other,Iterable):\n    return NotImplemented\n   other=self._from_iterable(other)\n  return self._from_iterable(value for value in self\n  if value not in other)\n  \n def __rsub__(self,other):\n  if not isinstance(other,Set):\n   if not isinstance(other,Iterable):\n    return NotImplemented\n   other=self._from_iterable(other)\n  return self._from_iterable(value for value in other\n  if value not in self)\n  \n def __xor__(self,other):\n  if not isinstance(other,Set):\n   if not isinstance(other,Iterable):\n    return NotImplemented\n   other=self._from_iterable(other)\n  return (self -other)|(other -self)\n  \n __rxor__=__xor__\n \n def _hash(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  MAX=sys.maxsize\n  MASK=2 *MAX+1\n  n=len(self)\n  h=1927868237 *(n+1)\n  h &=MASK\n  for x in self:\n   hx=hash(x)\n   h ^=(hx ^(hx <<16)^89869747)*3644798167\n   h &=MASK\n  h=h *69069+907133923\n  h &=MASK\n  if h >MAX:\n   h -=MASK+1\n  if h ==-1:\n   h=590923713\n  return h\n  \nSet.register(frozenset)\n\n\nclass MutableSet(Set):\n ''\n\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def add(self,value):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def discard(self,value):\n  ''\n  raise NotImplementedError\n  \n def remove(self,value):\n  ''\n  if value not in self:\n   raise KeyError(value)\n  self.discard(value)\n  \n def pop(self):\n  ''\n  it=iter(self)\n  try :\n   value=next(it)\n  except StopIteration:\n   raise KeyError from None\n  self.discard(value)\n  return value\n  \n def clear(self):\n  ''\n  try :\n   while True :\n    self.pop()\n  except KeyError:\n   pass\n   \n def __ior__(self,it):\n  for value in it:\n   self.add(value)\n  return self\n  \n def __iand__(self,it):\n  for value in (self -it):\n   self.discard(value)\n  return self\n  \n def __ixor__(self,it):\n  if it is self:\n   self.clear()\n  else :\n   if not isinstance(it,Set):\n    it=self._from_iterable(it)\n   for value in it:\n    if value in self:\n     self.discard(value)\n    else :\n     self.add(value)\n  return self\n  \n def __isub__(self,it):\n  if it is self:\n   self.clear()\n  else :\n   for value in it:\n    self.discard(value)\n  return self\n  \nMutableSet.register(set)\n\n\n\n\n\nclass Mapping(Collection):\n\n __slots__=()\n \n \"\"\"A Mapping is a generic container for associating key/value\n    pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __iter__, and __len__.\n\n    \"\"\"\n \n @abstractmethod\n def __getitem__(self,key):\n  raise KeyError\n  \n def get(self,key,default=None ):\n  ''\n  try :\n   return self[key]\n  except KeyError:\n   return default\n   \n def __contains__(self,key):\n  try :\n   self[key]\n  except KeyError:\n   return False\n  else :\n   return True\n   \n def keys(self):\n  ''\n  return KeysView(self)\n  \n def items(self):\n  ''\n  return ItemsView(self)\n  \n def values(self):\n  ''\n  return ValuesView(self)\n  \n def __eq__(self,other):\n  if not isinstance(other,Mapping):\n   return NotImplemented\n  return dict(self.items())==dict(other.items())\n  \n __reversed__=None\n \nMapping.register(mappingproxy)\n\n\nclass MappingView(Sized):\n\n __slots__='_mapping',\n \n def __init__(self,mapping):\n  self._mapping=mapping\n  \n def __len__(self):\n  return len(self._mapping)\n  \n def __repr__(self):\n  return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n  \n  \nclass KeysView(MappingView,Set):\n\n __slots__=()\n \n @classmethod\n def _from_iterable(self,it):\n  return set(it)\n  \n def __contains__(self,key):\n  return key in self._mapping\n  \n def __iter__(self):\n  yield from self._mapping\n  \nKeysView.register(dict_keys)\n\n\nclass ItemsView(MappingView,Set):\n\n __slots__=()\n \n @classmethod\n def _from_iterable(self,it):\n  return set(it)\n  \n def __contains__(self,item):\n  key,value=item\n  try :\n   v=self._mapping[key]\n  except KeyError:\n   return False\n  else :\n   return v is value or v ==value\n   \n def __iter__(self):\n  for key in self._mapping:\n   yield (key,self._mapping[key])\n   \nItemsView.register(dict_items)\n\n\nclass ValuesView(MappingView,Collection):\n\n __slots__=()\n \n def __contains__(self,value):\n  for key in self._mapping:\n   v=self._mapping[key]\n   if v is value or v ==value:\n    return True\n  return False\n  \n def __iter__(self):\n  for key in self._mapping:\n   yield self._mapping[key]\n   \nValuesView.register(dict_values)\n\n\nclass MutableMapping(Mapping):\n\n __slots__=()\n \n \"\"\"A MutableMapping is a generic container for associating\n    key/value pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __setitem__, __delitem__,\n    __iter__, and __len__.\n\n    \"\"\"\n \n @abstractmethod\n def __setitem__(self,key,value):\n  raise KeyError\n  \n @abstractmethod\n def __delitem__(self,key):\n  raise KeyError\n  \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n  \n  try :\n   value=self[key]\n  except KeyError:\n   if default is self.__marker:\n    raise\n   return default\n  else :\n   del self[key]\n   return value\n   \n def popitem(self):\n  ''\n\n  \n  try :\n   key=next(iter(self))\n  except StopIteration:\n   raise KeyError from None\n  value=self[key]\n  del self[key]\n  return key,value\n  \n def clear(self):\n  ''\n  try :\n   while True :\n    self.popitem()\n  except KeyError:\n   pass\n   \n def update(self,other=(),/,**kwds):\n  ''\n\n\n\n  \n  if isinstance(other,Mapping):\n   for key in other:\n    self[key]=other[key]\n  elif hasattr(other,\"keys\"):\n   for key in other.keys():\n    self[key]=other[key]\n  else :\n   for key,value in other:\n    self[key]=value\n  for key,value in kwds.items():\n   self[key]=value\n   \n def setdefault(self,key,default=None ):\n  ''\n  try :\n   return self[key]\n  except KeyError:\n   self[key]=default\n  return default\n  \nMutableMapping.register(dict)\n\n\n\n\n\nclass Sequence(Reversible,Collection):\n\n ''\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __getitem__(self,index):\n  raise IndexError\n  \n def __iter__(self):\n  i=0\n  try :\n   while True :\n    v=self[i]\n    yield v\n    i +=1\n  except IndexError:\n   return\n   \n def __contains__(self,value):\n  for v in self:\n   if v is value or v ==value:\n    return True\n  return False\n  \n def __reversed__(self):\n  for i in reversed(range(len(self))):\n   yield self[i]\n   \n def index(self,value,start=0,stop=None ):\n  ''\n\n\n\n\n  \n  if start is not None and start <0:\n   start=max(len(self)+start,0)\n  if stop is not None and stop <0:\n   stop +=len(self)\n   \n  i=start\n  while stop is None or i <stop:\n   try :\n    v=self[i]\n    if v is value or v ==value:\n     return i\n   except IndexError:\n    break\n   i +=1\n  raise ValueError\n  \n def count(self,value):\n  ''\n  return sum(1 for v in self if v is value or v ==value)\n  \nSequence.register(tuple)\nSequence.register(str)\nSequence.register(range)\nSequence.register(memoryview)\n\n\nclass ByteString(Sequence):\n\n ''\n\n\n \n \n __slots__=()\n \nByteString.register(bytes)\nByteString.register(bytearray)\n\n\nclass MutableSequence(Sequence):\n\n __slots__=()\n \n \"\"\"All the operations on a read-write sequence.\n\n    Concrete subclasses must provide __new__ or __init__,\n    __getitem__, __setitem__, __delitem__, __len__, and insert().\n\n    \"\"\"\n \n @abstractmethod\n def __setitem__(self,index,value):\n  raise IndexError\n  \n @abstractmethod\n def __delitem__(self,index):\n  raise IndexError\n  \n @abstractmethod\n def insert(self,index,value):\n  ''\n  raise IndexError\n  \n def append(self,value):\n  ''\n  self.insert(len(self),value)\n  \n def clear(self):\n  ''\n  try :\n   while True :\n    self.pop()\n  except IndexError:\n   pass\n   \n def reverse(self):\n  ''\n  n=len(self)\n  for i in range(n //2):\n   self[i],self[n -i -1]=self[n -i -1],self[i]\n   \n def extend(self,values):\n  ''\n  if values is self:\n   values=list(values)\n  for v in values:\n   self.append(v)\n   \n def pop(self,index=-1):\n  ''\n\n  \n  v=self[index]\n  del self[index]\n  return v\n  \n def remove(self,value):\n  ''\n\n  \n  del self[self.index(value)]\n  \n def __iadd__(self,values):\n  self.extend(values)\n  return self\n  \nMutableSequence.register(list)\nMutableSequence.register(bytearray)\n", ["abc", "sys"]], "posixpath": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncurdir='.'\npardir='..'\nextsep='.'\nsep='/'\npathsep=':'\ndefpath='/bin:/usr/bin'\naltsep=None\ndevnull='/dev/null'\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__=[\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n\"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n\"getatime\",\"getctime\",\"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n\"ismount\",\"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n\"samefile\",\"sameopenfile\",\"samestat\",\n\"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\"extsep\",\n\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\",\n\"commonpath\"]\n\n\ndef _get_sep(path):\n if isinstance(path,bytes):\n  return b'/'\n else :\n  return '/'\n  \n  \n  \n  \n  \n  \ndef normcase(s):\n ''\n return os.fspath(s)\n \n \n \n \n \ndef isabs(s):\n ''\n s=os.fspath(s)\n sep=_get_sep(s)\n return s.startswith(sep)\n \n \n \n \n \n \ndef join(a,*p):\n ''\n\n\n \n a=os.fspath(a)\n sep=_get_sep(a)\n path=a\n try :\n  if not p:\n   path[:0]+sep\n  for b in map(os.fspath,p):\n   if b.startswith(sep):\n    path=b\n   elif not path or path.endswith(sep):\n    path +=b\n   else :\n    path +=sep+b\n except (TypeError,AttributeError,BytesWarning):\n  genericpath._check_arg_types('join',a,*p)\n  raise\n return path\n \n \n \n \n \n \n \ndef split(p):\n ''\n \n p=os.fspath(p)\n sep=_get_sep(p)\n i=p.rfind(sep)+1\n head,tail=p[:i],p[i:]\n if head and head !=sep *len(head):\n  head=head.rstrip(sep)\n return head,tail\n \n \n \n \n \n \n \ndef splitext(p):\n p=os.fspath(p)\n if isinstance(p,bytes):\n  sep=b'/'\n  extsep=b'.'\n else :\n  sep='/'\n  extsep='.'\n return genericpath._splitext(p,sep,None ,extsep)\nsplitext.__doc__=genericpath._splitext.__doc__\n\n\n\n\ndef splitdrive(p):\n ''\n \n p=os.fspath(p)\n return p[:0],p\n \n \n \n \ndef basename(p):\n ''\n p=os.fspath(p)\n sep=_get_sep(p)\n i=p.rfind(sep)+1\n return p[i:]\n \n \n \n \ndef dirname(p):\n ''\n p=os.fspath(p)\n sep=_get_sep(p)\n i=p.rfind(sep)+1\n head=p[:i]\n if head and head !=sep *len(head):\n  head=head.rstrip(sep)\n return head\n \n \n \n \n \ndef islink(path):\n ''\n try :\n  st=os.lstat(path)\n except (OSError,ValueError,AttributeError):\n  return False\n return stat.S_ISLNK(st.st_mode)\n \n \n \ndef lexists(path):\n ''\n try :\n  os.lstat(path)\n except (OSError,ValueError):\n  return False\n return True\n \n \n \n \n \ndef ismount(path):\n ''\n try :\n  s1=os.lstat(path)\n except (OSError,ValueError):\n \n  return False\n else :\n \n  if stat.S_ISLNK(s1.st_mode):\n   return False\n   \n if isinstance(path,bytes):\n  parent=join(path,b'..')\n else :\n  parent=join(path,'..')\n parent=realpath(parent)\n try :\n  s2=os.lstat(parent)\n except (OSError,ValueError):\n  return False\n  \n dev1=s1.st_dev\n dev2=s2.st_dev\n if dev1 !=dev2:\n  return True\n ino1=s1.st_ino\n ino2=s2.st_ino\n if ino1 ==ino2:\n  return True\n return False\n \n \n \n \n \n \n \n \n \n \n \ndef expanduser(path):\n ''\n \n path=os.fspath(path)\n if isinstance(path,bytes):\n  tilde=b'~'\n else :\n  tilde='~'\n if not path.startswith(tilde):\n  return path\n sep=_get_sep(path)\n i=path.find(sep,1)\n if i <0:\n  i=len(path)\n if i ==1:\n  if 'HOME'not in os.environ:\n   import pwd\n   try :\n    userhome=pwd.getpwuid(os.getuid()).pw_dir\n   except KeyError:\n   \n   \n    return path\n  else :\n   userhome=os.environ['HOME']\n else :\n  import pwd\n  name=path[1:i]\n  if isinstance(name,bytes):\n   name=str(name,'ASCII')\n  try :\n   pwent=pwd.getpwnam(name)\n  except KeyError:\n  \n  \n   return path\n  userhome=pwent.pw_dir\n if isinstance(path,bytes):\n  userhome=os.fsencode(userhome)\n  root=b'/'\n else :\n  root='/'\n userhome=userhome.rstrip(root)\n return (userhome+path[i:])or root\n \n \n \n \n \n \n_varprog=None\n_varprogb=None\n\ndef expandvars(path):\n ''\n \n path=os.fspath(path)\n global _varprog,_varprogb\n if isinstance(path,bytes):\n  if b'$'not in path:\n   return path\n  if not _varprogb:\n   import re\n   _varprogb=re.compile(br'\\$(\\w+|\\{[^}]*\\})',re.ASCII)\n  search=_varprogb.search\n  start=b'{'\n  end=b'}'\n  environ=getattr(os,'environb',None )\n else :\n  if '$'not in path:\n   return path\n  if not _varprog:\n   import re\n   _varprog=re.compile(r'\\$(\\w+|\\{[^}]*\\})',re.ASCII)\n  search=_varprog.search\n  start='{'\n  end='}'\n  environ=os.environ\n i=0\n while True :\n  m=search(path,i)\n  if not m:\n   break\n  i,j=m.span(0)\n  name=m.group(1)\n  if name.startswith(start)and name.endswith(end):\n   name=name[1:-1]\n  try :\n   if environ is None :\n    value=os.fsencode(os.environ[os.fsdecode(name)])\n   else :\n    value=environ[name]\n  except KeyError:\n   i=j\n  else :\n   tail=path[j:]\n   path=path[:i]+value\n   i=len(path)\n   path +=tail\n return path\n \n \n \n \n \n \ndef normpath(path):\n ''\n path=os.fspath(path)\n if isinstance(path,bytes):\n  sep=b'/'\n  empty=b''\n  dot=b'.'\n  dotdot=b'..'\n else :\n  sep='/'\n  empty=''\n  dot='.'\n  dotdot='..'\n if path ==empty:\n  return dot\n initial_slashes=path.startswith(sep)\n \n \n if (initial_slashes and\n path.startswith(sep *2)and not path.startswith(sep *3)):\n  initial_slashes=2\n comps=path.split(sep)\n new_comps=[]\n for comp in comps:\n  if comp in (empty,dot):\n   continue\n  if (comp !=dotdot or (not initial_slashes and not new_comps)or\n  (new_comps and new_comps[-1]==dotdot)):\n   new_comps.append(comp)\n  elif new_comps:\n   new_comps.pop()\n comps=new_comps\n path=sep.join(comps)\n if initial_slashes:\n  path=sep *initial_slashes+path\n return path or dot\n \n \ndef abspath(path):\n ''\n path=os.fspath(path)\n if not isabs(path):\n  if isinstance(path,bytes):\n   cwd=os.getcwdb()\n  else :\n   cwd=os.getcwd()\n  path=join(cwd,path)\n return normpath(path)\n \n \n \n \n \ndef realpath(filename):\n ''\n \n filename=os.fspath(filename)\n path,ok=_joinrealpath(filename[:0],filename,{})\n return abspath(path)\n \n \n \ndef _joinrealpath(path,rest,seen):\n if isinstance(path,bytes):\n  sep=b'/'\n  curdir=b'.'\n  pardir=b'..'\n else :\n  sep='/'\n  curdir='.'\n  pardir='..'\n  \n if isabs(rest):\n  rest=rest[1:]\n  path=sep\n  \n while rest:\n  name,_,rest=rest.partition(sep)\n  if not name or name ==curdir:\n  \n   continue\n  if name ==pardir:\n  \n   if path:\n    path,name=split(path)\n    if name ==pardir:\n     path=join(path,pardir,pardir)\n   else :\n    path=pardir\n   continue\n  newpath=join(path,name)\n  if not islink(newpath):\n   path=newpath\n   continue\n   \n  if newpath in seen:\n  \n   path=seen[newpath]\n   if path is not None :\n   \n    continue\n    \n    \n   return join(newpath,rest),False\n  seen[newpath]=None\n  path,ok=_joinrealpath(path,os.readlink(newpath),seen)\n  if not ok:\n   return join(path,rest),False\n  seen[newpath]=path\n  \n return path,True\n \n \nsupports_unicode_filenames=(sys.platform =='darwin')\n\ndef relpath(path,start=None ):\n ''\n \n if not path:\n  raise ValueError(\"no path specified\")\n  \n path=os.fspath(path)\n if isinstance(path,bytes):\n  curdir=b'.'\n  sep=b'/'\n  pardir=b'..'\n else :\n  curdir='.'\n  sep='/'\n  pardir='..'\n  \n if start is None :\n  start=curdir\n else :\n  start=os.fspath(start)\n  \n try :\n  start_list=[x for x in abspath(start).split(sep)if x]\n  path_list=[x for x in abspath(path).split(sep)if x]\n  \n  i=len(commonprefix([start_list,path_list]))\n  \n  rel_list=[pardir]*(len(start_list)-i)+path_list[i:]\n  if not rel_list:\n   return curdir\n  return join(*rel_list)\n except (TypeError,AttributeError,BytesWarning,DeprecationWarning):\n  genericpath._check_arg_types('relpath',path,start)\n  raise\n  \n  \n  \n  \n  \n  \n  \ndef commonpath(paths):\n ''\n \n if not paths:\n  raise ValueError('commonpath() arg is an empty sequence')\n  \n paths=tuple(map(os.fspath,paths))\n if isinstance(paths[0],bytes):\n  sep=b'/'\n  curdir=b'.'\n else :\n  sep='/'\n  curdir='.'\n  \n try :\n  split_paths=[path.split(sep)for path in paths]\n  \n  try :\n   isabs,=set(p[:1]==sep for p in paths)\n  except ValueError:\n   raise ValueError(\"Can't mix absolute and relative paths\")from None\n   \n  split_paths=[[c for c in s if c and c !=curdir]for s in split_paths]\n  s1=min(split_paths)\n  s2=max(split_paths)\n  common=s1\n  for i,c in enumerate(s1):\n   if c !=s2[i]:\n    common=s1[:i]\n    break\n    \n  prefix=sep if isabs else sep[:0]\n  return prefix+sep.join(common)\n except (TypeError,AttributeError):\n  genericpath._check_arg_types('commonpath',*paths)\n  raise\n", ["genericpath", "os", "pwd", "re", "stat", "sys"]], "bisect": [".py", "''\n\ndef insort_right(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n \n \n lo=bisect_right(a,x,lo,hi)\n a.insert(lo,x)\n \ndef bisect_right(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n\n\n \n \n if lo <0:\n  raise ValueError('lo must be non-negative')\n if hi is None :\n  hi=len(a)\n while lo <hi:\n  mid=(lo+hi)//2\n  if x <a[mid]:hi=mid\n  else :lo=mid+1\n return lo\n \ndef insort_left(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n \n \n lo=bisect_left(a,x,lo,hi)\n a.insert(lo,x)\n \n \ndef bisect_left(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n\n\n \n \n if lo <0:\n  raise ValueError('lo must be non-negative')\n if hi is None :\n  hi=len(a)\n while lo <hi:\n  mid=(lo+hi)//2\n  if a[mid]<x:lo=mid+1\n  else :hi=mid\n return lo\n \n \ntry :\n from _bisect import *\nexcept ImportError:\n pass\n \n \nbisect=bisect_right\ninsort=insort_right\n", ["_bisect"]], "functools": [".py", "''\n\n\n\n\n\n\n\n\n\n\n__all__=['update_wrapper','wraps','WRAPPER_ASSIGNMENTS','WRAPPER_UPDATES',\n'total_ordering','cmp_to_key','lru_cache','reduce','partial',\n'partialmethod','singledispatch','singledispatchmethod']\n\nfrom abc import get_cache_token\nfrom collections import namedtuple\n\nfrom reprlib import recursive_repr\nfrom _thread import RLock\n\n\n\n\n\n\n\n\n\nWRAPPER_ASSIGNMENTS=('__module__','__name__','__qualname__','__doc__',\n'__annotations__')\nWRAPPER_UPDATES=('__dict__',)\ndef update_wrapper(wrapper,\nwrapped,\nassigned=WRAPPER_ASSIGNMENTS,\nupdated=WRAPPER_UPDATES):\n ''\n\n\n\n\n\n\n\n\n\n \n for attr in assigned:\n  try :\n   value=getattr(wrapped,attr)\n  except AttributeError:\n   pass\n  else :\n   setattr(wrapper,attr,value)\n for attr in updated:\n  getattr(wrapper,attr).update(getattr(wrapped,attr,{}))\n  \n  \n wrapper.__wrapped__=wrapped\n \n return wrapper\n \ndef wraps(wrapped,\nassigned=WRAPPER_ASSIGNMENTS,\nupdated=WRAPPER_UPDATES):\n ''\n\n\n\n\n\n\n \n return partial(update_wrapper,wrapped=wrapped,\n assigned=assigned,updated=updated)\n \n \n \n \n \n \n \n \n \n \n \ndef _gt_from_lt(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__lt__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result and self !=other\n \ndef _le_from_lt(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__lt__(other)\n return op_result or self ==other\n \ndef _ge_from_lt(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__lt__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \ndef _ge_from_le(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__le__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result or self ==other\n \ndef _lt_from_le(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__le__(other)\n if op_result is NotImplemented:\n  return op_result\n return op_result and self !=other\n \ndef _gt_from_le(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__le__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \ndef _lt_from_gt(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__gt__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result and self !=other\n \ndef _ge_from_gt(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__gt__(other)\n return op_result or self ==other\n \ndef _le_from_gt(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__gt__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \ndef _le_from_ge(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__ge__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result or self ==other\n \ndef _gt_from_ge(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__ge__(other)\n if op_result is NotImplemented:\n  return op_result\n return op_result and self !=other\n \ndef _lt_from_ge(self,other,NotImplemented=NotImplemented):\n ''\n op_result=self.__ge__(other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \n_convert={\n'__lt__':[('__gt__',_gt_from_lt),\n('__le__',_le_from_lt),\n('__ge__',_ge_from_lt)],\n'__le__':[('__ge__',_ge_from_le),\n('__lt__',_lt_from_le),\n('__gt__',_gt_from_le)],\n'__gt__':[('__lt__',_lt_from_gt),\n('__ge__',_ge_from_gt),\n('__le__',_le_from_gt)],\n'__ge__':[('__le__',_le_from_ge),\n('__gt__',_gt_from_ge),\n('__lt__',_lt_from_ge)]\n}\n\ndef total_ordering(cls):\n ''\n \n roots={op for op in _convert if getattr(cls,op,None )is not getattr(object,op,None )}\n if not roots:\n  raise ValueError('must define at least one ordering operation: < > <= >=')\n root=max(roots)\n for opname,opfunc in _convert[root]:\n  if opname not in roots:\n   opfunc.__name__=opname\n   setattr(cls,opname,opfunc)\n return cls\n \n \n \n \n \n \ndef cmp_to_key(mycmp):\n ''\n class K(object):\n  __slots__=['obj']\n  def __init__(self,obj):\n   self.obj=obj\n  def __lt__(self,other):\n   return mycmp(self.obj,other.obj)<0\n  def __gt__(self,other):\n   return mycmp(self.obj,other.obj)>0\n  def __eq__(self,other):\n   return mycmp(self.obj,other.obj)==0\n  def __le__(self,other):\n   return mycmp(self.obj,other.obj)<=0\n  def __ge__(self,other):\n   return mycmp(self.obj,other.obj)>=0\n  __hash__=None\n return K\n \ntry :\n from _functools import cmp_to_key\nexcept ImportError:\n pass\n \n \n \n \n \n \n_initial_missing=object()\n\ndef reduce(function,sequence,initial=_initial_missing):\n ''\n\n\n\n\n\n\n\n\n \n \n it=iter(sequence)\n \n if initial is _initial_missing:\n  try :\n   value=next(it)\n  except StopIteration:\n   raise TypeError(\"reduce() of empty sequence with no initial value\")from None\n else :\n  value=initial\n  \n for element in it:\n  value=function(value,element)\n  \n return value\n \ntry :\n from _functools import reduce\nexcept ImportError:\n pass\n \n \n \n \n \n \n \nclass partial:\n ''\n\n \n \n __slots__=\"func\",\"args\",\"keywords\",\"__dict__\",\"__weakref__\"\n \n def __new__(cls,func,/,*args,**keywords):\n  if not callable(func):\n   raise TypeError(\"the first argument must be callable\")\n   \n  if hasattr(func,\"func\"):\n   args=func.args+args\n   keywords={**func.keywords,**keywords}\n   func=func.func\n   \n  self=super(partial,cls).__new__(cls)\n  \n  self.func=func\n  self.args=args\n  self.keywords=keywords\n  return self\n  \n def __call__(self,/,*args,**keywords):\n  keywords={**self.keywords,**keywords}\n  return self.func(*self.args,*args,**keywords)\n  \n @recursive_repr()\n def __repr__(self):\n  qualname=type(self).__qualname__\n  args=[repr(self.func)]\n  args.extend(repr(x)for x in self.args)\n  args.extend(f\"{k}={v!r}\"for (k,v)in self.keywords.items())\n  if type(self).__module__ ==\"functools\":\n   return f\"functools.{qualname}({', '.join(args)})\"\n  return f\"{qualname}({', '.join(args)})\"\n  \n def __reduce__(self):\n  return type(self),(self.func,),(self.func,self.args,\n  self.keywords or None ,self.__dict__ or None )\n  \n def __setstate__(self,state):\n  if not isinstance(state,tuple):\n   raise TypeError(\"argument to __setstate__ must be a tuple\")\n  if len(state)!=4:\n   raise TypeError(f\"expected 4 items in state, got {len(state)}\")\n  func,args,kwds,namespace=state\n  if (not callable(func)or not isinstance(args,tuple)or\n  (kwds is not None and not isinstance(kwds,dict))or\n  (namespace is not None and not isinstance(namespace,dict))):\n   raise TypeError(\"invalid partial state\")\n   \n  args=tuple(args)\n  if kwds is None :\n   kwds={}\n  elif type(kwds)is not dict:\n   kwds=dict(kwds)\n  if namespace is None :\n   namespace={}\n   \n  self.__dict__=namespace\n  self.func=func\n  self.args=args\n  self.keywords=kwds\n  \ntry :\n from _functools import partial\nexcept ImportError:\n pass\n \n \nclass partialmethod(object):\n ''\n\n\n\n\n \n \n def __init__(*args,**keywords):\n  if len(args)>=2:\n   self,func,*args=args\n  elif not args:\n   raise TypeError(\"descriptor '__init__' of partialmethod \"\n   \"needs an argument\")\n  elif 'func'in keywords:\n   func=keywords.pop('func')\n   self,*args=args\n   import warnings\n   warnings.warn(\"Passing 'func' as keyword argument is deprecated\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   raise TypeError(\"type 'partialmethod' takes at least one argument, \"\n   \"got %d\"%(len(args)-1))\n  args=tuple(args)\n  \n  if not callable(func)and not hasattr(func,\"__get__\"):\n   raise TypeError(\"{!r} is not callable or a descriptor\"\n   .format(func))\n   \n   \n   \n  if isinstance(func,partialmethod):\n  \n  \n  \n   self.func=func.func\n   self.args=func.args+args\n   self.keywords={**func.keywords,**keywords}\n  else :\n   self.func=func\n   self.args=args\n   self.keywords=keywords\n __init__.__text_signature__='($self, func, /, *args, **keywords)'\n \n def __repr__(self):\n  args=\", \".join(map(repr,self.args))\n  keywords=\", \".join(\"{}={!r}\".format(k,v)\n  for k,v in self.keywords.items())\n  format_string=\"{module}.{cls}({func}, {args}, {keywords})\"\n  return format_string.format(module=self.__class__.__module__,\n  cls=self.__class__.__qualname__,\n  func=self.func,\n  args=args,\n  keywords=keywords)\n  \n def _make_unbound_method(self):\n  def _method(cls_or_self,/,*args,**keywords):\n   keywords={**self.keywords,**keywords}\n   return self.func(cls_or_self,*self.args,*args,**keywords)\n  _method.__isabstractmethod__=self.__isabstractmethod__\n  _method._partialmethod=self\n  return _method\n  \n def __get__(self,obj,cls=None ):\n  get=getattr(self.func,\"__get__\",None )\n  result=None\n  if get is not None :\n   new_func=get(obj,cls)\n   if new_func is not self.func:\n   \n   \n    result=partial(new_func,*self.args,**self.keywords)\n    try :\n     result.__self__=new_func.__self__\n    except AttributeError:\n     pass\n  if result is None :\n  \n  \n   result=self._make_unbound_method().__get__(obj,cls)\n  return result\n  \n @property\n def __isabstractmethod__(self):\n  return getattr(self.func,\"__isabstractmethod__\",False )\n  \n  \n  \ndef _unwrap_partial(func):\n while isinstance(func,partial):\n  func=func.func\n return func\n \n \n \n \n \n_CacheInfo=namedtuple(\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"])\n\nclass _HashedSeq(list):\n ''\n\n\n\n \n \n __slots__='hashvalue'\n \n def __init__(self,tup,hash=hash):\n  self[:]=tup\n  self.hashvalue=hash(tup)\n  \n def __hash__(self):\n  return self.hashvalue\n  \ndef _make_key(args,kwds,typed,\nkwd_mark=(object(),),\nfasttypes={int,str},\ntuple=tuple,type=type,len=len):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n \n key=args\n if kwds:\n  key +=kwd_mark\n  for item in kwds.items():\n   key +=item\n if typed:\n  key +=tuple(type(v)for v in args)\n  if kwds:\n   key +=tuple(type(v)for v in kwds.values())\n elif len(key)==1 and type(key[0])in fasttypes:\n  return key[0]\n return _HashedSeq(key)\n \ndef lru_cache(maxsize=128,typed=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n if isinstance(maxsize,int):\n \n  if maxsize <0:\n   maxsize=0\n elif callable(maxsize)and isinstance(typed,bool):\n \n  user_function,maxsize=maxsize,128\n  wrapper=_lru_cache_wrapper(user_function,maxsize,typed,_CacheInfo)\n  return update_wrapper(wrapper,user_function)\n elif maxsize is not None :\n  raise TypeError(\n  'Expected first argument to be an integer, a callable, or None')\n  \n def decorating_function(user_function):\n  wrapper=_lru_cache_wrapper(user_function,maxsize,typed,_CacheInfo)\n  return update_wrapper(wrapper,user_function)\n  \n return decorating_function\n \ndef _lru_cache_wrapper(user_function,maxsize,typed,_CacheInfo):\n\n sentinel=object()\n make_key=_make_key\n PREV,NEXT,KEY,RESULT=0,1,2,3\n \n cache={}\n hits=misses=0\n full=False\n cache_get=cache.get\n cache_len=cache.__len__\n lock=RLock()\n root=[]\n root[:]=[root,root,None ,None ]\n \n if maxsize ==0:\n \n  def wrapper(*args,**kwds):\n  \n   nonlocal misses\n   misses +=1\n   result=user_function(*args,**kwds)\n   return result\n   \n elif maxsize is None :\n \n  def wrapper(*args,**kwds):\n  \n   nonlocal hits,misses\n   key=make_key(args,kwds,typed)\n   result=cache_get(key,sentinel)\n   if result is not sentinel:\n    hits +=1\n    return result\n   misses +=1\n   result=user_function(*args,**kwds)\n   cache[key]=result\n   return result\n   \n else :\n \n  def wrapper(*args,**kwds):\n  \n   nonlocal root,hits,misses,full\n   key=make_key(args,kwds,typed)\n   with lock:\n    link=cache_get(key)\n    if link is not None :\n    \n     link_prev,link_next,_key,result=link\n     link_prev[NEXT]=link_next\n     link_next[PREV]=link_prev\n     last=root[PREV]\n     last[NEXT]=root[PREV]=link\n     link[PREV]=last\n     link[NEXT]=root\n     hits +=1\n     return result\n    misses +=1\n   result=user_function(*args,**kwds)\n   with lock:\n    if key in cache:\n    \n    \n    \n    \n     pass\n    elif full:\n    \n     oldroot=root\n     oldroot[KEY]=key\n     oldroot[RESULT]=result\n     \n     \n     \n     \n     \n     \n     root=oldroot[NEXT]\n     oldkey=root[KEY]\n     oldresult=root[RESULT]\n     root[KEY]=root[RESULT]=None\n     \n     del cache[oldkey]\n     \n     \n     \n     cache[key]=oldroot\n    else :\n    \n     last=root[PREV]\n     link=[last,root,key,result]\n     last[NEXT]=root[PREV]=cache[key]=link\n     \n     \n     full=(cache_len()>=maxsize)\n   return result\n   \n def cache_info():\n  ''\n  with lock:\n   return _CacheInfo(hits,misses,maxsize,cache_len())\n   \n def cache_clear():\n  ''\n  nonlocal hits,misses,full\n  with lock:\n   cache.clear()\n   root[:]=[root,root,None ,None ]\n   hits=misses=0\n   full=False\n   \n wrapper.cache_info=cache_info\n wrapper.cache_clear=cache_clear\n return wrapper\n \ntry :\n from _functools import _lru_cache_wrapper\nexcept ImportError:\n pass\n \n \n \n \n \n \ndef _c3_merge(sequences):\n ''\n\n\n\n \n result=[]\n while True :\n  sequences=[s for s in sequences if s]\n  if not sequences:\n   return result\n  for s1 in sequences:\n   candidate=s1[0]\n   for s2 in sequences:\n    if candidate in s2[1:]:\n     candidate=None\n     break\n   else :\n    break\n  if candidate is None :\n   raise RuntimeError(\"Inconsistent hierarchy\")\n  result.append(candidate)\n  \n  for seq in sequences:\n   if seq[0]==candidate:\n    del seq[0]\n    \ndef _c3_mro(cls,abcs=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n for i,base in enumerate(reversed(cls.__bases__)):\n  if hasattr(base,'__abstractmethods__'):\n   boundary=len(cls.__bases__)-i\n   break\n else :\n  boundary=0\n abcs=list(abcs)if abcs else []\n explicit_bases=list(cls.__bases__[:boundary])\n abstract_bases=[]\n other_bases=list(cls.__bases__[boundary:])\n for base in abcs:\n  if issubclass(cls,base)and not any(\n  issubclass(b,base)for b in cls.__bases__\n  ):\n  \n  \n   abstract_bases.append(base)\n for base in abstract_bases:\n  abcs.remove(base)\n explicit_c3_mros=[_c3_mro(base,abcs=abcs)for base in explicit_bases]\n abstract_c3_mros=[_c3_mro(base,abcs=abcs)for base in abstract_bases]\n other_c3_mros=[_c3_mro(base,abcs=abcs)for base in other_bases]\n return _c3_merge(\n [[cls]]+\n explicit_c3_mros+abstract_c3_mros+other_c3_mros+\n [explicit_bases]+[abstract_bases]+[other_bases]\n )\n \ndef _compose_mro(cls,types):\n ''\n\n\n\n\n \n bases=set(cls.__mro__)\n \n def is_related(typ):\n  return (typ not in bases and hasattr(typ,'__mro__')\n  and issubclass(cls,typ))\n types=[n for n in types if is_related(n)]\n \n \n def is_strict_base(typ):\n  for other in types:\n   if typ !=other and typ in other.__mro__:\n    return True\n  return False\n types=[n for n in types if not is_strict_base(n)]\n \n \n type_set=set(types)\n mro=[]\n for typ in types:\n  found=[]\n  for sub in typ.__subclasses__():\n   if sub not in bases and issubclass(cls,sub):\n    found.append([s for s in sub.__mro__ if s in type_set])\n  if not found:\n   mro.append(typ)\n   continue\n   \n  found.sort(key=len,reverse=True )\n  for sub in found:\n   for subcls in sub:\n    if subcls not in mro:\n     mro.append(subcls)\n return _c3_mro(cls,abcs=mro)\n \ndef _find_impl(cls,registry):\n ''\n\n\n\n\n\n\n\n \n mro=_compose_mro(cls,registry.keys())\n match=None\n for t in mro:\n  if match is not None :\n  \n  \n   if (t in registry and t not in cls.__mro__\n   and match not in cls.__mro__\n   and not issubclass(match,t)):\n    raise RuntimeError(\"Ambiguous dispatch: {} or {}\".format(\n    match,t))\n   break\n  if t in registry:\n   match=t\n return registry.get(match)\n \ndef singledispatch(func):\n ''\n\n\n\n\n\n\n \n \n \n \n import types,weakref\n \n registry={}\n dispatch_cache=weakref.WeakKeyDictionary()\n cache_token=None\n \n def dispatch(cls):\n  ''\n\n\n\n\n  \n  nonlocal cache_token\n  if cache_token is not None :\n   current_token=get_cache_token()\n   if cache_token !=current_token:\n    dispatch_cache.clear()\n    cache_token=current_token\n  try :\n   impl=dispatch_cache[cls]\n  except KeyError:\n   try :\n    impl=registry[cls]\n   except KeyError:\n    impl=_find_impl(cls,registry)\n   dispatch_cache[cls]=impl\n  return impl\n  \n def register(cls,func=None ):\n  ''\n\n\n\n  \n  nonlocal cache_token\n  if func is None :\n   if isinstance(cls,type):\n    return lambda f:register(cls,f)\n   ann=getattr(cls,'__annotations__',{})\n   if not ann:\n    raise TypeError(\n    f\"Invalid first argument to `register()`: {cls!r}. \"\n    f\"Use either `@register(some_class)` or plain `@register` \"\n    f\"on an annotated function.\"\n    )\n   func=cls\n   \n   \n   from typing import get_type_hints\n   argname,cls=next(iter(get_type_hints(func).items()))\n   if not isinstance(cls,type):\n    raise TypeError(\n    f\"Invalid annotation for {argname!r}. \"\n    f\"{cls!r} is not a class.\"\n    )\n  registry[cls]=func\n  if cache_token is None and hasattr(cls,'__abstractmethods__'):\n   cache_token=get_cache_token()\n  dispatch_cache.clear()\n  return func\n  \n def wrapper(*args,**kw):\n  if not args:\n   raise TypeError(f'{funcname} requires at least '\n   '1 positional argument')\n   \n  return dispatch(args[0].__class__)(*args,**kw)\n  \n funcname=getattr(func,'__name__','singledispatch function')\n registry[object]=func\n wrapper.register=register\n wrapper.dispatch=dispatch\n wrapper.registry=types.MappingProxyType(registry)\n wrapper._clear_cache=dispatch_cache.clear\n update_wrapper(wrapper,func)\n return wrapper\n \n \n \nclass singledispatchmethod:\n ''\n\n\n\n \n \n def __init__(self,func):\n  if not callable(func)and not hasattr(func,\"__get__\"):\n   raise TypeError(f\"{func!r} is not callable or a descriptor\")\n   \n  self.dispatcher=singledispatch(func)\n  self.func=func\n  \n def register(self,cls,method=None ):\n  ''\n\n\n  \n  return self.dispatcher.register(cls,func=method)\n  \n def __get__(self,obj,cls=None ):\n  def _method(*args,**kwargs):\n   method=self.dispatcher.dispatch(args[0].__class__)\n   return method.__get__(obj,cls)(*args,**kwargs)\n   \n  _method.__isabstractmethod__=self.__isabstractmethod__\n  _method.register=self.register\n  update_wrapper(_method,self.func)\n  return _method\n  \n @property\n def __isabstractmethod__(self):\n  return getattr(self.func,'__isabstractmethod__',False )\n  \n  \n  \n  \n  \n  \n_NOT_FOUND=object()\n\n\nclass cached_property:\n def __init__(self,func):\n  self.func=func\n  self.attrname=None\n  self.__doc__=func.__doc__\n  self.lock=RLock()\n  \n def __set_name__(self,owner,name):\n  if self.attrname is None :\n   self.attrname=name\n  elif name !=self.attrname:\n   raise TypeError(\n   \"Cannot assign the same cached_property to two different names \"\n   f\"({self.attrname!r} and {name!r}).\"\n   )\n   \n def __get__(self,instance,owner=None ):\n  if instance is None :\n   return self\n  if self.attrname is None :\n   raise TypeError(\n   \"Cannot use cached_property instance without calling __set_name__ on it.\")\n  try :\n   cache=instance.__dict__\n  except AttributeError:\n   msg=(\n   f\"No '__dict__' attribute on {type(instance).__name__!r} \"\n   f\"instance to cache {self.attrname!r} property.\"\n   )\n   raise TypeError(msg)from None\n  val=cache.get(self.attrname,_NOT_FOUND)\n  if val is _NOT_FOUND:\n   with self.lock:\n   \n    val=cache.get(self.attrname,_NOT_FOUND)\n    if val is _NOT_FOUND:\n     val=self.func(instance)\n     try :\n      cache[self.attrname]=val\n     except TypeError:\n      msg=(\n      f\"The '__dict__' attribute on {type(instance).__name__!r} instance \"\n      f\"does not support item assignment for caching {self.attrname!r} property.\"\n      )\n      raise TypeError(msg)from None\n  return val\n", ["_functools", "_thread", "abc", "collections", "reprlib", "types", "typing", "warnings", "weakref"]], "platform": [".py", "''\n\n\n\nfrom browser import self as window\n\ndef architecture(*args,**kw):\n return \"<unknown>\",window.navigator.platform\n \ndef machine(*args,**kw):\n return ''\n \ndef node(*args,**kw):\n return ''\n \ndef platform(*args,**kw):\n return window.navigator.platform\n \ndef processor(*args,**kw):\n return ''\n \ndef python_build():\n return ('.'.join(map(str,__BRYTHON__.implementation[:-1])),\n __BRYTHON__.compiled_date)\n \ndef python_compiler():\n return ''\n \ndef python_branch():\n return ''\n \ndef python_implementation():\n return 'Brython'\n \ndef python_revision():\n return ''\n \ndef python_version():\n return '.'.join(map(str,__BRYTHON__.version_info[:3]))\n \ndef python_version_tuple():\n return __BRYTHON__.version_info[:3]\n \ndef release():\n return ''\n \ndef system():\n return window.navigator.platform\n \ndef system_alias(*args,**kw):\n return window.navigator.platform\n \ndef uname():\n from collections import namedtuple\n klass=namedtuple('uname_result',\n 'system node release version machine processor')\n return klass(window.navigator.platform,'','','','','')\n", ["browser", "collections"]], "_functools": [".py", "from reprlib import recursive_repr\n\nclass partial:\n ''\n\n \n \n __slots__=\"func\",\"args\",\"keywords\",\"__dict__\",\"__weakref__\"\n \n def __new__(*args,**keywords):\n  if not args:\n   raise TypeError(\"descriptor '__new__' of partial needs an argument\")\n  if len(args)<2:\n   raise TypeError(\"type 'partial' takes at least one argument\")\n  cls,func,*args=args\n  if not callable(func):\n   raise TypeError(\"the first argument must be callable\")\n  args=tuple(args)\n  \n  if hasattr(func,\"func\"):\n   args=func.args+args\n   tmpkw=func.keywords.copy()\n   tmpkw.update(keywords)\n   keywords=tmpkw\n   del tmpkw\n   func=func.func\n   \n  self=super(partial,cls).__new__(cls)\n  \n  self.func=func\n  self.args=args\n  self.keywords=keywords\n  return self\n  \n def __call__(*args,**keywords):\n  if not args:\n   raise TypeError(\"descriptor '__call__' of partial needs an argument\")\n  self,*args=args\n  newkeywords=self.keywords.copy()\n  newkeywords.update(keywords)\n  return self.func(*self.args,*args,**newkeywords)\n  \n @recursive_repr()\n def __repr__(self):\n  qualname=type(self).__qualname__\n  args=[repr(self.func)]\n  args.extend(repr(x)for x in self.args)\n  args.extend(f\"{k}={v!r}\"for (k,v)in self.keywords.items())\n  if type(self).__module__ ==\"functools\":\n   return f\"functools.{qualname}({', '.join(args)})\"\n  return f\"{qualname}({', '.join(args)})\"\n  \n def __reduce__(self):\n  return type(self),(self.func,),(self.func,self.args,\n  self.keywords or None ,self.__dict__ or None )\n  \n def __setstate__(self,state):\n  if not isinstance(state,tuple):\n   raise TypeError(\"argument to __setstate__ must be a tuple\")\n  if len(state)!=4:\n   raise TypeError(f\"expected 4 items in state, got {len(state)}\")\n  func,args,kwds,namespace=state\n  if (not callable(func)or not isinstance(args,tuple)or\n  (kwds is not None and not isinstance(kwds,dict))or\n  (namespace is not None and not isinstance(namespace,dict))):\n   raise TypeError(\"invalid partial state\")\n   \n  args=tuple(args)\n  if kwds is None :\n   kwds={}\n  elif type(kwds)is not dict:\n   kwds=dict(kwds)\n  if namespace is None :\n   namespace={}\n   \n  self.__dict__=namespace\n  self.func=func\n  self.args=args\n  self.keywords=kwds\n  \ndef reduce(func,iterable,initializer=None ):\n args=iter(iterable)\n if initializer is not None :\n  res=initializer\n else :\n  res=next(args)\n while True :\n  try :\n   res=func(res,next(args))\n  except StopIteration:\n   return res\n", ["reprlib"]], "linecache": [".py", "''\n\n\n\n\n\n\nimport functools\nimport sys\nimport os\nimport tokenize\n\n__all__=[\"getline\",\"clearcache\",\"checkcache\"]\n\ndef getline(filename,lineno,module_globals=None ):\n lines=getlines(filename,module_globals)\n if 1 <=lineno <=len(lines):\n  return lines[lineno -1]\n else :\n  return ''\n  \n  \n  \n  \n  \n  \ncache={}\n\n\ndef clearcache():\n ''\n \n global cache\n cache={}\n \n \ndef getlines(filename,module_globals=None ):\n ''\n \n \n if filename in cache:\n  entry=cache[filename]\n  if len(entry)!=1:\n   return cache[filename][2]\n   \n try :\n  return updatecache(filename,module_globals)\n except MemoryError:\n  clearcache()\n  return []\n  \n  \ndef checkcache(filename=None ):\n ''\n \n \n if filename is None :\n  filenames=list(cache.keys())\n else :\n  if filename in cache:\n   filenames=[filename]\n  else :\n   return\n   \n for filename in filenames:\n  entry=cache[filename]\n  if len(entry)==1:\n  \n   continue\n  size,mtime,lines,fullname=entry\n  if mtime is None :\n   continue\n  try :\n   stat=os.stat(fullname)\n  except OSError:\n   del cache[filename]\n   continue\n  if size !=stat.st_size or mtime !=stat.st_mtime:\n   del cache[filename]\n   \n   \ndef updatecache(filename,module_globals=None ):\n ''\n\n \n \n if filename in cache:\n  if len(cache[filename])!=1:\n   del cache[filename]\n if not filename or (filename.startswith('<')and filename.endswith('>')):\n  return []\n  \n fullname=filename\n try :\n  stat=os.stat(fullname)\n except OSError:\n  basename=filename\n  \n  \n  \n  if lazycache(filename,module_globals):\n   try :\n    data=cache[filename][0]()\n   except (ImportError,OSError):\n    pass\n   else :\n    if data is None :\n    \n    \n     return []\n    cache[filename]=(\n    len(data),None ,\n    [line+'\\n'for line in data.splitlines()],fullname\n    )\n    return cache[filename][2]\n    \n    \n    \n  if os.path.isabs(filename):\n   return []\n   \n  for dirname in sys.path:\n   try :\n    fullname=os.path.join(dirname,basename)\n   except (TypeError,AttributeError):\n   \n    continue\n   try :\n    stat=os.stat(fullname)\n    break\n   except OSError:\n    pass\n  else :\n   return []\n try :\n  with tokenize.open(fullname)as fp:\n   lines=fp.readlines()\n except OSError:\n  return []\n if lines and not lines[-1].endswith('\\n'):\n  lines[-1]+='\\n'\n size,mtime=stat.st_size,stat.st_mtime\n cache[filename]=size,mtime,lines,fullname\n return lines\n \n \ndef lazycache(filename,module_globals):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if filename in cache:\n  if len(cache[filename])==1:\n   return True\n  else :\n   return False\n if not filename or (filename.startswith('<')and filename.endswith('>')):\n  return False\n  \n if module_globals and '__loader__'in module_globals:\n  name=module_globals.get('__name__')\n  loader=module_globals['__loader__']\n  get_source=getattr(loader,'get_source',None )\n  \n  if name and get_source:\n   get_lines=functools.partial(get_source,name)\n   cache[filename]=(get_lines,)\n   return True\n return False\n", ["functools", "os", "sys", "tokenize"]], "codecs": [".py", "''\n\n\n\n\n\n\n\n\nimport builtins\nimport sys\n\n\n\ntry :\n from _codecs import *\nexcept ImportError as why:\n raise SystemError('Failed to load the builtin codecs: %s'%why)\n \n__all__=[\"register\",\"lookup\",\"open\",\"EncodedFile\",\"BOM\",\"BOM_BE\",\n\"BOM_LE\",\"BOM32_BE\",\"BOM32_LE\",\"BOM64_BE\",\"BOM64_LE\",\n\"BOM_UTF8\",\"BOM_UTF16\",\"BOM_UTF16_LE\",\"BOM_UTF16_BE\",\n\"BOM_UTF32\",\"BOM_UTF32_LE\",\"BOM_UTF32_BE\",\n\"CodecInfo\",\"Codec\",\"IncrementalEncoder\",\"IncrementalDecoder\",\n\"StreamReader\",\"StreamWriter\",\n\"StreamReaderWriter\",\"StreamRecoder\",\n\"getencoder\",\"getdecoder\",\"getincrementalencoder\",\n\"getincrementaldecoder\",\"getreader\",\"getwriter\",\n\"encode\",\"decode\",\"iterencode\",\"iterdecode\",\n\"strict_errors\",\"ignore_errors\",\"replace_errors\",\n\"xmlcharrefreplace_errors\",\n\"backslashreplace_errors\",\"namereplace_errors\",\n\"register_error\",\"lookup_error\"]\n\n\n\n\n\n\n\n\n\n\nBOM_UTF8=b'\\xef\\xbb\\xbf'\n\n\nBOM_LE=BOM_UTF16_LE=b'\\xff\\xfe'\n\n\nBOM_BE=BOM_UTF16_BE=b'\\xfe\\xff'\n\n\nBOM_UTF32_LE=b'\\xff\\xfe\\x00\\x00'\n\n\nBOM_UTF32_BE=b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder =='little':\n\n\n BOM=BOM_UTF16=BOM_UTF16_LE\n \n \n BOM_UTF32=BOM_UTF32_LE\n \nelse :\n\n\n BOM=BOM_UTF16=BOM_UTF16_BE\n \n \n BOM_UTF32=BOM_UTF32_BE\n \n \nBOM32_LE=BOM_UTF16_LE\nBOM32_BE=BOM_UTF16_BE\nBOM64_LE=BOM_UTF32_LE\nBOM64_BE=BOM_UTF32_BE\n\n\n\n\nclass CodecInfo(tuple):\n ''\n \n \n \n \n \n \n \n _is_text_encoding=True\n \n def __new__(cls,encode,decode,streamreader=None ,streamwriter=None ,\n incrementalencoder=None ,incrementaldecoder=None ,name=None ,\n *,_is_text_encoding=None ):\n  self=tuple.__new__(cls,(encode,decode,streamreader,streamwriter))\n  self.name=name\n  self.encode=encode\n  self.decode=decode\n  self.incrementalencoder=incrementalencoder\n  self.incrementaldecoder=incrementaldecoder\n  self.streamwriter=streamwriter\n  self.streamreader=streamreader\n  if _is_text_encoding is not None :\n   self._is_text_encoding=_is_text_encoding\n  return self\n  \n def __repr__(self):\n  return \"<%s.%s object for encoding %s at %#x>\"%\\\n  (self.__class__.__module__,self.__class__.__qualname__,\n  self.name,id(self))\n  \nclass Codec:\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def encode(self,input,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError\n  \n def decode(self,input,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError\n  \nclass IncrementalEncoder(object):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  ''\n\n\n\n\n\n  \n  self.errors=errors\n  self.buffer=\"\"\n  \n def encode(self,input,final=False ):\n  ''\n\n  \n  raise NotImplementedError\n  \n def reset(self):\n  ''\n\n  \n  \n def getstate(self):\n  ''\n\n  \n  return 0\n  \n def setstate(self,state):\n  ''\n\n\n  \n  \nclass BufferedIncrementalEncoder(IncrementalEncoder):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  IncrementalEncoder.__init__(self,errors)\n  \n  self.buffer=\"\"\n  \n def _buffer_encode(self,input,errors,final):\n \n \n  raise NotImplementedError\n  \n def encode(self,input,final=False ):\n \n  data=self.buffer+input\n  (result,consumed)=self._buffer_encode(data,self.errors,final)\n  \n  self.buffer=data[consumed:]\n  return result\n  \n def reset(self):\n  IncrementalEncoder.reset(self)\n  self.buffer=\"\"\n  \n def getstate(self):\n  return self.buffer or 0\n  \n def setstate(self,state):\n  self.buffer=state or \"\"\n  \nclass IncrementalDecoder(object):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  ''\n\n\n\n\n\n  \n  self.errors=errors\n  \n def decode(self,input,final=False ):\n  ''\n\n  \n  raise NotImplementedError\n  \n def reset(self):\n  ''\n\n  \n  \n def getstate(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  return (b\"\",0)\n  \n def setstate(self,state):\n  ''\n\n\n\n\n  \n  \nclass BufferedIncrementalDecoder(IncrementalDecoder):\n ''\n\n\n\n \n def __init__(self,errors='strict'):\n  IncrementalDecoder.__init__(self,errors)\n  \n  self.buffer=b\"\"\n  \n def _buffer_decode(self,input,errors,final):\n \n \n  raise NotImplementedError\n  \n def decode(self,input,final=False ):\n \n  data=self.buffer+input\n  (result,consumed)=self._buffer_decode(data,self.errors,final)\n  \n  self.buffer=data[consumed:]\n  return result\n  \n def reset(self):\n  IncrementalDecoder.reset(self)\n  self.buffer=b\"\"\n  \n def getstate(self):\n \n  return (self.buffer,0)\n  \n def setstate(self,state):\n \n  self.buffer=state[0]\n  \n  \n  \n  \n  \n  \n  \n  \nclass StreamWriter(Codec):\n\n def __init__(self,stream,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.stream=stream\n  self.errors=errors\n  \n def write(self,object):\n \n  ''\n  \n  data,consumed=self.encode(object,self.errors)\n  self.stream.write(data)\n  \n def writelines(self,list):\n \n  ''\n\n  \n  self.write(''.join(list))\n  \n def reset(self):\n \n  ''\n\n\n\n\n\n\n  \n  pass\n  \n def seek(self,offset,whence=0):\n  self.stream.seek(offset,whence)\n  if whence ==0 and offset ==0:\n   self.reset()\n   \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self.stream,name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self.stream.close()\n  \n  \n  \nclass StreamReader(Codec):\n\n charbuffertype=str\n \n def __init__(self,stream,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.stream=stream\n  self.errors=errors\n  self.bytebuffer=b\"\"\n  self._empty_charbuffer=self.charbuffertype()\n  self.charbuffer=self._empty_charbuffer\n  self.linebuffer=None\n  \n def decode(self,input,errors='strict'):\n  raise NotImplementedError\n  \n def read(self,size=-1,chars=-1,firstline=False ):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self.linebuffer:\n   self.charbuffer=self._empty_charbuffer.join(self.linebuffer)\n   self.linebuffer=None\n   \n  if chars <0:\n  \n  \n   chars=size\n   \n   \n  while True :\n  \n   if chars >=0:\n    if len(self.charbuffer)>=chars:\n     break\n     \n   if size <0:\n    newdata=self.stream.read()\n   else :\n    newdata=self.stream.read(size)\n    \n   data=self.bytebuffer+newdata\n   if not data:\n    break\n   try :\n    newchars,decodedbytes=self.decode(data,self.errors)\n   except UnicodeDecodeError as exc:\n    if firstline:\n     newchars,decodedbytes=\\\n     self.decode(data[:exc.start],self.errors)\n     lines=newchars.splitlines(keepends=True )\n     if len(lines)<=1:\n      raise\n    else :\n     raise\n     \n   self.bytebuffer=data[decodedbytes:]\n   \n   self.charbuffer +=newchars\n   \n   if not newdata:\n    break\n  if chars <0:\n  \n   result=self.charbuffer\n   self.charbuffer=self._empty_charbuffer\n  else :\n  \n   result=self.charbuffer[:chars]\n   self.charbuffer=self.charbuffer[chars:]\n  return result\n  \n def readline(self,size=None ,keepends=True ):\n \n  ''\n\n\n\n\n\n  \n  \n  \n  if self.linebuffer:\n   line=self.linebuffer[0]\n   del self.linebuffer[0]\n   if len(self.linebuffer)==1:\n   \n   \n    self.charbuffer=self.linebuffer[0]\n    self.linebuffer=None\n   if not keepends:\n    line=line.splitlines(keepends=False )[0]\n   return line\n   \n  readsize=size or 72\n  line=self._empty_charbuffer\n  \n  while True :\n   data=self.read(readsize,firstline=True )\n   if data:\n   \n   \n   \n    if (isinstance(data,str)and data.endswith(\"\\r\"))or\\\n    (isinstance(data,bytes)and data.endswith(b\"\\r\")):\n     data +=self.read(size=1,chars=1)\n     \n   line +=data\n   lines=line.splitlines(keepends=True )\n   if lines:\n    if len(lines)>1:\n    \n    \n     line=lines[0]\n     del lines[0]\n     if len(lines)>1:\n     \n      lines[-1]+=self.charbuffer\n      self.linebuffer=lines\n      self.charbuffer=None\n     else :\n     \n      self.charbuffer=lines[0]+self.charbuffer\n     if not keepends:\n      line=line.splitlines(keepends=False )[0]\n     break\n    line0withend=lines[0]\n    line0withoutend=lines[0].splitlines(keepends=False )[0]\n    if line0withend !=line0withoutend:\n    \n     self.charbuffer=self._empty_charbuffer.join(lines[1:])+\\\n     self.charbuffer\n     if keepends:\n      line=line0withend\n     else :\n      line=line0withoutend\n     break\n     \n   if not data or size is not None :\n    if line and not keepends:\n     line=line.splitlines(keepends=False )[0]\n    break\n   if readsize <8000:\n    readsize *=2\n  return line\n  \n def readlines(self,sizehint=None ,keepends=True ):\n \n  ''\n\n\n\n\n\n\n\n\n  \n  data=self.read()\n  return data.splitlines(keepends)\n  \n def reset(self):\n \n  ''\n\n\n\n\n\n  \n  self.bytebuffer=b\"\"\n  self.charbuffer=self._empty_charbuffer\n  self.linebuffer=None\n  \n def seek(self,offset,whence=0):\n  ''\n\n\n  \n  self.stream.seek(offset,whence)\n  self.reset()\n  \n def __next__(self):\n \n  ''\n  line=self.readline()\n  if line:\n   return line\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self.stream,name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self.stream.close()\n  \n  \n  \nclass StreamReaderWriter:\n\n ''\n\n\n\n\n\n\n \n \n encoding='unknown'\n \n def __init__(self,stream,Reader,Writer,errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n  \n  self.stream=stream\n  self.reader=Reader(stream,errors)\n  self.writer=Writer(stream,errors)\n  self.errors=errors\n  \n def read(self,size=-1):\n \n  return self.reader.read(size)\n  \n def readline(self,size=None ):\n \n  return self.reader.readline(size)\n  \n def readlines(self,sizehint=None ):\n \n  return self.reader.readlines(sizehint)\n  \n def __next__(self):\n \n  ''\n  return next(self.reader)\n  \n def __iter__(self):\n  return self\n  \n def write(self,data):\n \n  return self.writer.write(data)\n  \n def writelines(self,list):\n \n  return self.writer.writelines(list)\n  \n def reset(self):\n \n  self.reader.reset()\n  self.writer.reset()\n  \n def seek(self,offset,whence=0):\n  self.stream.seek(offset,whence)\n  self.reader.reset()\n  if whence ==0 and offset ==0:\n   self.writer.reset()\n   \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self.stream,name)\n  \n  \n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self.stream.close()\n  \n  \n  \nclass StreamRecoder:\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n data_encoding='unknown'\n file_encoding='unknown'\n \n def __init__(self,stream,encode,decode,Reader,Writer,\n errors='strict'):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.stream=stream\n  self.encode=encode\n  self.decode=decode\n  self.reader=Reader(stream,errors)\n  self.writer=Writer(stream,errors)\n  self.errors=errors\n  \n def read(self,size=-1):\n \n  data=self.reader.read(size)\n  data,bytesencoded=self.encode(data,self.errors)\n  return data\n  \n def readline(self,size=None ):\n \n  if size is None :\n   data=self.reader.readline()\n  else :\n   data=self.reader.readline(size)\n  data,bytesencoded=self.encode(data,self.errors)\n  return data\n  \n def readlines(self,sizehint=None ):\n \n  data=self.reader.read()\n  data,bytesencoded=self.encode(data,self.errors)\n  return data.splitlines(keepends=True )\n  \n def __next__(self):\n \n  ''\n  data=next(self.reader)\n  data,bytesencoded=self.encode(data,self.errors)\n  return data\n  \n def __iter__(self):\n  return self\n  \n def write(self,data):\n \n  data,bytesdecoded=self.decode(data,self.errors)\n  return self.writer.write(data)\n  \n def writelines(self,list):\n \n  data=b''.join(list)\n  data,bytesdecoded=self.decode(data,self.errors)\n  return self.writer.write(data)\n  \n def reset(self):\n \n  self.reader.reset()\n  self.writer.reset()\n  \n def seek(self,offset,whence=0):\n \n \n  self.reader.seek(offset,whence)\n  self.writer.seek(offset,whence)\n  \n def __getattr__(self,name,\n getattr=getattr):\n \n  ''\n  \n  return getattr(self.stream,name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,type,value,tb):\n  self.stream.close()\n  \n  \n  \ndef open(filename,mode='r',encoding=None ,errors='strict',buffering=-1):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if encoding is not None and\\\n 'b'not in mode:\n \n  mode=mode+'b'\n file=builtins.open(filename,mode,buffering)\n if encoding is None :\n  return file\n info=lookup(encoding)\n srw=StreamReaderWriter(file,info.streamreader,info.streamwriter,errors)\n \n srw.encoding=encoding\n return srw\n \ndef EncodedFile(file,data_encoding,file_encoding=None ,errors='strict'):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if file_encoding is None :\n  file_encoding=data_encoding\n data_info=lookup(data_encoding)\n file_info=lookup(file_encoding)\n sr=StreamRecoder(file,data_info.encode,data_info.decode,\n file_info.streamreader,file_info.streamwriter,errors)\n \n sr.data_encoding=data_encoding\n sr.file_encoding=file_encoding\n return sr\n \n \n \ndef getencoder(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding).encode\n \ndef getdecoder(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding).decode\n \ndef getincrementalencoder(encoding):\n\n ''\n\n\n\n\n\n \n encoder=lookup(encoding).incrementalencoder\n if encoder is None :\n  raise LookupError(encoding)\n return encoder\n \ndef getincrementaldecoder(encoding):\n\n ''\n\n\n\n\n\n \n decoder=lookup(encoding).incrementaldecoder\n if decoder is None :\n  raise LookupError(encoding)\n return decoder\n \ndef getreader(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding).streamreader\n \ndef getwriter(encoding):\n\n ''\n\n\n\n\n \n return lookup(encoding).streamwriter\n \ndef iterencode(iterator,encoding,errors='strict',**kwargs):\n ''\n\n\n\n\n\n\n \n encoder=getincrementalencoder(encoding)(errors,**kwargs)\n for input in iterator:\n  output=encoder.encode(input)\n  if output:\n   yield output\n output=encoder.encode(\"\",True )\n if output:\n  yield output\n  \ndef iterdecode(iterator,encoding,errors='strict',**kwargs):\n ''\n\n\n\n\n\n\n \n decoder=getincrementaldecoder(encoding)(errors,**kwargs)\n for input in iterator:\n  output=decoder.decode(input)\n  if output:\n   yield output\n output=decoder.decode(b\"\",True )\n if output:\n  yield output\n  \n  \n  \ndef make_identity_dict(rng):\n\n ''\n\n\n\n\n \n return {i:i for i in rng}\n \ndef make_encoding_map(decoding_map):\n\n ''\n\n\n\n\n\n\n\n\n\n \n m={}\n for k,v in decoding_map.items():\n  if not v in m:\n   m[v]=k\n  else :\n   m[v]=None\n return m\n \n \n \ntry :\n strict_errors=lookup_error(\"strict\")\n ignore_errors=lookup_error(\"ignore\")\n replace_errors=lookup_error(\"replace\")\n xmlcharrefreplace_errors=lookup_error(\"xmlcharrefreplace\")\n backslashreplace_errors=lookup_error(\"backslashreplace\")\n namereplace_errors=lookup_error(\"namereplace\")\nexcept LookupError:\n\n strict_errors=None\n ignore_errors=None\n replace_errors=None\n xmlcharrefreplace_errors=None\n backslashreplace_errors=None\n namereplace_errors=None\n \n \n \n_false=0\nif _false:\n import encodings\n \n \n \nif __name__ =='__main__':\n\n\n sys.stdout=EncodedFile(sys.stdout,'latin-1','utf-8')\n \n \n sys.stdin=EncodedFile(sys.stdin,'utf-8','latin-1')\n", ["_codecs", "builtins", "encodings", "sys"]], "_contextvars": [".py", "''\n\n\nclass Context(object):\n\n __contains__=\"<slot wrapper '__contains__' of 'Context' objects>\"\n \n copy=\"<method 'copy' of 'Context' objects>\"\n \n def get(self,*args):\n  pass\n  \n items=\"<method 'items' of 'Context' objects>\"\n \n keys=\"<method 'keys' of 'Context' objects>\"\n \n run=\"<method 'run' of 'Context' objects>\"\n \n values=\"<method 'values' of 'Context' objects>\"\n \nclass ContextVar:\n\n def __init__(self,name,**kw):\n  ''\n  self.name=name\n  if \"default\"in kw:\n   self.default=kw[\"default\"]\n   \n def get(self,*args):\n  if hasattr(self,\"value\"):\n   return self.value\n  elif len(args)==1:\n   return args[0]\n  elif hasattr(self,\"default\"):\n   return self.default\n  raise LookupError(self.name)\n  \n def reset(self,token):\n  if token.old_value ==Token.MISSING:\n   del self.value\n  else :\n   self.value=token.old_value\n   \n def set(self,value):\n  self.value=value\n  return Token(self)\n  \nclass Token(object):\n\n MISSING=\"<Token.MISSING>\"\n \n def __init__(self,contextvar):\n  self.var=contextvar\n  try :\n   self.old_value=contextvar.get()\n  except LookupError:\n   self.old_value=Token.MISSING\n   \ndef copy_context(*args,**kw):\n pass\n", []], "_weakref": [".py", "\n\nclass ProxyType:\n\n def __init__(self,obj):\n  object.__setattr__(self,\"obj\",obj)\n  \n def __setattr__(self,attr,value):\n  setattr(object.__getattribute__(self,\"obj\"),attr,value)\n  \n def __getattr__(self,attr):\n  return getattr(object.__getattribute__(self,\"obj\"),attr)\n  \nCallableProxyType=ProxyType\nProxyTypes=[ProxyType,CallableProxyType]\n\nclass ReferenceType:\n\n def __init__(self,obj,callback):\n  self.obj=obj\n  self.callback=callback\n  \nclass ref:\n\n def __init__(self,obj,callback=None ):\n  self.obj=ReferenceType(obj,callback)\n  self.callback=callback\n  \n def __call__(self):\n  return self.obj.obj\n  \n def __hash__(self):\n  return hash(self.obj.obj)\n  \n def __eq__(self,other):\n  return self.obj.obj ==other.obj.obj\n  \ndef getweakrefcount(obj):\n return 1\n \ndef getweakrefs(obj):\n return obj\n \ndef _remove_dead_weakref(*args):\n pass\n \ndef proxy(obj,callback=None ):\n return ProxyType(obj)\n \n", []], "_frozen_importlib": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_bootstrap_external=None\n_thread=None\nimport _weakref\n\nimport _imp\nimport sys\n\ndef _wrap(new,old):\n ''\n for replace in ['__module__','__name__','__qualname__','__doc__']:\n  if hasattr(old,replace):\n   setattr(new,replace,getattr(old,replace))\n new.__dict__.update(old.__dict__)\n \n \ndef _new_module(name):\n return type(sys)(name)\n \n \n \n \n \n \n_module_locks={}\n\n_blocking_on={}\n\n\nclass _DeadlockError(RuntimeError):\n pass\n \n \nclass _ModuleLock:\n ''\n\n\n \n \n def __init__(self,name):\n  self.lock=_thread.allocate_lock()\n  self.wakeup=_thread.allocate_lock()\n  self.name=name\n  self.owner=None\n  self.count=0\n  self.waiters=0\n  \n def has_deadlock(self):\n \n  me=_thread.get_ident()\n  tid=self.owner\n  while True :\n   lock=_blocking_on.get(tid)\n   if lock is None :\n    return False\n   tid=lock.owner\n   if tid ==me:\n    return True\n    \n def acquire(self):\n  ''\n\n\n\n  \n  tid=_thread.get_ident()\n  _blocking_on[tid]=self\n  try :\n   while True :\n    with self.lock:\n     if self.count ==0 or self.owner ==tid:\n      self.owner=tid\n      self.count +=1\n      return True\n     if self.has_deadlock():\n      raise _DeadlockError('deadlock detected by %r'%self)\n     if self.wakeup.acquire(False ):\n      self.waiters +=1\n      \n    self.wakeup.acquire()\n    self.wakeup.release()\n  finally :\n   del _blocking_on[tid]\n   \n def release(self):\n  tid=_thread.get_ident()\n  with self.lock:\n   if self.owner !=tid:\n    raise RuntimeError('cannot release un-acquired lock')\n   assert self.count >0\n   self.count -=1\n   if self.count ==0:\n    self.owner=None\n    if self.waiters:\n     self.waiters -=1\n     self.wakeup.release()\n     \n def __repr__(self):\n  return '_ModuleLock({!r}) at {}'.format(self.name,id(self))\n  \n  \nclass _DummyModuleLock:\n ''\n \n \n def __init__(self,name):\n  self.name=name\n  self.count=0\n  \n def acquire(self):\n  self.count +=1\n  return True\n  \n def release(self):\n  if self.count ==0:\n   raise RuntimeError('cannot release un-acquired lock')\n  self.count -=1\n  \n def __repr__(self):\n  return '_DummyModuleLock({!r}) at {}'.format(self.name,id(self))\n  \n  \nclass _ModuleLockManager:\n\n def __init__(self,name):\n  self._name=name\n  self._lock=None\n  \n def __enter__(self):\n  self._lock=_get_module_lock(self._name)\n  self._lock.acquire()\n  \n def __exit__(self,*args,**kwargs):\n  self._lock.release()\n  \n  \n  \n  \ndef _get_module_lock(name):\n ''\n\n\n \n \n _imp.acquire_lock()\n try :\n  try :\n   lock=_module_locks[name]()\n  except KeyError:\n   lock=None\n   \n  if lock is None :\n   if _thread is None :\n    lock=_DummyModuleLock(name)\n   else :\n    lock=_ModuleLock(name)\n    \n   def cb(ref,name=name):\n    _imp.acquire_lock()\n    try :\n    \n    \n    \n     if _module_locks.get(name)is ref:\n      del _module_locks[name]\n    finally :\n     _imp.release_lock()\n     \n   _module_locks[name]=_weakref.ref(lock,cb)\n finally :\n  _imp.release_lock()\n  \n return lock\n \n \ndef _lock_unlock_module(name):\n ''\n\n\n\n \n lock=_get_module_lock(name)\n try :\n  lock.acquire()\n except _DeadlockError:\n \n \n  pass\n else :\n  lock.release()\n  \n  \ndef _call_with_frames_removed(f,*args,**kwds):\n ''\n\n\n\n\n\n \n return f(*args,**kwds)\n \n \ndef _verbose_message(message,*args,verbosity=1):\n ''\n if sys.flags.verbose >=verbosity:\n  if not message.startswith(('#','import ')):\n   message='# '+message\n  print(message.format(*args),file=sys.stderr)\n  \n  \ndef _requires_builtin(fxn):\n ''\n def _requires_builtin_wrapper(self,fullname):\n  if fullname not in sys.builtin_module_names:\n   raise ImportError('{!r} is not a built-in module'.format(fullname),\n   name=fullname)\n  return fxn(self,fullname)\n _wrap(_requires_builtin_wrapper,fxn)\n return _requires_builtin_wrapper\n \n \ndef _requires_frozen(fxn):\n ''\n def _requires_frozen_wrapper(self,fullname):\n  if not _imp.is_frozen(fullname):\n   raise ImportError('{!r} is not a frozen module'.format(fullname),\n   name=fullname)\n  return fxn(self,fullname)\n _wrap(_requires_frozen_wrapper,fxn)\n return _requires_frozen_wrapper\n \n \n \ndef _load_module_shim(self,fullname):\n ''\n\n\n\n \n spec=spec_from_loader(fullname,self)\n if fullname in sys.modules:\n  module=sys.modules[fullname]\n  _exec(spec,module)\n  return sys.modules[fullname]\n else :\n  return _load(spec)\n  \n  \n  \ndef _module_repr(module):\n\n loader=getattr(module,'__loader__',None )\n if hasattr(loader,'module_repr'):\n \n \n \n  try :\n   return loader.module_repr(module)\n  except Exception:\n   pass\n try :\n  spec=module.__spec__\n except AttributeError:\n  pass\n else :\n  if spec is not None :\n   return _module_repr_from_spec(spec)\n   \n   \n   \n try :\n  name=module.__name__\n except AttributeError:\n  name='?'\n try :\n  filename=module.__file__\n except AttributeError:\n  if loader is None :\n   return '<module {!r}>'.format(name)\n  else :\n   return '<module {!r} ({!r})>'.format(name,loader)\n else :\n  return '<module {!r} from {!r}>'.format(name,filename)\n  \n  \nclass _installed_safely:\n\n def __init__(self,module):\n  self._module=module\n  self._spec=module.__spec__\n  \n def __enter__(self):\n \n \n \n  self._spec._initializing=True\n  sys.modules[self._spec.name]=self._module\n  \n def __exit__(self,*args):\n  try :\n   spec=self._spec\n   if any(arg is not None for arg in args):\n    try :\n     del sys.modules[spec.name]\n    except KeyError:\n     pass\n   else :\n    _verbose_message('import {!r} # {!r}',spec.name,spec.loader)\n  finally :\n   self._spec._initializing=False\n   \n   \nclass ModuleSpec:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,name,loader,*,origin=None ,loader_state=None ,\n is_package=None ):\n  self.name=name\n  self.loader=loader\n  self.origin=origin\n  self.loader_state=loader_state\n  self.submodule_search_locations=[]if is_package else None\n  \n  \n  self._set_fileattr=False\n  self._cached=None\n  \n def __repr__(self):\n  args=['name={!r}'.format(self.name),\n  'loader={!r}'.format(self.loader)]\n  if self.origin is not None :\n   args.append('origin={!r}'.format(self.origin))\n  if self.submodule_search_locations is not None :\n   args.append('submodule_search_locations={}'\n   .format(self.submodule_search_locations))\n  return '{}({})'.format(self.__class__.__name__,', '.join(args))\n  \n def __eq__(self,other):\n  smsl=self.submodule_search_locations\n  try :\n   return (self.name ==other.name and\n   self.loader ==other.loader and\n   self.origin ==other.origin and\n   smsl ==other.submodule_search_locations and\n   self.cached ==other.cached and\n   self.has_location ==other.has_location)\n  except AttributeError:\n   return False\n   \n @property\n def cached(self):\n  if self._cached is None :\n   if self.origin is not None and self._set_fileattr:\n    if _bootstrap_external is None :\n     raise NotImplementedError\n    self._cached=_bootstrap_external._get_cached(self.origin)\n  return self._cached\n  \n @cached.setter\n def cached(self,cached):\n  self._cached=cached\n  \n @property\n def parent(self):\n  ''\n  if self.submodule_search_locations is None :\n   return self.name.rpartition('.')[0]\n  else :\n   return self.name\n   \n @property\n def has_location(self):\n  return self._set_fileattr\n  \n @has_location.setter\n def has_location(self,value):\n  self._set_fileattr=bool(value)\n  \n  \ndef spec_from_loader(name,loader,*,origin=None ,is_package=None ):\n ''\n if hasattr(loader,'get_filename'):\n  if _bootstrap_external is None :\n   raise NotImplementedError\n  spec_from_file_location=_bootstrap_external.spec_from_file_location\n  \n  if is_package is None :\n   return spec_from_file_location(name,loader=loader)\n  search=[]if is_package else None\n  return spec_from_file_location(name,loader=loader,\n  submodule_search_locations=search)\n  \n if is_package is None :\n  if hasattr(loader,'is_package'):\n   try :\n    is_package=loader.is_package(name)\n   except ImportError:\n    is_package=None\n  else :\n  \n   is_package=False\n   \n return ModuleSpec(name,loader,origin=origin,is_package=is_package)\n \n \ndef _spec_from_module(module,loader=None ,origin=None ):\n\n try :\n  spec=module.__spec__\n except AttributeError:\n  pass\n else :\n  if spec is not None :\n   return spec\n   \n name=module.__name__\n if loader is None :\n  try :\n   loader=module.__loader__\n  except AttributeError:\n  \n   pass\n try :\n  location=module.__file__\n except AttributeError:\n  location=None\n if origin is None :\n  if location is None :\n   try :\n    origin=loader._ORIGIN\n   except AttributeError:\n    origin=None\n  else :\n   origin=location\n try :\n  cached=module.__cached__\n except AttributeError:\n  cached=None\n try :\n  submodule_search_locations=list(module.__path__)\n except AttributeError:\n  submodule_search_locations=None\n  \n spec=ModuleSpec(name,loader,origin=origin)\n spec._set_fileattr=False if location is None else True\n spec.cached=cached\n spec.submodule_search_locations=submodule_search_locations\n return spec\n \n \ndef _init_module_attrs(spec,module,*,override=False ):\n\n\n\n if (override or getattr(module,'__name__',None )is None ):\n  try :\n   module.__name__=spec.name\n  except AttributeError:\n   pass\n   \n if override or getattr(module,'__loader__',None )is None :\n  loader=spec.loader\n  if loader is None :\n  \n   if spec.submodule_search_locations is not None :\n    if _bootstrap_external is None :\n     raise NotImplementedError\n    _NamespaceLoader=_bootstrap_external._NamespaceLoader\n    \n    loader=_NamespaceLoader.__new__(_NamespaceLoader)\n    loader._path=spec.submodule_search_locations\n    spec.loader=loader\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    module.__file__=None\n  try :\n   module.__loader__=loader\n  except AttributeError:\n   pass\n   \n if override or getattr(module,'__package__',None )is None :\n  try :\n   module.__package__=spec.parent\n  except AttributeError:\n   pass\n   \n try :\n  module.__spec__=spec\n except AttributeError:\n  pass\n  \n if override or getattr(module,'__path__',None )is None :\n  if spec.submodule_search_locations is not None :\n   try :\n    module.__path__=spec.submodule_search_locations\n   except AttributeError:\n    pass\n    \n if spec.has_location:\n  if override or getattr(module,'__file__',None )is None :\n   try :\n    module.__file__=spec.origin\n   except AttributeError:\n    pass\n    \n  if override or getattr(module,'__cached__',None )is None :\n   if spec.cached is not None :\n    try :\n     module.__cached__=spec.cached\n    except AttributeError:\n     pass\n return module\n \n \ndef module_from_spec(spec):\n ''\n \n module=None\n if hasattr(spec.loader,'create_module'):\n \n \n  module=spec.loader.create_module(spec)\n elif hasattr(spec.loader,'exec_module'):\n  raise ImportError('loaders that define exec_module() '\n  'must also define create_module()')\n if module is None :\n  module=_new_module(spec.name)\n _init_module_attrs(spec,module)\n return module\n \n \ndef _module_repr_from_spec(spec):\n ''\n \n name='?'if spec.name is None else spec.name\n if spec.origin is None :\n  if spec.loader is None :\n   return '<module {!r}>'.format(name)\n  else :\n   return '<module {!r} ({!r})>'.format(name,spec.loader)\n else :\n  if spec.has_location:\n   return '<module {!r} from {!r}>'.format(name,spec.origin)\n  else :\n   return '<module {!r} ({})>'.format(spec.name,spec.origin)\n   \n   \n   \ndef _exec(spec,module):\n ''\n name=spec.name\n with _ModuleLockManager(name):\n  if sys.modules.get(name)is not module:\n   msg='module {!r} not in sys.modules'.format(name)\n   raise ImportError(msg,name=name)\n  if spec.loader is None :\n   if spec.submodule_search_locations is None :\n    raise ImportError('missing loader',name=spec.name)\n    \n   _init_module_attrs(spec,module,override=True )\n   return module\n  _init_module_attrs(spec,module,override=True )\n  if not hasattr(spec.loader,'exec_module'):\n  \n  \n  \n   spec.loader.load_module(name)\n  else :\n   spec.loader.exec_module(module)\n return sys.modules[name]\n \n \ndef _load_backward_compatible(spec):\n\n\n\n spec.loader.load_module(spec.name)\n \n module=sys.modules[spec.name]\n if getattr(module,'__loader__',None )is None :\n  try :\n   module.__loader__=spec.loader\n  except AttributeError:\n   pass\n if getattr(module,'__package__',None )is None :\n  try :\n  \n  \n  \n   module.__package__=module.__name__\n   if not hasattr(module,'__path__'):\n    module.__package__=spec.name.rpartition('.')[0]\n  except AttributeError:\n   pass\n if getattr(module,'__spec__',None )is None :\n  try :\n   module.__spec__=spec\n  except AttributeError:\n   pass\n return module\n \ndef _load_unlocked(spec):\n\n if spec.loader is not None :\n \n  if not hasattr(spec.loader,'exec_module'):\n   return _load_backward_compatible(spec)\n   \n module=module_from_spec(spec)\n with _installed_safely(module):\n  if spec.loader is None :\n   if spec.submodule_search_locations is None :\n    raise ImportError('missing loader',name=spec.name)\n    \n  else :\n   spec.loader.exec_module(module)\n   \n   \n   \n   \n return sys.modules[spec.name]\n \n \n \ndef _load(spec):\n ''\n\n\n\n\n\n\n \n with _ModuleLockManager(spec.name):\n  return _load_unlocked(spec)\n  \n  \n  \n  \nclass BuiltinImporter:\n\n ''\n\n\n\n\n \n \n @staticmethod\n def module_repr(module):\n  ''\n\n\n\n  \n  return '<module {!r} (built-in)>'.format(module.__name__)\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  if path is not None :\n   return None\n  if _imp.is_builtin(fullname):\n   return spec_from_loader(fullname,cls,origin='built-in')\n  else :\n   return None\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n\n\n  \n  spec=cls.find_spec(fullname,path)\n  return spec.loader if spec is not None else None\n  \n @classmethod\n def create_module(self,spec):\n  ''\n  if spec.name not in sys.builtin_module_names:\n   raise ImportError('{!r} is not a built-in module'.format(spec.name),\n   name=spec.name)\n  return _call_with_frames_removed(_imp.create_builtin,spec)\n  \n @classmethod\n def exec_module(self,module):\n  ''\n  _call_with_frames_removed(_imp.exec_builtin,module)\n  \n @classmethod\n @_requires_builtin\n def get_code(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_builtin\n def get_source(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_builtin\n def is_package(cls,fullname):\n  ''\n  return False\n  \n load_module=classmethod(_load_module_shim)\n \n \nclass FrozenImporter:\n\n ''\n\n\n\n\n \n \n @staticmethod\n def module_repr(m):\n  ''\n\n\n\n  \n  return '<module {!r} (frozen)>'.format(m.__name__)\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  if _imp.is_frozen(fullname):\n   return spec_from_loader(fullname,cls,origin='frozen')\n  else :\n   return None\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n  \n  return cls if _imp.is_frozen(fullname)else None\n  \n @classmethod\n def create_module(cls,spec):\n  ''\n  \n @staticmethod\n def exec_module(module):\n  name=module.__spec__.name\n  if not _imp.is_frozen(name):\n   raise ImportError('{!r} is not a frozen module'.format(name),\n   name=name)\n  code=_call_with_frames_removed(_imp.get_frozen_object,name)\n  exec(code,module.__dict__)\n  \n @classmethod\n def load_module(cls,fullname):\n  ''\n\n\n\n  \n  return _load_module_shim(cls,fullname)\n  \n @classmethod\n @_requires_frozen\n def get_code(cls,fullname):\n  ''\n  return _imp.get_frozen_object(fullname)\n  \n @classmethod\n @_requires_frozen\n def get_source(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_frozen\n def is_package(cls,fullname):\n  ''\n  return _imp.is_frozen_package(fullname)\n  \n  \n  \n  \nclass _ImportLockContext:\n\n ''\n \n def __enter__(self):\n  ''\n  _imp.acquire_lock()\n  \n def __exit__(self,exc_type,exc_value,exc_traceback):\n  ''\n  _imp.release_lock()\n  \n  \ndef _resolve_name(name,package,level):\n ''\n bits=package.rsplit('.',level -1)\n if len(bits)<level:\n  raise ValueError('attempted relative import beyond top-level package')\n base=bits[0]\n return '{}.{}'.format(base,name)if name else base\n \n \ndef _find_spec_legacy(finder,name,path):\n\n\n loader=finder.find_module(name,path)\n if loader is None :\n  return None\n return spec_from_loader(name,loader)\n \n \ndef _find_spec(name,path,target=None ):\n ''\n meta_path=sys.meta_path\n if meta_path is None :\n \n  raise ImportError(\"sys.meta_path is None, Python is likely \"\n  \"shutting down\")\n  \n if not meta_path:\n  _warnings.warn('sys.meta_path is empty',ImportWarning)\n  \n  \n  \n  \n is_reload=name in sys.modules\n for finder in meta_path:\n  with _ImportLockContext():\n   try :\n    find_spec=finder.find_spec\n   except AttributeError:\n    spec=_find_spec_legacy(finder,name,path)\n    if spec is None :\n     continue\n   else :\n    spec=find_spec(name,path,target)\n  if spec is not None :\n  \n   if not is_reload and name in sys.modules:\n    module=sys.modules[name]\n    try :\n     __spec__=module.__spec__\n    except AttributeError:\n    \n    \n    \n     return spec\n    else :\n     if __spec__ is None :\n      return spec\n     else :\n      return __spec__\n   else :\n    return spec\n else :\n  return None\n  \n  \ndef _sanity_check(name,package,level):\n ''\n if not isinstance(name,str):\n  raise TypeError('module name must be str, not {}'.format(type(name)))\n if level <0:\n  raise ValueError('level must be >= 0')\n if level >0:\n  if not isinstance(package,str):\n   raise TypeError('__package__ not set to a string')\n  elif not package:\n   raise ImportError('attempted relative import with no known parent '\n   'package')\n if not name and level ==0:\n  raise ValueError('Empty module name')\n  \n  \n_ERR_MSG_PREFIX='No module named '\n_ERR_MSG=_ERR_MSG_PREFIX+'{!r}'\n\ndef _find_and_load_unlocked(name,import_):\n path=None\n parent=name.rpartition('.')[0]\n if parent:\n  if parent not in sys.modules:\n   _call_with_frames_removed(import_,parent)\n   \n  if name in sys.modules:\n   return sys.modules[name]\n  parent_module=sys.modules[parent]\n  try :\n   path=parent_module.__path__\n  except AttributeError:\n   msg=(_ERR_MSG+'; {!r} is not a package').format(name,parent)\n   raise ModuleNotFoundError(msg,name=name)from None\n spec=_find_spec(name,path)\n if spec is None :\n  raise ModuleNotFoundError(_ERR_MSG.format(name),name=name)\n else :\n  module=_load_unlocked(spec)\n if parent:\n \n  parent_module=sys.modules[parent]\n  setattr(parent_module,name.rpartition('.')[2],module)\n return module\n \n \n_NEEDS_LOADING=object()\n\n\ndef _find_and_load(name,import_):\n ''\n with _ModuleLockManager(name):\n  module=sys.modules.get(name,_NEEDS_LOADING)\n  if module is _NEEDS_LOADING:\n   return _find_and_load_unlocked(name,import_)\n   \n if module is None :\n  message=('import of {} halted; '\n  'None in sys.modules'.format(name))\n  raise ModuleNotFoundError(message,name=name)\n  \n _lock_unlock_module(name)\n return module\n \n \ndef _gcd_import(name,package=None ,level=0):\n ''\n\n\n\n\n\n\n \n _sanity_check(name,package,level)\n if level >0:\n  name=_resolve_name(name,package,level)\n return _find_and_load(name,_gcd_import)\n \n \ndef _handle_fromlist(module,fromlist,import_,*,recursive=False ):\n ''\n\n\n\n\n\n \n \n \n if hasattr(module,'__path__'):\n  for x in fromlist:\n   if not isinstance(x,str):\n    if recursive:\n     where=module.__name__+'.__all__'\n    else :\n     where=\"``from list''\"\n    raise TypeError(f\"Item in {where} must be str, \"\n    f\"not {type(x).__name__}\")\n   elif x =='*':\n    if not recursive and hasattr(module,'__all__'):\n     _handle_fromlist(module,module.__all__,import_,\n     recursive=True )\n   elif not hasattr(module,x):\n    from_name='{}.{}'.format(module.__name__,x)\n    try :\n     _call_with_frames_removed(import_,from_name)\n    except ModuleNotFoundError as exc:\n    \n    \n    \n     if (exc.name ==from_name and\n     sys.modules.get(from_name,_NEEDS_LOADING)is not None ):\n      continue\n     raise\n return module\n \n \ndef _calc___package__(globals):\n ''\n\n\n\n\n \n package=globals.get('__package__')\n spec=globals.get('__spec__')\n if package is not None :\n  if spec is not None and package !=spec.parent:\n   _warnings.warn(\"__package__ != __spec__.parent \"\n   f\"({package!r} != {spec.parent!r})\",\n   ImportWarning,stacklevel=3)\n  return package\n elif spec is not None :\n  return spec.parent\n else :\n  _warnings.warn(\"can't resolve package from __spec__ or __package__, \"\n  \"falling back on __name__ and __path__\",\n  ImportWarning,stacklevel=3)\n  package=globals['__name__']\n  if '__path__'not in globals:\n   package=package.rpartition('.')[0]\n return package\n \n \ndef __import__(name,globals=None ,locals=None ,fromlist=(),level=0):\n ''\n\n\n\n\n\n\n\n\n \n if level ==0:\n  module=_gcd_import(name)\n else :\n  globals_=globals if globals is not None else {}\n  package=_calc___package__(globals_)\n  module=_gcd_import(name,package,level)\n if not fromlist:\n \n \n  if level ==0:\n   return _gcd_import(name.partition('.')[0])\n  elif not name:\n   return module\n  else :\n  \n  \n   cut_off=len(name)-len(name.partition('.')[0])\n   \n   \n   return sys.modules[module.__name__[:len(module.__name__)-cut_off]]\n else :\n  return _handle_fromlist(module,fromlist,_gcd_import)\n  \n  \ndef _builtin_from_name(name):\n spec=BuiltinImporter.find_spec(name)\n if spec is None :\n  raise ImportError('no built-in module named '+name)\n return _load_unlocked(spec)\n \n \nmodule_type=type(sys)\nfor name,module in sys.modules.items():\n if isinstance(module,module_type):\n  if name in sys.builtin_module_names:\n   loader=BuiltinImporter\n  elif _imp.is_frozen(name):\n   loader=FrozenImporter\n  else :\n   continue\n  spec=_spec_from_module(module,loader)\n  _init_module_attrs(spec,module)\n  \n  \nself_module=sys.modules[__name__]\n\n\nfor builtin_name in ('_warnings',):\n if builtin_name not in sys.modules:\n  builtin_module=_builtin_from_name(builtin_name)\n else :\n  builtin_module=sys.modules[builtin_name]\n setattr(self_module,builtin_name,builtin_module)\n \n \ndef _install(sys_module,_imp_module):\n ''\n _setup(sys_module,_imp_module)\n \n sys.meta_path.append(BuiltinImporter)\n sys.meta_path.append(FrozenImporter)\n \n \ndef _install_external_importers():\n ''\n global _bootstrap_external\n import _frozen_importlib_external\n _bootstrap_external=_frozen_importlib_external\n _frozen_importlib_external._install(sys.modules[__name__])\n \n", ["_frozen_importlib_external", "_imp", "_weakref", "sys"]], "enum": [".py", "import sys\nfrom types import MappingProxyType,DynamicClassAttribute\n\n\n__all__=[\n'EnumMeta',\n'Enum','IntEnum','Flag','IntFlag',\n'auto','unique',\n]\n\n\ndef _is_descriptor(obj):\n ''\n return (\n hasattr(obj,'__get__')or\n hasattr(obj,'__set__')or\n hasattr(obj,'__delete__'))\n \n \ndef _is_dunder(name):\n ''\n return (len(name)>4 and\n name[:2]==name[-2:]=='__'and\n name[2]!='_'and\n name[-3]!='_')\n \n \ndef _is_sunder(name):\n ''\n return (len(name)>2 and\n name[0]==name[-1]=='_'and\n name[1:2]!='_'and\n name[-2:-1]!='_')\n \n \ndef _make_class_unpicklable(cls):\n ''\n def _break_on_call_reduce(self,proto):\n  raise TypeError('%r cannot be pickled'%self)\n cls.__reduce_ex__=_break_on_call_reduce\n cls.__module__='<unknown>'\n \n_auto_null=object()\nclass auto:\n ''\n\n \n value=_auto_null\n \n \nclass _EnumDict(dict):\n ''\n\n\n\n\n \n def __init__(self):\n  super().__init__()\n  self._member_names=[]\n  self._last_values=[]\n  self._ignore=[]\n  \n def __setitem__(self,key,value):\n  ''\n\n\n\n\n\n\n  \n  if _is_sunder(key):\n   if key not in (\n   '_order_','_create_pseudo_member_',\n   '_generate_next_value_','_missing_','_ignore_',\n   ):\n    raise ValueError('_names_ are reserved for future Enum use')\n   if key =='_generate_next_value_':\n    setattr(self,'_generate_next_value',value)\n   elif key =='_ignore_':\n    if isinstance(value,str):\n     value=value.replace(',',' ').split()\n    else :\n     value=list(value)\n    self._ignore=value\n    already=set(value)&set(self._member_names)\n    if already:\n     raise ValueError('_ignore_ cannot specify already set names: %r'%(already,))\n  elif _is_dunder(key):\n   if key =='__order__':\n    key='_order_'\n  elif key in self._member_names:\n  \n   raise TypeError('Attempted to reuse key: %r'%key)\n  elif key in self._ignore:\n   pass\n  elif not _is_descriptor(value):\n   if key in self:\n   \n    raise TypeError('%r already defined as: %r'%(key,self[key]))\n   if isinstance(value,auto):\n    if value.value ==_auto_null:\n     value.value=self._generate_next_value(key,1,len(self._member_names),self._last_values[:])\n    value=value.value\n   self._member_names.append(key)\n   self._last_values.append(value)\n  super().__setitem__(key,value)\n  \n  \n  \n  \n  \nEnum=None\n\n\nclass EnumMeta(type):\n ''\n @classmethod\n def __prepare__(metacls,cls,bases):\n \n  enum_dict=_EnumDict()\n  \n  member_type,first_enum=metacls._get_mixins_(bases)\n  if first_enum is not None :\n   enum_dict['_generate_next_value_']=getattr(first_enum,'_generate_next_value_',None )\n  return enum_dict\n  \n def __new__(metacls,cls,bases,classdict):\n \n \n \n \n \n \n  classdict.setdefault('_ignore_',[]).append('_ignore_')\n  ignore=classdict['_ignore_']\n  for key in ignore:\n   classdict.pop(key,None )\n  member_type,first_enum=metacls._get_mixins_(bases)\n  __new__,save_new,use_args=metacls._find_new_(classdict,member_type,\n  first_enum)\n  \n  \n  \n  enum_members={k:classdict[k]for k in classdict._member_names}\n  for name in classdict._member_names:\n   del classdict[name]\n   \n   \n  _order_=classdict.pop('_order_',None )\n  \n  \n  invalid_names=set(enum_members)&{'mro',''}\n  if invalid_names:\n   raise ValueError('Invalid enum member name: {0}'.format(\n   ','.join(invalid_names)))\n   \n   \n  if '__doc__'not in classdict:\n   classdict['__doc__']='An enumeration.'\n   \n   \n  enum_class=super().__new__(metacls,cls,bases,classdict)\n  enum_class._member_names_=[]\n  enum_class._member_map_={}\n  enum_class._member_type_=member_type\n  \n  \n  \n  dynamic_attributes={k for c in enum_class.mro()\n  for k,v in c.__dict__.items()\n  if isinstance(v,DynamicClassAttribute)}\n  \n  \n  enum_class._value2member_map_={}\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if '__reduce_ex__'not in classdict:\n   if member_type is not object:\n    methods=('__getnewargs_ex__','__getnewargs__',\n    '__reduce_ex__','__reduce__')\n    if not any(m in member_type.__dict__ for m in methods):\n     _make_class_unpicklable(enum_class)\n     \n     \n     \n     \n     \n  for member_name in classdict._member_names:\n   value=enum_members[member_name]\n   if not isinstance(value,tuple):\n    args=(value,)\n   else :\n    args=value\n   if member_type is tuple:\n    args=(args,)\n   if not use_args:\n    enum_member=__new__(enum_class)\n    if not hasattr(enum_member,'_value_'):\n     enum_member._value_=value\n   else :\n    enum_member=__new__(enum_class,*args)\n    if not hasattr(enum_member,'_value_'):\n     if member_type is object:\n      enum_member._value_=value\n     else :\n      enum_member._value_=member_type(*args)\n   value=enum_member._value_\n   enum_member._name_=member_name\n   enum_member.__objclass__=enum_class\n   enum_member.__init__(*args)\n   \n   \n   for name,canonical_member in enum_class._member_map_.items():\n    if canonical_member._value_ ==enum_member._value_:\n     enum_member=canonical_member\n     break\n   else :\n   \n    enum_class._member_names_.append(member_name)\n    \n    \n   if member_name not in dynamic_attributes:\n    setattr(enum_class,member_name,enum_member)\n    \n   enum_class._member_map_[member_name]=enum_member\n   try :\n   \n   \n   \n    enum_class._value2member_map_[value]=enum_member\n   except TypeError:\n    pass\n    \n    \n    \n  for name in ('__repr__','__str__','__format__','__reduce_ex__'):\n   class_method=getattr(enum_class,name)\n   obj_method=getattr(member_type,name,None )\n   enum_method=getattr(first_enum,name,None )\n   if obj_method is not None and obj_method is class_method:\n    setattr(enum_class,name,enum_method)\n    \n    \n    \n  if Enum is not None :\n  \n  \n   if save_new:\n    enum_class.__new_member__=__new__\n   enum_class.__new__=Enum.__new__\n   \n   \n  if _order_ is not None :\n   if isinstance(_order_,str):\n    _order_=_order_.replace(',',' ').split()\n   if _order_ !=enum_class._member_names_:\n    raise TypeError('member order does not match _order_')\n    \n  return enum_class\n  \n def __bool__(self):\n  ''\n\n  \n  return True\n  \n def __call__(cls,value,names=None ,*,module=None ,qualname=None ,type=None ,start=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if names is None :\n   return cls.__new__(cls,value)\n   \n  return cls._create_(value,names,module=module,qualname=qualname,type=type,start=start)\n  \n def __contains__(cls,member):\n  if not isinstance(member,Enum):\n   raise TypeError(\n   \"unsupported operand type(s) for 'in': '%s' and '%s'\"%(\n   type(member).__qualname__,cls.__class__.__qualname__))\n  return isinstance(member,cls)and member._name_ in cls._member_map_\n  \n def __delattr__(cls,attr):\n \n \n  if attr in cls._member_map_:\n   raise AttributeError(\n   \"%s: cannot delete Enum member.\"%cls.__name__)\n  super().__delattr__(attr)\n  \n def __dir__(self):\n  return (['__class__','__doc__','__members__','__module__']+\n  self._member_names_)\n  \n def __getattr__(cls,name):\n  ''\n\n\n\n\n\n\n  \n  if _is_dunder(name):\n   raise AttributeError(name)\n  try :\n   return cls._member_map_[name]\n  except KeyError:\n   raise AttributeError(name)from None\n   \n def __getitem__(cls,name):\n  return cls._member_map_[name]\n  \n def __iter__(cls):\n  return (cls._member_map_[name]for name in cls._member_names_)\n  \n def __len__(cls):\n  return len(cls._member_names_)\n  \n @property\n def __members__(cls):\n  ''\n\n\n\n\n  \n  return MappingProxyType(cls._member_map_)\n  \n def __repr__(cls):\n  return \"<enum %r>\"%cls.__name__\n  \n def __reversed__(cls):\n  return (cls._member_map_[name]for name in reversed(cls._member_names_))\n  \n def __setattr__(cls,name,value):\n  ''\n\n\n\n\n\n  \n  member_map=cls.__dict__.get('_member_map_',{})\n  if name in member_map:\n   raise AttributeError('Cannot reassign members.')\n  super().__setattr__(name,value)\n  \n def _create_(cls,class_name,names,*,module=None ,qualname=None ,type=None ,start=1):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  metacls=cls.__class__\n  bases=(cls,)if type is None else (type,cls)\n  _,first_enum=cls._get_mixins_(bases)\n  classdict=metacls.__prepare__(class_name,bases)\n  \n  \n  if isinstance(names,str):\n   names=names.replace(',',' ').split()\n  if isinstance(names,(tuple,list))and names and isinstance(names[0],str):\n   original_names,names=names,[]\n   last_values=[]\n   for count,name in enumerate(original_names):\n    value=first_enum._generate_next_value_(name,start,count,last_values[:])\n    last_values.append(value)\n    names.append((name,value))\n    \n    \n  for item in names:\n   if isinstance(item,str):\n    member_name,member_value=item,names[item]\n   else :\n    member_name,member_value=item\n   classdict[member_name]=member_value\n  enum_class=metacls.__new__(metacls,class_name,bases,classdict)\n  \n  \n  \n  if module is None :\n   try :\n    module=sys._getframe(2).f_globals['__name__']\n   except (AttributeError,ValueError,KeyError)as exc:\n    pass\n  if module is None :\n   _make_class_unpicklable(enum_class)\n  else :\n   enum_class.__module__=module\n  if qualname is not None :\n   enum_class.__qualname__=qualname\n   \n  return enum_class\n  \n def _convert_(cls,name,module,filter,source=None ):\n  ''\n\n  \n  \n  \n  \n  \n  \n  module_globals=vars(sys.modules[module])\n  if source:\n   source=vars(source)\n  else :\n   source=module_globals\n   \n   \n   \n  members=[\n  (name,value)\n  for name,value in source.items()\n  if filter(name)]\n  try :\n  \n   members.sort(key=lambda t:(t[1],t[0]))\n  except TypeError:\n  \n   members.sort(key=lambda t:t[0])\n  cls=cls(name,members,module=module)\n  cls.__reduce_ex__=_reduce_ex_by_name\n  module_globals.update(cls.__members__)\n  module_globals[name]=cls\n  return cls\n  \n def _convert(cls,*args,**kwargs):\n  import warnings\n  warnings.warn(\"_convert is deprecated and will be removed in 3.9, use \"\n  \"_convert_ instead.\",DeprecationWarning,stacklevel=2)\n  return cls._convert_(*args,**kwargs)\n  \n @staticmethod\n def _get_mixins_(bases):\n  ''\n\n\n\n\n  \n  if not bases:\n   return object,Enum\n   \n  def _find_data_type(bases):\n   for chain in bases:\n    for base in chain.__mro__:\n     if base is object:\n      continue\n     elif '__new__'in base.__dict__:\n      if issubclass(base,Enum):\n       continue\n      return base\n      \n      \n      \n  first_enum=bases[-1]\n  if not issubclass(first_enum,Enum):\n   raise TypeError(\"new enumerations should be created as \"\n   \"`EnumName([mixin_type, ...] [data_type,] enum_type)`\")\n  member_type=_find_data_type(bases)or object\n  if first_enum._member_names_:\n   raise TypeError(\"Cannot extend enumerations\")\n  return member_type,first_enum\n  \n @staticmethod\n def _find_new_(classdict,member_type,first_enum):\n  ''\n\n\n\n\n\n  \n  \n  \n  \n  __new__=classdict.get('__new__',None )\n  \n  \n  save_new=__new__ is not None\n  \n  if __new__ is None :\n  \n  \n   for method in ('__new_member__','__new__'):\n    for possible in (member_type,first_enum):\n     target=getattr(possible,method,None )\n     if target not in {\n     None ,\n     None .__new__,\n     object.__new__,\n     Enum.__new__,\n     }:\n      __new__=target\n      break\n    if __new__ is not None :\n     break\n   else :\n    __new__=object.__new__\n    \n    \n    \n    \n  if __new__ is object.__new__:\n   use_args=False\n  else :\n   use_args=True\n  return __new__,save_new,use_args\n  \n  \nclass Enum(metaclass=EnumMeta):\n ''\n\n\n\n \n def __new__(cls,value):\n \n \n \n  if type(value)is cls:\n  \n   return value\n   \n   \n  try :\n   return cls._value2member_map_[value]\n  except KeyError:\n  \n   pass\n  except TypeError:\n  \n   for member in cls._member_map_.values():\n    if member._value_ ==value:\n     return member\n     \n  try :\n   exc=None\n   result=cls._missing_(value)\n  except Exception as e:\n   exc=e\n   result=None\n  if isinstance(result,cls):\n   return result\n  else :\n   ve_exc=ValueError(\"%r is not a valid %s\"%(value,cls.__name__))\n   if result is None and exc is None :\n    raise ve_exc\n   elif exc is None :\n    exc=TypeError(\n    'error in %s._missing_: returned %r instead of None or a valid member'\n    %(cls.__name__,result)\n    )\n   exc.__context__=ve_exc\n   raise exc\n   \n def _generate_next_value_(name,start,count,last_values):\n  for last_value in reversed(last_values):\n   try :\n    return last_value+1\n   except TypeError:\n    pass\n  else :\n   return start\n   \n @classmethod\n def _missing_(cls,value):\n  raise ValueError(\"%r is not a valid %s\"%(value,cls.__name__))\n  \n def __repr__(self):\n  return \"<%s.%s: %r>\"%(\n  self.__class__.__name__,self._name_,self._value_)\n  \n def __str__(self):\n  return \"%s.%s\"%(self.__class__.__name__,self._name_)\n  \n def __dir__(self):\n  added_behavior=[\n  m\n  for cls in self.__class__.mro()\n  for m in cls.__dict__\n  if m[0]!='_'and m not in self._member_map_\n  ]\n  return (['__class__','__doc__','__module__']+added_behavior)\n  \n def __format__(self,format_spec):\n \n \n \n \n \n  if self._member_type_ is object:\n   cls=str\n   val=str(self)\n   \n  else :\n   cls=self._member_type_\n   val=self._value_\n  return cls.__format__(val,format_spec)\n  \n def __hash__(self):\n  return hash(self._name_)\n  \n def __reduce_ex__(self,proto):\n  return self.__class__,(self._value_,)\n  \n  \n  \n  \n  \n  \n  \n  \n @DynamicClassAttribute\n def name(self):\n  ''\n  return self._name_\n  \n @DynamicClassAttribute\n def value(self):\n  ''\n  return self._value_\n  \n  \nclass IntEnum(int,Enum):\n ''\n \n \ndef _reduce_ex_by_name(self,proto):\n return self.name\n \nclass Flag(Enum):\n ''\n \n def _generate_next_value_(name,start,count,last_values):\n  ''\n\n\n\n\n\n\n  \n  if not count:\n   return start if start is not None else 1\n  for last_value in reversed(last_values):\n   try :\n    high_bit=_high_bit(last_value)\n    break\n   except Exception:\n    raise TypeError('Invalid Flag value: %r'%last_value)from None\n  return 2 **(high_bit+1)\n  \n @classmethod\n def _missing_(cls,value):\n  original_value=value\n  if value <0:\n   value=~value\n  possible_member=cls._create_pseudo_member_(value)\n  if original_value <0:\n   possible_member=~possible_member\n  return possible_member\n  \n @classmethod\n def _create_pseudo_member_(cls,value):\n  ''\n\n  \n  pseudo_member=cls._value2member_map_.get(value,None )\n  if pseudo_member is None :\n  \n   _,extra_flags=_decompose(cls,value)\n   if extra_flags:\n    raise ValueError(\"%r is not a valid %s\"%(value,cls.__name__))\n    \n   pseudo_member=object.__new__(cls)\n   pseudo_member._name_=None\n   pseudo_member._value_=value\n   \n   \n   pseudo_member=cls._value2member_map_.setdefault(value,pseudo_member)\n  return pseudo_member\n  \n def __contains__(self,other):\n  if not isinstance(other,self.__class__):\n   raise TypeError(\n   \"unsupported operand type(s) for 'in': '%s' and '%s'\"%(\n   type(other).__qualname__,self.__class__.__qualname__))\n  return other._value_&self._value_ ==other._value_\n  \n def __repr__(self):\n  cls=self.__class__\n  if self._name_ is not None :\n   return '<%s.%s: %r>'%(cls.__name__,self._name_,self._value_)\n  members,uncovered=_decompose(cls,self._value_)\n  return '<%s.%s: %r>'%(\n  cls.__name__,\n  '|'.join([str(m._name_ or m._value_)for m in members]),\n  self._value_,\n  )\n  \n def __str__(self):\n  cls=self.__class__\n  if self._name_ is not None :\n   return '%s.%s'%(cls.__name__,self._name_)\n  members,uncovered=_decompose(cls,self._value_)\n  if len(members)==1 and members[0]._name_ is None :\n   return '%s.%r'%(cls.__name__,members[0]._value_)\n  else :\n   return '%s.%s'%(\n   cls.__name__,\n   '|'.join([str(m._name_ or m._value_)for m in members]),\n   )\n   \n def __bool__(self):\n  return bool(self._value_)\n  \n def __or__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.__class__(self._value_ |other._value_)\n  \n def __and__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.__class__(self._value_&other._value_)\n  \n def __xor__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.__class__(self._value_ ^other._value_)\n  \n def __invert__(self):\n  members,uncovered=_decompose(self.__class__,self._value_)\n  inverted=self.__class__(0)\n  for m in self.__class__:\n   if m not in members and not (m._value_&self._value_):\n    inverted=inverted |m\n  return self.__class__(inverted)\n  \n  \nclass IntFlag(int,Flag):\n ''\n \n @classmethod\n def _missing_(cls,value):\n  if not isinstance(value,int):\n   raise ValueError(\"%r is not a valid %s\"%(value,cls.__name__))\n  new_member=cls._create_pseudo_member_(value)\n  return new_member\n  \n @classmethod\n def _create_pseudo_member_(cls,value):\n  pseudo_member=cls._value2member_map_.get(value,None )\n  if pseudo_member is None :\n   need_to_create=[value]\n   \n   _,extra_flags=_decompose(cls,value)\n   \n   while extra_flags:\n   \n    bit=_high_bit(extra_flags)\n    flag_value=2 **bit\n    if (flag_value not in cls._value2member_map_ and\n    flag_value not in need_to_create\n    ):\n     need_to_create.append(flag_value)\n    if extra_flags ==-flag_value:\n     extra_flags=0\n    else :\n     extra_flags ^=flag_value\n   for value in reversed(need_to_create):\n   \n    pseudo_member=int.__new__(cls,value)\n    pseudo_member._name_=None\n    pseudo_member._value_=value\n    \n    \n    pseudo_member=cls._value2member_map_.setdefault(value,pseudo_member)\n  return pseudo_member\n  \n def __or__(self,other):\n  if not isinstance(other,(self.__class__,int)):\n   return NotImplemented\n  result=self.__class__(self._value_ |self.__class__(other)._value_)\n  return result\n  \n def __and__(self,other):\n  if not isinstance(other,(self.__class__,int)):\n   return NotImplemented\n  return self.__class__(self._value_&self.__class__(other)._value_)\n  \n def __xor__(self,other):\n  if not isinstance(other,(self.__class__,int)):\n   return NotImplemented\n  return self.__class__(self._value_ ^self.__class__(other)._value_)\n  \n __ror__=__or__\n __rand__=__and__\n __rxor__=__xor__\n \n def __invert__(self):\n  result=self.__class__(~self._value_)\n  return result\n  \n  \ndef _high_bit(value):\n ''\n return value.bit_length()-1\n \ndef unique(enumeration):\n ''\n duplicates=[]\n for name,member in enumeration.__members__.items():\n  if name !=member.name:\n   duplicates.append((name,member.name))\n if duplicates:\n  alias_details=', '.join(\n  [\"%s -> %s\"%(alias,name)for (alias,name)in duplicates])\n  raise ValueError('duplicate values found in %r: %s'%\n  (enumeration,alias_details))\n return enumeration\n \ndef _decompose(flag,value):\n ''\n \n not_covered=value\n negative=value <0\n \n \n \n if negative:\n \n  flags_to_check=[\n  (m,v)\n  for v,m in list(flag._value2member_map_.items())\n  if m.name is not None\n  ]\n else :\n \n  flags_to_check=[\n  (m,v)\n  for v,m in list(flag._value2member_map_.items())\n  if m.name is not None or _power_of_two(v)\n  ]\n members=[]\n for member,member_value in flags_to_check:\n  if member_value and member_value&value ==member_value:\n   members.append(member)\n   not_covered &=~member_value\n if not members and value in flag._value2member_map_:\n  members.append(flag._value2member_map_[value])\n members.sort(key=lambda m:m._value_,reverse=True )\n if len(members)>1 and members[0].value ==value:\n \n  members.pop(0)\n return members,not_covered\n \ndef _power_of_two(value):\n if value <1:\n  return False\n return value ==2 **_high_bit(value)\n", ["sys", "types", "warnings"]], "_struct": [".py", "\n\n\n\n\n\n\n\n\n\n\n\"\"\"Functions to convert between Python values and C structs.\nPython strings are used to hold the data representing the C struct\nand also as format strings to describe the layout of data in the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n @: native order, size & alignment (default)\n =: native order, std. size & alignment\n <: little-endian, std. size & alignment\n >: big-endian, std. size & alignment\n !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n   x: pad byte (no data);\n   c:char;\n   b:signed byte;\n   B:unsigned byte;\n   h:short;\n   H:unsigned short;\n   i:int;\n   I:unsigned int;\n   l:long;\n   L:unsigned long;\n   f:float;\n   d:double.\nSpecial cases (preceding decimal count indicates length):\n   s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n   P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n   q:long long;\n   Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.\"\"\"\n\nimport math\nimport re\nimport sys\n\n\nclass StructError(Exception):\n pass\n \n \nerror=StructError\n\ndef _normalize(fmt):\n ''\n \n if re.search(r\"\\d\\s+\",fmt):\n  raise StructError(\"bad char in struct format\")\n return fmt.replace(\" \",\"\")\n \ndef unpack_int(data,index,size,le):\n bytes=[b for b in data[index:index+size]]\n if le =='little':\n  bytes.reverse()\n number=0\n for b in bytes:\n  number=number <<8 |b\n return int(number)\n \ndef unpack_signed_int(data,index,size,le):\n number=unpack_int(data,index,size,le)\n max=2 **(size *8)\n if number >2 **(size *8 -1)-1:\n  number=int(-1 *(max -number))\n return number\n \nINFINITY=1e200 *1e200\nNAN=INFINITY /INFINITY\n\ndef unpack_char(data,index,size,le):\n return data[index:index+size]\n \ndef pack_int(number,size,le):\n x=number\n res=[]\n for i in range(size):\n  res.append(x&0xff)\n  x >>=8\n if le =='big':\n  res.reverse()\n return bytes(res)\n \ndef pack_signed_int(number,size,le):\n if not isinstance(number,int):\n  raise StructError(\"argument for i,I,l,L,q,Q,h,H must be integer\")\n if number >2 **(8 *size -1)-1 or number <-1 *2 **(8 *size -1):\n  raise OverflowError(\"Number:%i too large to convert\"%number)\n return pack_int(number,size,le)\n \ndef pack_unsigned_int(number,size,le):\n if not isinstance(number,int):\n  raise StructError(\"argument for i,I,l,L,q,Q,h,H must be integer\")\n if number <0:\n  raise TypeError(\"can't convert negative long to unsigned\")\n if number >2 **(8 *size)-1:\n  raise OverflowError(\"Number:%i too large to convert\"%number)\n return pack_int(number,size,le)\n \ndef pack_char(char,size,le):\n return bytes(char)\n \ndef isinf(x):\n return x !=0.0 and x /2 ==x\n \ndef isnan(v):\n return v !=v *1.0 or (v ==1.0 and v ==2.0)\n \ndef pack_float(x,size,le):\n unsigned=float_pack(x,size)\n result=[]\n for i in range(size):\n  result.append((unsigned >>(i *8))&0xFF)\n if le ==\"big\":\n  result.reverse()\n return bytes(result)\n \ndef unpack_float(data,index,size,le):\n binary=[data[i]for i in range(index,index+size)]\n if le ==\"big\":\n  binary.reverse()\n unsigned=0\n for i in range(size):\n  unsigned |=binary[i]<<(i *8)\n return float_unpack(unsigned,size,le)\n \ndef round_to_nearest(x):\n ''\n\n\n\n\n\n\n\n\n \n int_part=int(x)\n frac_part=x -int_part\n if frac_part >0.5 or frac_part ==0.5 and int_part&1 ==1:\n  int_part +=1\n return int_part\n \ndef float_unpack(Q,size,le):\n ''\n \n \n if size ==8:\n  MIN_EXP=-1021\n  MAX_EXP=1024\n  MANT_DIG=53\n  BITS=64\n elif size ==4:\n  MIN_EXP=-125\n  MAX_EXP=128\n  MANT_DIG=24\n  BITS=32\n else :\n  raise ValueError(\"invalid size value\")\n  \n if Q >>BITS:\n  raise ValueError(\"input out of range\")\n  \n  \n sign=Q >>BITS -1\n exp=(Q&((1 <<BITS -1)-(1 <<MANT_DIG -1)))>>MANT_DIG -1\n mant=Q&((1 <<MANT_DIG -1)-1)\n \n if exp ==MAX_EXP -MIN_EXP+2:\n \n  result=float('nan')if mant else float('inf')\n elif exp ==0:\n \n  result=math.ldexp(float(mant),MIN_EXP -MANT_DIG)\n else :\n \n  mant +=1 <<MANT_DIG -1\n  result=math.ldexp(float(mant),exp+MIN_EXP -MANT_DIG -1)\n return -result if sign else result\n \n \ndef float_pack(x,size):\n ''\n \n \n if size ==8:\n  MIN_EXP=-1021\n  MAX_EXP=1024\n  MANT_DIG=53\n  BITS=64\n elif size ==4:\n  MIN_EXP=-125\n  MAX_EXP=128\n  MANT_DIG=24\n  BITS=32\n else :\n  raise ValueError(\"invalid size value\")\n  \n sign=math.copysign(1.0,x)<0.0\n if math.isinf(x):\n  mant=0\n  exp=MAX_EXP -MIN_EXP+2\n elif math.isnan(x):\n  mant=1 <<(MANT_DIG -2)\n  exp=MAX_EXP -MIN_EXP+2\n elif x ==0.0:\n  mant=0\n  exp=0\n else :\n  m,e=math.frexp(abs(x))\n  exp=e -(MIN_EXP -1)\n  if exp >0:\n  \n   mant=round_to_nearest(m *(1 <<MANT_DIG))\n   mant -=1 <<MANT_DIG -1\n  else :\n  \n   if exp+MANT_DIG -1 >=0:\n    mant=round_to_nearest(m *(1 <<exp+MANT_DIG -1))\n   else :\n    mant=0\n   exp=0\n   \n   \n  assert 0 <=mant <=1 <<MANT_DIG -1\n  if mant ==1 <<MANT_DIG -1:\n   mant=0\n   exp +=1\n   \n   \n   \n  if exp >=MAX_EXP -MIN_EXP+2:\n   raise OverflowError(\"float too large to pack in this format\")\n   \n   \n assert 0 <=mant <1 <<MANT_DIG -1\n assert 0 <=exp <=MAX_EXP -MIN_EXP+2\n assert 0 <=sign <=1\n return ((sign <<BITS -1)|(exp <<MANT_DIG -1))|mant\n \n \nbig_endian_format={\n'x':{'size':1,'alignment':0,'pack':None ,'unpack':None },\n'b':{'size':1,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'B':{'size':1,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'c':{'size':1,'alignment':0,'pack':pack_char,'unpack':unpack_char},\n's':{'size':1,'alignment':0,'pack':None ,'unpack':None },\n'p':{'size':1,'alignment':0,'pack':None ,'unpack':None },\n'h':{'size':2,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'H':{'size':2,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'i':{'size':4,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'I':{'size':4,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'l':{'size':4,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'L':{'size':4,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'q':{'size':8,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'Q':{'size':8,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'f':{'size':4,'alignment':0,'pack':pack_float,'unpack':unpack_float},\n'd':{'size':8,'alignment':0,'pack':pack_float,'unpack':unpack_float},\n'P':{'size':8,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int}\n}\n\ndefault=big_endian_format\n\nformatmode={'<':(default,'little'),\n'>':(default,'big'),\n'!':(default,'big'),\n'=':(default,sys.byteorder),\n'@':(default,sys.byteorder)\n}\n\ndef _getmode(fmt):\n try :\n  formatdef,endianness=formatmode[fmt[0]]\n  alignment=fmt[0]not in formatmode or fmt[0]=='@'\n  index=1\n except (IndexError,KeyError):\n  formatdef,endianness=formatmode['@']\n  alignment=True\n  index=0\n return formatdef,endianness,index,alignment\n \ndef _getnum(fmt,i):\n num=None\n cur=fmt[i]\n while ('0'<=cur)and (cur <='9'):\n  if num ==None :\n   num=int(cur)\n  else :\n   num=10 *num+int(cur)\n  i +=1\n  cur=fmt[i]\n return num,i\n \ndef calcsize(fmt):\n ''\n\n \n if isinstance(fmt,bytes):\n  fmt=fmt.decode(\"ascii\")\n  \n fmt=_normalize(fmt)\n \n formatdef,endianness,i,alignment=_getmode(fmt)\n num=0\n result=0\n while i <len(fmt):\n  num,i=_getnum(fmt,i)\n  cur=fmt[i]\n  try :\n   format=formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\"%cur)\n  if num !=None :\n   result +=num *format['size']\n  else :\n  \n  \n   if alignment and result:\n    result +=format['size']-result %format['size']\n   result +=format['size']\n  num=0\n  i +=1\n return result\n \ndef pack(fmt,*args):\n ''\n\n \n fmt=_normalize(fmt)\n formatdef,endianness,i,alignment=_getmode(fmt)\n args=list(args)\n n_args=len(args)\n result=[]\n while i <len(fmt):\n  num,i=_getnum(fmt,i)\n  cur=fmt[i]\n  try :\n   format=formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\"%cur)\n  if num ==None :\n   num_s=0\n   num=1\n  else :\n   num_s=num\n   \n  if cur =='x':\n   result +=[b'\\0'*num]\n  elif cur =='s':\n   if isinstance(args[0],bytes):\n    padding=num -len(args[0])\n    result +=[args[0][:num]+b'\\0'*padding]\n    args.pop(0)\n   else :\n    raise StructError(\"arg for string format not a string\")\n  elif cur =='p':\n   if isinstance(args[0],bytes):\n    padding=num -len(args[0])-1\n    \n    if padding >0:\n     result +=[bytes([len(args[0])])+args[0][:num -1]+\n     b'\\0'*padding]\n    else :\n     if num <255:\n      result +=[bytes([num -1])+args[0][:num -1]]\n     else :\n      result +=[bytes([255])+args[0][:num -1]]\n    args.pop(0)\n   else :\n    raise StructError(\"arg for string format not a string\")\n    \n  else :\n   if len(args)<num:\n    raise StructError(\"insufficient arguments to pack\")\n   for var in args[:num]:\n   \n    if len(result)and alignment:\n     padding=format['size']-len(result)%format['size']\n     result +=[bytes([0])]*padding\n    result +=[format['pack'](var,format['size'],endianness)]\n   args=args[num:]\n  num=None\n  i +=1\n if len(args)!=0:\n  raise StructError(\"too many arguments for pack format\")\n return b''.join(result)\n \ndef unpack(fmt,data):\n ''\n\n\n \n fmt=_normalize(fmt)\n formatdef,endianness,i,alignment=_getmode(fmt)\n j=0\n num=0\n result=[]\n length=calcsize(fmt)\n if length !=len(data):\n  raise StructError(\"unpack str size does not match format\")\n while i <len(fmt):\n  num,i=_getnum(fmt,i)\n  cur=fmt[i]\n  i +=1\n  try :\n   format=formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\"%cur)\n   \n  if not num:\n   num=1\n   \n  if cur =='x':\n   j +=num\n  elif cur =='s':\n   result.append(data[j:j+num])\n   j +=num\n  elif cur =='p':\n   n=data[j]\n   if n >=num:\n    n=num -1\n   result.append(data[j+1:j+n+1])\n   j +=num\n  else :\n  \n   if j >0 and alignment:\n    padding=format['size']-j %format['size']\n    j +=padding\n   for n in range(num):\n    result +=[format['unpack'](data,j,format['size'],\n    endianness)]\n    j +=format['size']\n    \n return tuple(result)\n \ndef pack_into(fmt,buf,offset,*args):\n data=pack(fmt,*args)\n buf[offset:offset+len(data)]=data\n \ndef unpack_from(fmt,buf,offset=0):\n size=calcsize(fmt)\n data=buf[offset:offset+size]\n if len(data)!=size:\n  raise error(\"unpack_from requires a buffer of at least %d bytes\"\n  %(size,))\n return unpack(fmt,data)\n \ndef _clearcache():\n ''\n \n \nclass Struct:\n\n def __init__(self,fmt):\n  self.format=fmt\n  \n def pack(self,*args):\n  return pack(self.format,*args)\n  \n def pack_into(self,*args):\n  return pack_into(self.format,*args)\n  \n def unpack(self,*args):\n  return unpack(self.format,*args)\n  \n def unpack_from(self,*args):\n  return unpack_from(self.format,*args)\n  \nif __name__ =='__main__':\n t=pack('Bf',1,2)\n print(t,len(t))\n print(unpack('Bf',t))\n print(calcsize('Bf'))\n \n", ["math", "re", "sys"]], "abc": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n funcobj.__isabstractmethod__=True\n return funcobj\n \n \nclass abstractclassmethod(classmethod):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\n  \n  \nclass abstractstaticmethod(staticmethod):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\n  \n  \nclass abstractproperty(property):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n \ntry :\n from _abc import (get_cache_token,_abc_init,_abc_register,\n _abc_instancecheck,_abc_subclasscheck,_get_dump,\n _reset_registry,_reset_caches)\nexcept ImportError:\n from _py_abc import ABCMeta,get_cache_token\n ABCMeta.__module__='abc'\nelse :\n class ABCMeta(type):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  def __new__(mcls,name,bases,namespace,**kwargs):\n   cls=super().__new__(mcls,name,bases,namespace,**kwargs)\n   _abc_init(cls)\n   return cls\n   \n  def register(cls,subclass):\n   ''\n\n\n   \n   return _abc_register(cls,subclass)\n   \n  def __instancecheck__(cls,instance):\n   ''\n   return _abc_instancecheck(cls,instance)\n   \n  def __subclasscheck__(cls,subclass):\n   ''\n   return _abc_subclasscheck(cls,subclass)\n   \n  def _dump_registry(cls,file=None ):\n   ''\n   print(f\"Class: {cls.__module__}.{cls.__qualname__}\",file=file)\n   print(f\"Inv. counter: {get_cache_token()}\",file=file)\n   (_abc_registry,_abc_cache,_abc_negative_cache,\n   _abc_negative_cache_version)=_get_dump(cls)\n   print(f\"_abc_registry: {_abc_registry!r}\",file=file)\n   print(f\"_abc_cache: {_abc_cache!r}\",file=file)\n   print(f\"_abc_negative_cache: {_abc_negative_cache!r}\",file=file)\n   print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n   file=file)\n   \n  def _abc_registry_clear(cls):\n   ''\n   _reset_registry(cls)\n   \n  def _abc_caches_clear(cls):\n   ''\n   _reset_caches(cls)\n   \n   \nclass ABC(metaclass=ABCMeta):\n ''\n\n \n __slots__=()\n", ["_abc", "_py_abc"]], "_sre": [".py", "\n''\n\n\n\n\n\n\n\nMAXREPEAT=2147483648\nMAXGROUPS=2147483647\n\nimport array\nimport operator,sys\nfrom sre_constants import ATCODES,OPCODES,CHCODES\nfrom sre_constants import SRE_INFO_PREFIX,SRE_INFO_LITERAL\nfrom sre_constants import SRE_FLAG_UNICODE,SRE_FLAG_LOCALE\n\n\nfrom _sre_utils import (unicode_iscased,ascii_iscased,unicode_tolower,\nascii_tolower)\n\nimport sys\n\n\n\nMAGIC=20171005\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODESIZE=4\n\ncopyright=\"_sre.py 2.4c Copyright 2005 by Nik Haldimann\"\n\n\ndef getcodesize():\n return CODESIZE\n \ndef compile(pattern,flags,code,groups=0,groupindex={},indexgroup=[None ]):\n ''\n \n return SRE_Pattern(pattern,flags,code,groups,groupindex,indexgroup)\n \ndef getlower(char_ord,flags):\n if (char_ord <128)or (flags&SRE_FLAG_UNICODE)\\\n or (flags&SRE_FLAG_LOCALE and char_ord <256):\n \n  return ord(chr(char_ord).lower())\n else :\n  return char_ord\n  \n  \nclass SRE_Pattern:\n\n def __init__(self,pattern,flags,code,groups=0,groupindex={},indexgroup=[None ]):\n  self.pattern=pattern\n  self.flags=flags\n  self.groups=groups\n  self.groupindex=groupindex\n  self._indexgroup=indexgroup\n  self._code=code\n  \n def match(self,string,pos=0,endpos=sys.maxsize):\n  ''\n\n  \n  state=_State(string,pos,endpos,self.flags)\n  if state.match(self._code):\n   return SRE_Match(self,state)\n  return None\n  \n def fullmatch(self,string,pos=0,endpos=sys.maxsize):\n  ''\n\n  \n  if not string.endswith(\"$\"):\n   string +=\"$\"\n  state=_State(string,pos,endpos,self.flags)\n  if state.match(self._code):\n   return SRE_Match(self,state)\n  return None\n  \n def search(self,string,pos=0,endpos=sys.maxsize):\n  ''\n\n\n  \n  state=_State(string,pos,endpos,self.flags)\n  if state.search(self._code):\n   return SRE_Match(self,state)\n  else :\n   return None\n   \n def findall(self,string,pos=0,endpos=sys.maxsize):\n  ''\n  matchlist=[]\n  state=_State(string,pos,endpos,self.flags)\n  while state.start <=state.end:\n   state.reset()\n   state.string_position=state.start\n   if not state.search(self._code):\n    break\n   match=SRE_Match(self,state)\n   if self.groups ==0 or self.groups ==1:\n    item=match.group(self.groups)\n   else :\n    item=match.groups(\"\")\n   matchlist.append(item)\n   if state.string_position ==state.start:\n    state.start +=1\n   else :\n    state.start=state.string_position\n  return matchlist\n  \n def _subx(self,template,string,count=0,subn=False ):\n  filter=template\n  if not callable(template)and \"\\\\\"in template:\n  \n  \n  \n  \n   import re as sre\n   filter=sre._subx(self,template)\n  state=_State(string,0,sys.maxsize,self.flags)\n  sublist=[]\n  \n  n=last_pos=0\n  while not count or n <count:\n   state.reset()\n   state.string_position=state.start\n   if not state.search(self._code):\n    break\n   if last_pos <state.start:\n    sublist.append(string[last_pos:state.start])\n   if not (last_pos ==state.start and\n   last_pos ==state.string_position and n >0):\n   \n    if callable(filter):\n     sublist.append(filter(SRE_Match(self,state)))\n    else :\n     sublist.append(filter)\n    last_pos=state.string_position\n    n +=1\n   if state.string_position ==state.start:\n    state.start +=1\n   else :\n    state.start=state.string_position\n    \n  if last_pos <state.end:\n   sublist.append(string[last_pos:state.end])\n  item=\"\".join(sublist)\n  if subn:\n   return item,n\n  else :\n   return item\n   \n def sub(self,repl,string,count=0):\n  ''\n  \n  return self._subx(repl,string,count,False )\n  \n def subn(self,repl,string,count=0):\n  ''\n\n  \n  return self._subx(repl,string,count,True )\n  \n def split(self,string,maxsplit=0):\n  ''\n  splitlist=[]\n  state=_State(string,0,sys.maxsize,self.flags)\n  n=0\n  last=state.start\n  while not maxsplit or n <maxsplit:\n   state.reset()\n   state.string_position=state.start\n   if not state.search(self._code):\n    break\n   if state.start ==state.string_position:\n    if last ==state.end:\n     break\n    state.start +=1\n    continue\n   splitlist.append(string[last:state.start])\n   \n   if self.groups:\n    match=SRE_Match(self,state)\n    splitlist.extend(list(match.groups(None )))\n   n +=1\n   last=state.start=state.string_position\n  splitlist.append(string[last:state.end])\n  return splitlist\n  \n def finditer(self,string,pos=0,endpos=sys.maxsize):\n  ''\n  \n  _list=[]\n  _m=self.scanner(string,pos,endpos)\n  _re=SRE_Scanner(self,string,pos,endpos)\n  _m=_re.search()\n  while _m:\n   _list.append(_m)\n   _m=_re.search()\n  return _list\n  \n  \n def scanner(self,string,start=0,end=sys.maxsize):\n  return SRE_Scanner(self,string,start,end)\n  \n def __copy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \nclass SRE_Scanner:\n ''\n \n def __init__(self,pattern,string,start,end):\n  self.pattern=pattern\n  self._state=_State(string,start,end,self.pattern.flags)\n  \n def _match_search(self,matcher):\n  state=self._state\n  state.reset()\n  state.string_position=state.start\n  match=None\n  if matcher(self.pattern._code):\n   match=SRE_Match(self.pattern,state)\n  if match is None or state.string_position ==state.start:\n   state.start +=1\n  else :\n   state.start=state.string_position\n  return match\n  \n def match(self):\n  return self._match_search(self._state.match)\n  \n def search(self):\n  return self._match_search(self._state.search)\n  \nclass SRE_Match:\n\n def __init__(self,pattern,state):\n  self.re=pattern\n  self.string=state.string\n  self.pos=state.pos\n  self.endpos=state.end\n  self.lastindex=state.lastindex\n  if self.lastindex <0:\n   self.lastindex=None\n  self.regs=self._create_regs(state)\n  \n  \n  \n  if self.lastindex is not None and pattern._indexgroup and 0 <=self.lastindex <len(pattern._indexgroup):\n  \n  \n  \n  \n  \n   self.lastgroup=pattern._indexgroup[self.lastindex]\n  else :\n   self.lastgroup=None\n   \n def __getitem__(self,rank):\n  return self.group(rank)\n  \n def _create_regs(self,state):\n  ''\n  regs=[(state.start,state.string_position)]\n  for group in range(self.re.groups):\n   mark_index=2 *group\n   if mark_index+1 <len(state.marks)\\\n   and state.marks[mark_index]is not None\\\n   and state.marks[mark_index+1]is not None :\n    regs.append((state.marks[mark_index],state.marks[mark_index+1]))\n   else :\n    regs.append((-1,-1))\n  return tuple(regs)\n  \n def _get_index(self,group):\n  if isinstance(group,int):\n   if group >=0 and group <=self.re.groups:\n    return group\n  else :\n   if group in self.re.groupindex:\n    return self.re.groupindex[group]\n  raise IndexError(\"no such group\")\n  \n def _get_slice(self,group,default):\n  group_indices=self.regs[group]\n  if group_indices[0]>=0:\n   return self.string[group_indices[0]:group_indices[1]]\n  else :\n   return default\n   \n def start(self,group=0):\n  ''\n\n  \n  return self.regs[self._get_index(group)][0]\n  \n def end(self,group=0):\n  ''\n\n  \n  return self.regs[self._get_index(group)][1]\n  \n def span(self,group=0):\n  ''\n  return self.start(group),self.end(group)\n  \n def expand(self,template):\n  ''\n  \n  import sre\n  return sre._expand(self.re,self,template)\n  \n def groups(self,default=None ):\n  ''\n\n  \n  groups=[]\n  for indices in self.regs[1:]:\n   if indices[0]>=0:\n    groups.append(self.string[indices[0]:indices[1]])\n   else :\n    groups.append(default)\n  return tuple(groups)\n  \n def groupdict(self,default=None ):\n  ''\n\n  \n  groupdict={}\n  for key,value in self.re.groupindex.items():\n   groupdict[key]=self._get_slice(value,default)\n  return groupdict\n  \n def group(self,*args):\n  ''\n  \n  if len(args)==0:\n   args=(0,)\n  grouplist=[]\n  for group in args:\n   grouplist.append(self._get_slice(self._get_index(group),None ))\n  if len(grouplist)==1:\n   return grouplist[0]\n  else :\n   return tuple(grouplist)\n   \n def __copy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n  \nclass _State:\n\n def __init__(self,string,start,end,flags):\n  if isinstance(string,bytearray):\n   string=str(bytes(string),\"latin1\")\n  if isinstance(string,bytes):\n   string=str(string,\"latin1\")\n  self.string=string\n  if start <0:\n   start=0\n  if end >len(string):\n   end=len(string)\n  self.start=start\n  self.string_position=self.start\n  self.end=end\n  self.pos=start\n  self.flags=flags\n  self.reset()\n  \n def reset(self):\n  self.marks=[]\n  self.lastindex=-1\n  self.marks_stack=[]\n  self.context_stack=[]\n  self.repeat=None\n  \n def match(self,pattern_codes):\n \n \n \n \n \n \n \n \n  dispatcher=_OpcodeDispatcher()\n  self.context_stack.append(_MatchContext(self,pattern_codes))\n  has_matched=None\n  while len(self.context_stack)>0:\n   context=self.context_stack[-1]\n   has_matched=dispatcher.match(context)\n   if has_matched is not None :\n    self.context_stack.pop()\n  return has_matched\n  \n def search(self,pattern_codes):\n  flags=0\n  if OPCODES[pattern_codes[0]].name ==\"info\":\n  \n  \n   if pattern_codes[2]&SRE_INFO_PREFIX and pattern_codes[5]>1:\n    return self.fast_search(pattern_codes)\n   flags=pattern_codes[2]\n   pattern_codes=pattern_codes[pattern_codes[1]+1:]\n   \n  string_position=self.start\n  if OPCODES[pattern_codes[0]].name ==\"literal\":\n  \n  \n   character=pattern_codes[1]\n   while True :\n    while string_position <self.end\\\n    and ord(self.string[string_position])!=character:\n     string_position +=1\n    if string_position >=self.end:\n     return False\n    self.start=string_position\n    string_position +=1\n    self.string_position=string_position\n    if flags&SRE_INFO_LITERAL:\n     return True\n    if self.match(pattern_codes[2:]):\n     return True\n   return False\n   \n   \n  while string_position <=self.end:\n   self.reset()\n   self.start=self.string_position=string_position\n   if self.match(pattern_codes):\n    return True\n   string_position +=1\n  return False\n  \n def fast_search(self,pattern_codes):\n  ''\n  \n  \n  \n  flags=pattern_codes[2]\n  prefix_len=pattern_codes[5]\n  prefix_skip=pattern_codes[6]\n  prefix=pattern_codes[7:7+prefix_len]\n  overlap=pattern_codes[7+prefix_len -1:pattern_codes[1]+1]\n  pattern_codes=pattern_codes[pattern_codes[1]+1:]\n  i=0\n  string_position=self.string_position\n  while string_position <self.end:\n   while True :\n    if ord(self.string[string_position])!=prefix[i]:\n     if i ==0:\n      break\n     else :\n      i=overlap[i]\n    else :\n     i +=1\n     if i ==prefix_len:\n     \n      self.start=string_position+1 -prefix_len\n      self.string_position=string_position+1\\\n      -prefix_len+prefix_skip\n      if flags&SRE_INFO_LITERAL:\n       return True\n      if self.match(pattern_codes[2 *prefix_skip:]):\n       return True\n      i=overlap[i]\n     break\n   string_position +=1\n  return False\n  \n def set_mark(self,mark_nr,position):\n  if mark_nr&1:\n  \n  \n  \n   self.lastindex=mark_nr //2+1\n  if mark_nr >=len(self.marks):\n   self.marks.extend([None ]*(mark_nr -len(self.marks)+1))\n  self.marks[mark_nr]=position\n  \n def get_marks(self,group_index):\n  marks_index=2 *group_index\n  if len(self.marks)>marks_index+1:\n   return self.marks[marks_index],self.marks[marks_index+1]\n  else :\n   return None ,None\n   \n def marks_push(self):\n  self.marks_stack.append((self.marks[:],self.lastindex))\n  \n def marks_pop(self):\n  self.marks,self.lastindex=self.marks_stack.pop()\n  \n def marks_pop_keep(self):\n  self.marks,self.lastindex=self.marks_stack[-1]\n  \n def marks_pop_discard(self):\n  self.marks_stack.pop()\n  \n def lower(self,char_ord):\n  return getlower(char_ord,self.flags)\n  \n  \nclass _MatchContext:\n\n def __init__(self,state,pattern_codes):\n  self.state=state\n  self.pattern_codes=pattern_codes\n  self.string_position=state.string_position\n  self.code_position=0\n  self.has_matched=None\n  \n def push_new_context(self,pattern_offset):\n  ''\n\n  \n  child_context=_MatchContext(self.state,\n  self.pattern_codes[self.code_position+pattern_offset:])\n  \n  \n  \n  \n  self.state.context_stack.append(child_context)\n  return child_context\n  \n def peek_char(self,peek=0):\n  return self.state.string[self.string_position+peek]\n  \n def skip_char(self,skip_count):\n  self.string_position +=skip_count\n  \n def remaining_chars(self):\n  return self.state.end -self.string_position\n  \n def peek_code(self,peek=0):\n  return self.pattern_codes[self.code_position+peek]\n  \n def skip_code(self,skip_count):\n  self.code_position +=skip_count\n  \n def remaining_codes(self):\n  return len(self.pattern_codes)-self.code_position\n  \n def at_beginning(self):\n  return self.string_position ==0\n  \n def at_end(self):\n  return self.string_position ==self.state.end\n  \n def at_linebreak(self):\n  return not self.at_end()and _is_linebreak(self.peek_char())\n  \n def at_boundary(self,word_checker):\n  if self.at_beginning()and self.at_end():\n   return False\n  that=not self.at_beginning()and word_checker(self.peek_char(-1))\n  this=not self.at_end()and word_checker(self.peek_char())\n  return this !=that\n  \n  \nclass _RepeatContext(_MatchContext):\n\n def __init__(self,context):\n  _MatchContext.__init__(self,context.state,\n  context.pattern_codes[context.code_position:])\n  self.count=-1\n  \n  self.previous=context.state.repeat\n  self.last_position=None\n  \n  \nclass _Dispatcher:\n\n DISPATCH_TABLE=None\n \n def dispatch(self,code,context):\n  method=self.DISPATCH_TABLE.get(code,self.__class__.unknown)\n  return method(self,context)\n  \n def unknown(self,code,ctx):\n  raise NotImplementedError()\n  \n def build_dispatch_table(cls,items,method_prefix):\n  if cls.DISPATCH_TABLE is not None :\n   return\n  table={}\n  for item in items:\n   key,value=item.name.lower(),int(item)\n   if hasattr(cls,\"%s%s\"%(method_prefix,key)):\n    table[value]=getattr(cls,\"%s%s\"%(method_prefix,key))\n  cls.DISPATCH_TABLE=table\n  \n build_dispatch_table=classmethod(build_dispatch_table)\n \n \nclass _OpcodeDispatcher(_Dispatcher):\n\n def __init__(self):\n  self.executing_contexts={}\n  self.at_dispatcher=_AtcodeDispatcher()\n  self.ch_dispatcher=_ChcodeDispatcher()\n  self.set_dispatcher=_CharsetDispatcher()\n  \n def match(self,context):\n  ''\n\n  \n  while context.remaining_codes()>0 and context.has_matched is None :\n   opcode=context.peek_code()\n   if not self.dispatch(opcode,context):\n    return None\n  if context.has_matched is None :\n   context.has_matched=False\n  return context.has_matched\n  \n def dispatch(self,opcode,context):\n  ''\n  \n  \n  if id(context)in self.executing_contexts:\n   generator=self.executing_contexts[id(context)]\n   del self.executing_contexts[id(context)]\n   has_finished=next(generator)\n  else :\n   method=self.DISPATCH_TABLE.get(opcode,_OpcodeDispatcher.unknown)\n   has_finished=method(self,context)\n   if hasattr(has_finished,\"__next__\"):\n    generator=has_finished\n    has_finished=next(generator)\n  if not has_finished:\n   self.executing_contexts[id(context)]=generator\n  return has_finished\n  \n def op_success(self,ctx):\n \n \n  ctx.state.string_position=ctx.string_position\n  ctx.has_matched=True\n  return True\n  \n def op_failure(self,ctx):\n \n \n  ctx.has_matched=False\n  return True\n  \n def general_op_literal(self,ctx,compare,decorate=lambda x:x):\n  if ctx.at_end()or not compare(decorate(ord(ctx.peek_char())),\n  decorate(ctx.peek_code(1))):\n   ctx.has_matched=False\n  ctx.skip_code(2)\n  ctx.skip_char(1)\n  \n def op_literal(self,ctx):\n \n \n \n  self.general_op_literal(ctx,operator.eq)\n  return True\n  \n def op_not_literal(self,ctx):\n \n \n \n  self.general_op_literal(ctx,operator.ne)\n  return True\n  \n def op_literal_ignore(self,ctx):\n \n \n \n  self.general_op_literal(ctx,operator.eq,ctx.state.lower)\n  return True\n  \n def op_literal_uni_ignore(self,ctx):\n  self.general_op_literal(ctx,operator.eq,ctx.state.lower)\n  return True\n  \n def op_not_literal_ignore(self,ctx):\n \n \n \n  self.general_op_literal(ctx,operator.ne,ctx.state.lower)\n  return True\n  \n def op_at(self,ctx):\n \n \n \n  if not self.at_dispatcher.dispatch(ctx.peek_code(1),ctx):\n   ctx.has_matched=False\n   \n   return True\n  ctx.skip_code(2)\n  return True\n  \n def op_category(self,ctx):\n \n \n \n  if ctx.at_end()or not self.ch_dispatcher.dispatch(ctx.peek_code(1),ctx):\n   ctx.has_matched=False\n   \n   return True\n  ctx.skip_code(2)\n  ctx.skip_char(1)\n  return True\n  \n def op_any(self,ctx):\n \n \n \n  if ctx.at_end()or ctx.at_linebreak():\n   ctx.has_matched=False\n   \n   return True\n  ctx.skip_code(1)\n  ctx.skip_char(1)\n  return True\n  \n def op_any_all(self,ctx):\n \n \n \n  if ctx.at_end():\n   ctx.has_matched=False\n   \n   return True\n  ctx.skip_code(1)\n  ctx.skip_char(1)\n  return True\n  \n def general_op_in(self,ctx,decorate=lambda x:x):\n \n \n  if ctx.at_end():\n   ctx.has_matched=False\n   \n   return\n  skip=ctx.peek_code(1)\n  ctx.skip_code(2)\n  \n  \n  if not self.check_charset(ctx,decorate(ord(ctx.peek_char()))):\n  \n   ctx.has_matched=False\n   return\n  ctx.skip_code(skip -1)\n  ctx.skip_char(1)\n  \n  \n def op_in(self,ctx):\n \n \n \n  self.general_op_in(ctx)\n  return True\n  \n def op_in_ignore(self,ctx):\n \n \n \n  self.general_op_in(ctx,ctx.state.lower)\n  return True\n  \n def op_in_uni_ignore(self,ctx):\n  self.general_op_in(ctx,ctx.state.lower)\n  return True\n  \n def op_jump(self,ctx):\n \n \n \n  ctx.skip_code(ctx.peek_code(1)+1)\n  return True\n  \n  \n  \n op_info=op_jump\n \n def op_mark(self,ctx):\n \n \n \n  ctx.state.set_mark(ctx.peek_code(1),ctx.string_position)\n  ctx.skip_code(2)\n  return True\n  \n def op_branch(self,ctx):\n \n \n \n  ctx.state.marks_push()\n  ctx.skip_code(1)\n  current_branch_length=ctx.peek_code(0)\n  while current_branch_length:\n  \n  \n   if not (OPCODES[ctx.peek_code(1)].name ==\"literal\"and\\\n   (ctx.at_end()or ctx.peek_code(2)!=ord(ctx.peek_char()))):\n    ctx.state.string_position=ctx.string_position\n    child_context=ctx.push_new_context(1)\n    \n    yield False\n    if child_context.has_matched:\n     ctx.has_matched=True\n     yield True\n    ctx.state.marks_pop_keep()\n   ctx.skip_code(current_branch_length)\n   current_branch_length=ctx.peek_code(0)\n  ctx.state.marks_pop_discard()\n  ctx.has_matched=False\n  \n  yield True\n  \n def op_repeat_one(self,ctx):\n \n \n \n \n  mincount=ctx.peek_code(2)\n  maxcount=ctx.peek_code(3)\n  \n  \n  \n  if ctx.remaining_chars()<mincount:\n   ctx.has_matched=False\n   yield True\n  ctx.state.string_position=ctx.string_position\n  count=self.count_repetitions(ctx,maxcount)\n  ctx.skip_char(count)\n  if count <mincount:\n   ctx.has_matched=False\n   yield True\n  if OPCODES[ctx.peek_code(ctx.peek_code(1)+1)].name ==\"success\":\n  \n   ctx.state.string_position=ctx.string_position\n   ctx.has_matched=True\n   yield True\n   \n  ctx.state.marks_push()\n  if OPCODES[ctx.peek_code(ctx.peek_code(1)+1)].name ==\"literal\":\n  \n  \n   char=ctx.peek_code(ctx.peek_code(1)+2)\n   while True :\n    while count >=mincount and\\\n    (ctx.at_end()or ord(ctx.peek_char())!=char):\n     ctx.skip_char(-1)\n     count -=1\n    if count <mincount:\n     break\n    ctx.state.string_position=ctx.string_position\n    child_context=ctx.push_new_context(ctx.peek_code(1)+1)\n    \n    yield False\n    if child_context.has_matched:\n     ctx.has_matched=True\n     yield True\n    ctx.skip_char(-1)\n    count -=1\n    ctx.state.marks_pop_keep()\n    \n  else :\n  \n   while count >=mincount:\n    ctx.state.string_position=ctx.string_position\n    child_context=ctx.push_new_context(ctx.peek_code(1)+1)\n    yield False\n    if child_context.has_matched:\n     ctx.has_matched=True\n     yield True\n    ctx.skip_char(-1)\n    count -=1\n    ctx.state.marks_pop_keep()\n    \n  ctx.state.marks_pop_discard()\n  ctx.has_matched=False\n  \n  yield True\n  \n def op_min_repeat_one(self,ctx):\n \n \n  mincount=ctx.peek_code(2)\n  maxcount=ctx.peek_code(3)\n  \n  \n  if ctx.remaining_chars()<mincount:\n   ctx.has_matched=False\n   yield True\n  ctx.state.string_position=ctx.string_position\n  if mincount ==0:\n   count=0\n  else :\n   count=self.count_repetitions(ctx,mincount)\n   if count <mincount:\n    ctx.has_matched=False\n    \n    yield True\n   ctx.skip_char(count)\n  if OPCODES[ctx.peek_code(ctx.peek_code(1)+1)].name ==\"success\":\n  \n   ctx.state.string_position=ctx.string_position\n   ctx.has_matched=True\n   yield True\n   \n  ctx.state.marks_push()\n  while maxcount ==MAXREPEAT or count <=maxcount:\n   ctx.state.string_position=ctx.string_position\n   child_context=ctx.push_new_context(ctx.peek_code(1)+1)\n   \n   yield False\n   if child_context.has_matched:\n    ctx.has_matched=True\n    yield True\n   ctx.state.string_position=ctx.string_position\n   if self.count_repetitions(ctx,1)==0:\n    break\n   ctx.skip_char(1)\n   count +=1\n   ctx.state.marks_pop_keep()\n   \n  ctx.state.marks_pop_discard()\n  ctx.has_matched=False\n  yield True\n  \n def op_repeat(self,ctx):\n \n \n \n \n \n \n \n \n \n  repeat=_RepeatContext(ctx)\n  ctx.state.repeat=repeat\n  ctx.state.string_position=ctx.string_position\n  child_context=ctx.push_new_context(ctx.peek_code(1)+1)\n  \n  \n  \n  \n  yield False\n  ctx.state.repeat=repeat.previous\n  ctx.has_matched=child_context.has_matched\n  yield True\n  \n def op_max_until(self,ctx):\n \n \n  repeat=ctx.state.repeat\n  \n  if repeat is None :\n  \n   raise RuntimeError(\"Internal re error: MAX_UNTIL without REPEAT.\")\n  mincount=repeat.peek_code(2)\n  maxcount=repeat.peek_code(3)\n  ctx.state.string_position=ctx.string_position\n  count=repeat.count+1\n  \n  \n  if count <mincount:\n  \n   repeat.count=count\n   child_context=repeat.push_new_context(4)\n   yield False\n   ctx.has_matched=child_context.has_matched\n   if not ctx.has_matched:\n    repeat.count=count -1\n    ctx.state.string_position=ctx.string_position\n   yield True\n   \n  if (count <maxcount or maxcount ==MAXREPEAT)\\\n  and ctx.state.string_position !=repeat.last_position:\n  \n   repeat.count=count\n   ctx.state.marks_push()\n   save_last_position=repeat.last_position\n   repeat.last_position=ctx.state.string_position\n   child_context=repeat.push_new_context(4)\n   yield False\n   repeat.last_position=save_last_position\n   if child_context.has_matched:\n    ctx.state.marks_pop_discard()\n    ctx.has_matched=True\n    yield True\n   ctx.state.marks_pop()\n   repeat.count=count -1\n   ctx.state.string_position=ctx.string_position\n   \n   \n  ctx.state.repeat=repeat.previous\n  child_context=ctx.push_new_context(1)\n  \n  yield False\n  ctx.has_matched=child_context.has_matched\n  if not ctx.has_matched:\n   ctx.state.repeat=repeat\n   ctx.state.string_position=ctx.string_position\n  yield True\n  \n def op_min_until(self,ctx):\n \n \n  repeat=ctx.state.repeat\n  if repeat is None :\n   raise RuntimeError(\"Internal re error: MIN_UNTIL without REPEAT.\")\n  mincount=repeat.peek_code(2)\n  maxcount=repeat.peek_code(3)\n  ctx.state.string_position=ctx.string_position\n  count=repeat.count+1\n  \n  \n  if count <mincount:\n  \n   repeat.count=count\n   child_context=repeat.push_new_context(4)\n   yield False\n   ctx.has_matched=child_context.has_matched\n   if not ctx.has_matched:\n    repeat.count=count -1\n    ctx.state.string_position=ctx.string_position\n   yield True\n   \n   \n  ctx.state.marks_push()\n  ctx.state.repeat=repeat.previous\n  child_context=ctx.push_new_context(1)\n  \n  yield False\n  if child_context.has_matched:\n   ctx.has_matched=True\n   yield True\n  ctx.state.repeat=repeat\n  ctx.state.string_position=ctx.string_position\n  ctx.state.marks_pop()\n  \n  \n  if count >=maxcount and maxcount !=MAXREPEAT:\n   ctx.has_matched=False\n   \n   yield True\n  repeat.count=count\n  child_context=repeat.push_new_context(4)\n  yield False\n  ctx.has_matched=child_context.has_matched\n  if not ctx.has_matched:\n   repeat.count=count -1\n   ctx.state.string_position=ctx.string_position\n  yield True\n  \n def general_op_groupref(self,ctx,decorate=lambda x:x):\n  group_start,group_end=ctx.state.get_marks(ctx.peek_code(1))\n  if group_start is None or group_end is None or group_end <group_start:\n   ctx.has_matched=False\n   return True\n  while group_start <group_end:\n   if ctx.at_end()or decorate(ord(ctx.peek_char()))\\\n   !=decorate(ord(ctx.state.string[group_start])):\n    ctx.has_matched=False\n    \n    return True\n   group_start +=1\n   ctx.skip_char(1)\n  ctx.skip_code(2)\n  return True\n  \n def op_groupref(self,ctx):\n \n \n \n  return self.general_op_groupref(ctx)\n  \n def op_groupref_ignore(self,ctx):\n \n \n \n  return self.general_op_groupref(ctx,ctx.state.lower)\n  \n def op_groupref_exists(self,ctx):\n \n \n  group_start,group_end=ctx.state.get_marks(ctx.peek_code(1))\n  if group_start is None or group_end is None or group_end <group_start:\n   ctx.skip_code(ctx.peek_code(2)+1)\n  else :\n   ctx.skip_code(3)\n  return True\n  \n def op_assert(self,ctx):\n \n \n \n  ctx.state.string_position=ctx.string_position -ctx.peek_code(2)\n  if ctx.state.string_position <0:\n   ctx.has_matched=False\n   yield True\n  child_context=ctx.push_new_context(3)\n  yield False\n  if child_context.has_matched:\n   ctx.skip_code(ctx.peek_code(1)+1)\n  else :\n   ctx.has_matched=False\n  yield True\n  \n def op_assert_not(self,ctx):\n \n \n \n  ctx.state.string_position=ctx.string_position -ctx.peek_code(2)\n  if ctx.state.string_position >=0:\n   child_context=ctx.push_new_context(3)\n   yield False\n   if child_context.has_matched:\n    ctx.has_matched=False\n    yield True\n  ctx.skip_code(ctx.peek_code(1)+1)\n  yield True\n  \n def unknown(self,ctx):\n \n  raise RuntimeError(\"Internal re error. Unknown opcode: %s\"%ctx.peek_code())\n  \n def check_charset(self,ctx,char):\n  ''\n  \n  self.set_dispatcher.reset(char)\n  save_position=ctx.code_position\n  result=None\n  while result is None :\n   result=self.set_dispatcher.dispatch(ctx.peek_code(),ctx)\n  ctx.code_position=save_position\n  \n  return result\n  \n def count_repetitions(self,ctx,maxcount):\n  ''\n\n  \n  count=0\n  real_maxcount=ctx.state.end -ctx.string_position\n  if maxcount <real_maxcount and maxcount !=MAXREPEAT:\n   real_maxcount=maxcount\n   \n   \n   \n  code_position=ctx.code_position\n  string_position=ctx.string_position\n  ctx.skip_code(4)\n  reset_position=ctx.code_position\n  while count <real_maxcount:\n  \n  \n   ctx.code_position=reset_position\n   self.dispatch(ctx.peek_code(),ctx)\n   \n   if ctx.has_matched is False :\n    break\n   count +=1\n  ctx.has_matched=None\n  ctx.code_position=code_position\n  ctx.string_position=string_position\n  return count\n  \n def _log(self,context,opname,*args):\n  arg_string=(\"%s \"*len(args))%args\n  _log(\"|%s|%s|%s %s\"%(context.pattern_codes,\n  context.string_position,opname,arg_string))\n  \n_OpcodeDispatcher.build_dispatch_table(OPCODES,\"op_\")\n\n\nclass _CharsetDispatcher(_Dispatcher):\n\n def __init__(self):\n  self.ch_dispatcher=_ChcodeDispatcher()\n  \n def reset(self,char):\n  self.char=char\n  self.ok=True\n  \n def set_failure(self,ctx):\n  return not self.ok\n def set_literal(self,ctx):\n \n  if ctx.peek_code(1)==self.char:\n   return self.ok\n  else :\n   ctx.skip_code(2)\n def set_category(self,ctx):\n \n  if self.ch_dispatcher.dispatch(ctx.peek_code(1),ctx):\n   return self.ok\n  else :\n   ctx.skip_code(2)\n def set_charset(self,ctx):\n \n  char_code=self.char\n  ctx.skip_code(1)\n  if CODESIZE ==2:\n   if char_code <256 and ctx.peek_code(char_code >>4)\\\n   &(1 <<(char_code&15)):\n    return self.ok\n   ctx.skip_code(16)\n  else :\n   if char_code <256 and ctx.peek_code(char_code >>5)\\\n   &(1 <<(char_code&31)):\n    return self.ok\n   ctx.skip_code(8)\n def set_range(self,ctx):\n \n  if ctx.peek_code(1)<=self.char <=ctx.peek_code(2):\n   return self.ok\n  ctx.skip_code(3)\n def set_negate(self,ctx):\n  self.ok=not self.ok\n  ctx.skip_code(1)\n  \n def set_bigcharset(self,ctx):\n \n  char_code=self.char\n  count=ctx.peek_code(1)\n  ctx.skip_code(2)\n  if char_code <65536:\n   block_index=char_code >>8\n   \n   a=array.array(\"B\")\n   a.fromstring(array.array(CODESIZE ==2 and \"H\"or \"I\",\n   [ctx.peek_code(block_index //CODESIZE)]).tostring())\n   block=a[block_index %CODESIZE]\n   ctx.skip_code(256 //CODESIZE)\n   block_value=ctx.peek_code(block *(32 //CODESIZE)\n   +((char_code&255)>>(CODESIZE ==2 and 4 or 5)))\n   if block_value&(1 <<(char_code&((8 *CODESIZE)-1))):\n    return self.ok\n  else :\n   ctx.skip_code(256 //CODESIZE)\n  ctx.skip_code(count *(32 //CODESIZE))\n  \n def unknown(self,ctx):\n  return False\n  \n_CharsetDispatcher.build_dispatch_table(OPCODES,\"set_\")\n\n\nclass _AtcodeDispatcher(_Dispatcher):\n\n def at_beginning(self,ctx):\n  return ctx.at_beginning()\n at_beginning_string=at_beginning\n def at_beginning_line(self,ctx):\n  return ctx.at_beginning()or _is_linebreak(ctx.peek_char(-1))\n def at_end(self,ctx):\n  return (ctx.remaining_chars()==1 and ctx.at_linebreak())or ctx.at_end()\n def at_end_line(self,ctx):\n  return ctx.at_linebreak()or ctx.at_end()\n def at_end_string(self,ctx):\n  return ctx.at_end()\n def at_boundary(self,ctx):\n  return ctx.at_boundary(_is_word)\n def at_non_boundary(self,ctx):\n  return not ctx.at_boundary(_is_word)\n def at_loc_boundary(self,ctx):\n  return ctx.at_boundary(_is_loc_word)\n def at_loc_non_boundary(self,ctx):\n  return not ctx.at_boundary(_is_loc_word)\n def at_uni_boundary(self,ctx):\n  return ctx.at_boundary(_is_uni_word)\n def at_uni_non_boundary(self,ctx):\n  return not ctx.at_boundary(_is_uni_word)\n def unknown(self,ctx):\n  return False\n  \n_AtcodeDispatcher.build_dispatch_table(ATCODES,\"\")\n\n\nclass _ChcodeDispatcher(_Dispatcher):\n\n def category_digit(self,ctx):\n  return _is_digit(ctx.peek_char())\n def category_not_digit(self,ctx):\n  return not _is_digit(ctx.peek_char())\n def category_space(self,ctx):\n  return _is_space(ctx.peek_char())\n def category_not_space(self,ctx):\n  return not _is_space(ctx.peek_char())\n def category_word(self,ctx):\n  return _is_word(ctx.peek_char())\n def category_not_word(self,ctx):\n  return not _is_word(ctx.peek_char())\n def category_linebreak(self,ctx):\n  return _is_linebreak(ctx.peek_char())\n def category_not_linebreak(self,ctx):\n  return not _is_linebreak(ctx.peek_char())\n def category_loc_word(self,ctx):\n  return _is_loc_word(ctx.peek_char())\n def category_loc_not_word(self,ctx):\n  return not _is_loc_word(ctx.peek_char())\n def category_uni_digit(self,ctx):\n  return ctx.peek_char().isdigit()\n def category_uni_not_digit(self,ctx):\n  return not ctx.peek_char().isdigit()\n def category_uni_space(self,ctx):\n  return ctx.peek_char().isspace()\n def category_uni_not_space(self,ctx):\n  return not ctx.peek_char().isspace()\n def category_uni_word(self,ctx):\n  return _is_uni_word(ctx.peek_char())\n def category_uni_not_word(self,ctx):\n  return not _is_uni_word(ctx.peek_char())\n def category_uni_linebreak(self,ctx):\n  return ord(ctx.peek_char())in _uni_linebreaks\n def category_uni_not_linebreak(self,ctx):\n  return ord(ctx.peek_char())not in _uni_linebreaks\n def unknown(self,ctx):\n  return False\n  \n_ChcodeDispatcher.build_dispatch_table(CHCODES,\"\")\n\n\n_ascii_char_info=[0,0,0,0,0,0,0,0,0,2,6,2,\n2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,25,25,25,25,25,25,25,25,\n25,25,0,0,0,0,0,0,0,24,24,24,24,24,24,24,24,24,24,\n24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,0,0,\n0,0,16,0,24,24,24,24,24,24,24,24,24,24,24,24,24,24,\n24,24,24,24,24,24,24,24,24,24,24,24,0,0,0,0,0]\n\ndef _is_digit(char):\n code=ord(char)\n return code <128 and _ascii_char_info[code]&1\n \ndef _is_space(char):\n code=ord(char)\n return code <128 and _ascii_char_info[code]&2\n \ndef _is_word(char):\n\n code=ord(char)\n return code <128 and _ascii_char_info[code]&16\n \ndef _is_loc_word(char):\n return (not (ord(char)&~255)and char.isalnum())or char =='_'\n \ndef _is_uni_word(char):\n\n\n return chr(ord(char)).isalnum()or char =='_'\n \ndef _is_linebreak(char):\n return char ==\"\\n\"\n \n \n_uni_linebreaks=[10,13,28,29,30,133,8232,8233]\n\ndef _log(message):\n if 0:\n  print(message)\n", ["_sre_utils", "array", "operator", "re", "sre", "sre_constants", "sys"]], "VFS_import": [".py", "import os\nimport sys\nfrom browser import doc\n\n\n\n\n\n\nVFS=dict(JSObject(__BRYTHON__.py_VFS))\nclass VFSModuleFinder:\n def __init__(self,path_entry):\n  print(\"in VFSModuleFinder\")\n  if path_entry.startswith('/libs')or path_entry.startswith('/Lib'):\n   self.path_entry=path_entry\n  else :\n   raise ImportError()\n   \n def __str__(self):\n  return '<%s for \"%s\">'%(self.__class__.__name__,self.path_entry)\n  \n def find_module(self,fullname,path=None ):\n  path=path or self.path_entry\n  \n  for _ext in ['js','pyj','py']:\n   _filepath=os.path.join(self.path_entry,'%s.%s'%(fullname,_ext))\n   if _filepath in VFS:\n    print(\"module found at %s:%s\"%(_filepath,fullname))\n    return VFSModuleLoader(_filepath,fullname)\n    \n  print('module %s not found'%fullname)\n  raise ImportError()\n  return None\n  \nclass VFSModuleLoader:\n ''\n \n def __init__(self,filepath,name):\n  self._filepath=filepath\n  self._name=name\n  \n def get_source(self):\n  if self._filepath in VFS:\n   return JSObject(readFromVFS(self._filepath))\n   \n  raise ImportError('could not find source for %s'%fullname)\n  \n def is_package(self):\n  return '.'in self._name\n  \n def load_module(self):\n  if self._name in sys.modules:\n  \n   mod=sys.modules[self._name]\n   return mod\n   \n  _src=self.get_source()\n  if self._filepath.endswith('.js'):\n   mod=JSObject(import_js_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.py'):\n   mod=JSObject(import_py_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.pyj'):\n   mod=JSObject(import_pyj_module(_src,self._filepath,self._name))\n  else :\n   raise ImportError('Invalid Module: %s'%self._filepath)\n   \n   \n  mod.__file__=self._filepath\n  mod.__name__=self._name\n  mod.__path__=os.path.abspath(self._filepath)\n  mod.__loader__=self\n  mod.__package__='.'.join(self._name.split('.')[:-1])\n  \n  if self.is_package():\n   print('adding path for package')\n   \n   \n   mod.__path__=[self.path_entry]\n  else :\n   print('imported as regular module')\n   \n  print('creating a new module object for \"%s\"'%self._name)\n  sys.modules.setdefault(self._name,mod)\n  JSObject(__BRYTHON__.imported)[self._name]=mod\n  \n  return mod\n  \nJSObject(__BRYTHON__.path_hooks.insert(0,VFSModuleFinder))\n", ["browser", "os", "sys"]], "this": [".py", "s=\"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd={}\nfor c in (65,97):\n for i in range(26):\n  d[chr(i+c)]=chr((i+13)%26+c)\n  \nprint(\"\".join([d.get(c,c)for c in s]))\n", []], "operator": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n__all__=['abs','add','and_','attrgetter','concat','contains','countOf',\n'delitem','eq','floordiv','ge','getitem','gt','iadd','iand',\n'iconcat','ifloordiv','ilshift','imatmul','imod','imul',\n'index','indexOf','inv','invert','ior','ipow','irshift',\n'is_','is_not','isub','itemgetter','itruediv','ixor','le',\n'length_hint','lshift','lt','matmul','methodcaller','mod',\n'mul','ne','neg','not_','or_','pos','pow','rshift',\n'setitem','sub','truediv','truth','xor']\n\nfrom builtins import abs as _abs\n\n\n\n\ndef lt(a,b):\n ''\n return a <b\n \ndef le(a,b):\n ''\n return a <=b\n \ndef eq(a,b):\n ''\n return a ==b\n \ndef ne(a,b):\n ''\n return a !=b\n \ndef ge(a,b):\n ''\n return a >=b\n \ndef gt(a,b):\n ''\n return a >b\n \n \n \ndef not_(a):\n ''\n return not a\n \ndef truth(a):\n ''\n return True if a else False\n \ndef is_(a,b):\n ''\n return a is b\n \ndef is_not(a,b):\n ''\n return a is not b\n \n \n \ndef abs(a):\n ''\n return _abs(a)\n \ndef add(a,b):\n ''\n return a+b\n \ndef and_(a,b):\n ''\n return a&b\n \ndef floordiv(a,b):\n ''\n return a //b\n \ndef index(a):\n ''\n return a.__index__()\n \ndef inv(a):\n ''\n return ~a\ninvert=inv\n\ndef lshift(a,b):\n ''\n return a <<b\n \ndef mod(a,b):\n ''\n return a %b\n \ndef mul(a,b):\n ''\n return a *b\n \ndef matmul(a,b):\n ''\n return a @b\n \ndef neg(a):\n ''\n return -a\n \ndef or_(a,b):\n ''\n return a |b\n \ndef pos(a):\n ''\n return +a\n \ndef pow(a,b):\n ''\n return a **b\n \ndef rshift(a,b):\n ''\n return a >>b\n \ndef sub(a,b):\n ''\n return a -b\n \ndef truediv(a,b):\n ''\n return a /b\n \ndef xor(a,b):\n ''\n return a ^b\n \n \n \ndef concat(a,b):\n ''\n if not hasattr(a,'__getitem__'):\n  msg=\"'%s' object can't be concatenated\"%type(a).__name__\n  raise TypeError(msg)\n return a+b\n \ndef contains(a,b):\n ''\n return b in a\n \ndef countOf(a,b):\n ''\n count=0\n for i in a:\n  if i ==b:\n   count +=1\n return count\n \ndef delitem(a,b):\n ''\n del a[b]\n \ndef getitem(a,b):\n ''\n return a[b]\n \ndef indexOf(a,b):\n ''\n for i,j in enumerate(a):\n  if j ==b:\n   return i\n else :\n  raise ValueError('sequence.index(x): x not in sequence')\n  \ndef setitem(a,b,c):\n ''\n a[b]=c\n \ndef length_hint(obj,default=0):\n ''\n\n\n\n\n\n\n \n if not isinstance(default,int):\n  msg=(\"'%s' object cannot be interpreted as an integer\"%\n  type(default).__name__)\n  raise TypeError(msg)\n  \n try :\n  return len(obj)\n except TypeError:\n  pass\n  \n try :\n  hint=type(obj).__length_hint__\n except AttributeError:\n  return default\n  \n try :\n  val=hint(obj)\n except TypeError:\n  return default\n if val is NotImplemented:\n  return default\n if not isinstance(val,int):\n  msg=('__length_hint__ must be integer, not %s'%\n  type(val).__name__)\n  raise TypeError(msg)\n if val <0:\n  msg='__length_hint__() should return >= 0'\n  raise ValueError(msg)\n return val\n \n \n \nclass attrgetter:\n ''\n\n\n\n\n\n \n __slots__=('_attrs','_call')\n \n def __init__(self,attr,*attrs):\n  if not attrs:\n   if not isinstance(attr,str):\n    raise TypeError('attribute name must be a string')\n   self._attrs=(attr,)\n   names=attr.split('.')\n   def func(obj):\n    for name in names:\n     obj=getattr(obj,name)\n    return obj\n   self._call=func\n  else :\n   self._attrs=(attr,)+attrs\n   getters=tuple(map(attrgetter,self._attrs))\n   def func(obj):\n    return tuple(getter(obj)for getter in getters)\n   self._call=func\n   \n def __call__(self,obj):\n  return self._call(obj)\n  \n def __repr__(self):\n  return '%s.%s(%s)'%(self.__class__.__module__,\n  self.__class__.__qualname__,\n  ', '.join(map(repr,self._attrs)))\n  \n def __reduce__(self):\n  return self.__class__,self._attrs\n  \nclass itemgetter:\n ''\n\n\n\n \n __slots__=('_items','_call')\n \n def __init__(self,item,*items):\n  if not items:\n   self._items=(item,)\n   def func(obj):\n    return obj[item]\n   self._call=func\n  else :\n   self._items=items=(item,)+items\n   def func(obj):\n    return tuple(obj[i]for i in items)\n   self._call=func\n   \n def __call__(self,obj):\n  return self._call(obj)\n  \n def __repr__(self):\n  return '%s.%s(%s)'%(self.__class__.__module__,\n  self.__class__.__name__,\n  ', '.join(map(repr,self._items)))\n  \n def __reduce__(self):\n  return self.__class__,self._items\n  \nclass methodcaller:\n ''\n\n\n\n\n \n __slots__=('_name','_args','_kwargs')\n \n def __init__(self,name,/,*args,**kwargs):\n  self._name=name\n  if not isinstance(self._name,str):\n   raise TypeError('method name must be a string')\n  self._args=args\n  self._kwargs=kwargs\n  \n def __call__(self,obj):\n  return getattr(obj,self._name)(*self._args,**self._kwargs)\n  \n def __repr__(self):\n  args=[repr(self._name)]\n  args.extend(map(repr,self._args))\n  args.extend('%s=%r'%(k,v)for k,v in self._kwargs.items())\n  return '%s.%s(%s)'%(self.__class__.__module__,\n  self.__class__.__name__,\n  ', '.join(args))\n  \n def __reduce__(self):\n  if not self._kwargs:\n   return self.__class__,(self._name,)+self._args\n  else :\n   from functools import partial\n   return partial(self.__class__,self._name,**self._kwargs),self._args\n   \n   \n   \n   \ndef iadd(a,b):\n ''\n a +=b\n return a\n \ndef iand(a,b):\n ''\n a &=b\n return a\n \ndef iconcat(a,b):\n ''\n if not hasattr(a,'__getitem__'):\n  msg=\"'%s' object can't be concatenated\"%type(a).__name__\n  raise TypeError(msg)\n a +=b\n return a\n \ndef ifloordiv(a,b):\n ''\n a //=b\n return a\n \ndef ilshift(a,b):\n ''\n a <<=b\n return a\n \ndef imod(a,b):\n ''\n a %=b\n return a\n \ndef imul(a,b):\n ''\n a *=b\n return a\n \ndef imatmul(a,b):\n ''\n a @=b\n return a\n \ndef ior(a,b):\n ''\n a |=b\n return a\n \ndef ipow(a,b):\n ''\n a **=b\n return a\n \ndef irshift(a,b):\n ''\n a >>=b\n return a\n \ndef isub(a,b):\n ''\n a -=b\n return a\n \ndef itruediv(a,b):\n ''\n a /=b\n return a\n \ndef ixor(a,b):\n ''\n a ^=b\n return a\n \n \ntry :\n from _operator import *\nexcept ImportError:\n pass\nelse :\n from _operator import __doc__\n \n \n \n__lt__=lt\n__le__=le\n__eq__=eq\n__ne__=ne\n__ge__=ge\n__gt__=gt\n__not__=not_\n__abs__=abs\n__add__=add\n__and__=and_\n__floordiv__=floordiv\n__index__=index\n__inv__=inv\n__invert__=invert\n__lshift__=lshift\n__mod__=mod\n__mul__=mul\n__matmul__=matmul\n__neg__=neg\n__or__=or_\n__pos__=pos\n__pow__=pow\n__rshift__=rshift\n__sub__=sub\n__truediv__=truediv\n__xor__=xor\n__concat__=concat\n__contains__=contains\n__delitem__=delitem\n__getitem__=getitem\n__setitem__=setitem\n__iadd__=iadd\n__iand__=iand\n__iconcat__=iconcat\n__ifloordiv__=ifloordiv\n__ilshift__=ilshift\n__imod__=imod\n__imul__=imul\n__imatmul__=imatmul\n__ior__=ior\n__ipow__=ipow\n__irshift__=irshift\n__isub__=isub\n__itruediv__=itruediv\n__ixor__=ixor\n", ["_operator", "builtins", "functools"]], "opcode": [".py", "\n\"\"\"\nopcode module - potentially shared between dis and other modules which\noperate on bytecodes (e.g. peephole optimizers).\n\"\"\"\n\n__all__=[\"cmp_op\",\"hasconst\",\"hasname\",\"hasjrel\",\"hasjabs\",\n\"haslocal\",\"hascompare\",\"hasfree\",\"opname\",\"opmap\",\n\"HAVE_ARGUMENT\",\"EXTENDED_ARG\",\"hasnargs\"]\n\n\n\n\n\n\n\n\ntry :\n from _opcode import stack_effect\n __all__.append('stack_effect')\nexcept ImportError:\n pass\n \ncmp_op=('<','<=','==','!=','>','>=','in','not in','is',\n'is not','exception match','BAD')\n\nhasconst=[]\nhasname=[]\nhasjrel=[]\nhasjabs=[]\nhaslocal=[]\nhascompare=[]\nhasfree=[]\nhasnargs=[]\n\nopmap={}\nopname=['<%r>'%(op,)for op in range(256)]\n\ndef def_op(name,op):\n opname[op]=name\n opmap[name]=op\n \ndef name_op(name,op):\n def_op(name,op)\n hasname.append(op)\n \ndef jrel_op(name,op):\n def_op(name,op)\n hasjrel.append(op)\n \ndef jabs_op(name,op):\n def_op(name,op)\n hasjabs.append(op)\n \n \n \n \ndef_op('POP_TOP',1)\ndef_op('ROT_TWO',2)\ndef_op('ROT_THREE',3)\ndef_op('DUP_TOP',4)\ndef_op('DUP_TOP_TWO',5)\ndef_op('ROT_FOUR',6)\n\ndef_op('NOP',9)\ndef_op('UNARY_POSITIVE',10)\ndef_op('UNARY_NEGATIVE',11)\ndef_op('UNARY_NOT',12)\n\ndef_op('UNARY_INVERT',15)\n\ndef_op('BINARY_MATRIX_MULTIPLY',16)\ndef_op('INPLACE_MATRIX_MULTIPLY',17)\n\ndef_op('BINARY_POWER',19)\ndef_op('BINARY_MULTIPLY',20)\n\ndef_op('BINARY_MODULO',22)\ndef_op('BINARY_ADD',23)\ndef_op('BINARY_SUBTRACT',24)\ndef_op('BINARY_SUBSCR',25)\ndef_op('BINARY_FLOOR_DIVIDE',26)\ndef_op('BINARY_TRUE_DIVIDE',27)\ndef_op('INPLACE_FLOOR_DIVIDE',28)\ndef_op('INPLACE_TRUE_DIVIDE',29)\n\ndef_op('GET_AITER',50)\ndef_op('GET_ANEXT',51)\ndef_op('BEFORE_ASYNC_WITH',52)\ndef_op('BEGIN_FINALLY',53)\ndef_op('END_ASYNC_FOR',54)\ndef_op('INPLACE_ADD',55)\ndef_op('INPLACE_SUBTRACT',56)\ndef_op('INPLACE_MULTIPLY',57)\n\ndef_op('INPLACE_MODULO',59)\ndef_op('STORE_SUBSCR',60)\ndef_op('DELETE_SUBSCR',61)\ndef_op('BINARY_LSHIFT',62)\ndef_op('BINARY_RSHIFT',63)\ndef_op('BINARY_AND',64)\ndef_op('BINARY_XOR',65)\ndef_op('BINARY_OR',66)\ndef_op('INPLACE_POWER',67)\ndef_op('GET_ITER',68)\ndef_op('GET_YIELD_FROM_ITER',69)\n\ndef_op('PRINT_EXPR',70)\ndef_op('LOAD_BUILD_CLASS',71)\ndef_op('YIELD_FROM',72)\ndef_op('GET_AWAITABLE',73)\n\ndef_op('INPLACE_LSHIFT',75)\ndef_op('INPLACE_RSHIFT',76)\ndef_op('INPLACE_AND',77)\ndef_op('INPLACE_XOR',78)\ndef_op('INPLACE_OR',79)\ndef_op('WITH_CLEANUP_START',81)\ndef_op('WITH_CLEANUP_FINISH',82)\ndef_op('RETURN_VALUE',83)\ndef_op('IMPORT_STAR',84)\ndef_op('SETUP_ANNOTATIONS',85)\ndef_op('YIELD_VALUE',86)\ndef_op('POP_BLOCK',87)\ndef_op('END_FINALLY',88)\ndef_op('POP_EXCEPT',89)\n\nHAVE_ARGUMENT=90\n\nname_op('STORE_NAME',90)\nname_op('DELETE_NAME',91)\ndef_op('UNPACK_SEQUENCE',92)\njrel_op('FOR_ITER',93)\ndef_op('UNPACK_EX',94)\nname_op('STORE_ATTR',95)\nname_op('DELETE_ATTR',96)\nname_op('STORE_GLOBAL',97)\nname_op('DELETE_GLOBAL',98)\ndef_op('LOAD_CONST',100)\nhasconst.append(100)\nname_op('LOAD_NAME',101)\ndef_op('BUILD_TUPLE',102)\ndef_op('BUILD_LIST',103)\ndef_op('BUILD_SET',104)\ndef_op('BUILD_MAP',105)\nname_op('LOAD_ATTR',106)\ndef_op('COMPARE_OP',107)\nhascompare.append(107)\nname_op('IMPORT_NAME',108)\nname_op('IMPORT_FROM',109)\n\njrel_op('JUMP_FORWARD',110)\njabs_op('JUMP_IF_FALSE_OR_POP',111)\njabs_op('JUMP_IF_TRUE_OR_POP',112)\njabs_op('JUMP_ABSOLUTE',113)\njabs_op('POP_JUMP_IF_FALSE',114)\njabs_op('POP_JUMP_IF_TRUE',115)\n\nname_op('LOAD_GLOBAL',116)\n\njrel_op('SETUP_FINALLY',122)\n\ndef_op('LOAD_FAST',124)\nhaslocal.append(124)\ndef_op('STORE_FAST',125)\nhaslocal.append(125)\ndef_op('DELETE_FAST',126)\nhaslocal.append(126)\n\ndef_op('RAISE_VARARGS',130)\ndef_op('CALL_FUNCTION',131)\ndef_op('MAKE_FUNCTION',132)\ndef_op('BUILD_SLICE',133)\ndef_op('LOAD_CLOSURE',135)\nhasfree.append(135)\ndef_op('LOAD_DEREF',136)\nhasfree.append(136)\ndef_op('STORE_DEREF',137)\nhasfree.append(137)\ndef_op('DELETE_DEREF',138)\nhasfree.append(138)\n\ndef_op('CALL_FUNCTION_KW',141)\ndef_op('CALL_FUNCTION_EX',142)\n\njrel_op('SETUP_WITH',143)\n\ndef_op('LIST_APPEND',145)\ndef_op('SET_ADD',146)\ndef_op('MAP_ADD',147)\n\ndef_op('LOAD_CLASSDEREF',148)\nhasfree.append(148)\n\ndef_op('EXTENDED_ARG',144)\nEXTENDED_ARG=144\n\ndef_op('BUILD_LIST_UNPACK',149)\ndef_op('BUILD_MAP_UNPACK',150)\ndef_op('BUILD_MAP_UNPACK_WITH_CALL',151)\ndef_op('BUILD_TUPLE_UNPACK',152)\ndef_op('BUILD_SET_UNPACK',153)\n\njrel_op('SETUP_ASYNC_WITH',154)\n\ndef_op('FORMAT_VALUE',155)\ndef_op('BUILD_CONST_KEY_MAP',156)\ndef_op('BUILD_STRING',157)\ndef_op('BUILD_TUPLE_UNPACK_WITH_CALL',158)\n\nname_op('LOAD_METHOD',160)\ndef_op('CALL_METHOD',161)\njrel_op('CALL_FINALLY',162)\ndef_op('POP_FINALLY',163)\n\ndel def_op,name_op,jrel_op,jabs_op\n", ["_opcode"]], "re": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nr\"\"\"Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode whitespace characters.\n    \\S       Matches any non-whitespace character; equivalent to [^\\s].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match     Match a regular expression pattern to the beginning of a string.\n    fullmatch Match a regular expression pattern to all of a string.\n    search    Search a string for the presence of a pattern.\n    sub       Substitute occurrences of a pattern found in a string.\n    subn      Same as sub, but also return the number of substitutions made.\n    split     Split a string by the occurrences of a pattern.\n    findall   Find all occurrences of a pattern in a string.\n    finditer  Return an iterator yielding a Match object for each match.\n    compile   Compile a pattern into a Pattern object.\n    purge     Clear the regular expression cache.\n    escape    Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.\n\n\"\"\"\n\nimport enum\nimport sre_compile\nimport sre_parse\nimport functools\ntry :\n import _locale\nexcept ImportError:\n _locale=None\n \n \n \n__all__=[\n\"match\",\"fullmatch\",\"search\",\"sub\",\"subn\",\"split\",\n\"findall\",\"finditer\",\"compile\",\"purge\",\"template\",\"escape\",\n\"error\",\"Pattern\",\"Match\",\"A\",\"I\",\"L\",\"M\",\"S\",\"X\",\"U\",\n\"ASCII\",\"IGNORECASE\",\"LOCALE\",\"MULTILINE\",\"DOTALL\",\"VERBOSE\",\n\"UNICODE\",\n]\n\n__version__=\"2.2.1\"\n\nclass RegexFlag(enum.IntFlag):\n ASCII=A=sre_compile.SRE_FLAG_ASCII\n IGNORECASE=I=sre_compile.SRE_FLAG_IGNORECASE\n LOCALE=L=sre_compile.SRE_FLAG_LOCALE\n UNICODE=U=sre_compile.SRE_FLAG_UNICODE\n MULTILINE=M=sre_compile.SRE_FLAG_MULTILINE\n DOTALL=S=sre_compile.SRE_FLAG_DOTALL\n VERBOSE=X=sre_compile.SRE_FLAG_VERBOSE\n \n TEMPLATE=T=sre_compile.SRE_FLAG_TEMPLATE\n DEBUG=sre_compile.SRE_FLAG_DEBUG\n \n def __repr__(self):\n  if self._name_ is not None :\n   return f're.{self._name_}'\n  value=self._value_\n  members=[]\n  negative=value <0\n  if negative:\n   value=~value\n  for m in self.__class__:\n   if value&m._value_:\n    value &=~m._value_\n    members.append(f're.{m._name_}')\n  if value:\n   members.append(hex(value))\n  res='|'.join(members)\n  if negative:\n   if len(members)>1:\n    res=f'~({res})'\n   else :\n    res=f'~{res}'\n  return res\n __str__=object.__str__\n \nglobals().update(RegexFlag.__members__)\n\n\nerror=sre_compile.error\n\n\n\n\ndef match(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags).match(string)\n \ndef fullmatch(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags).fullmatch(string)\n \ndef search(pattern,string,flags=0):\n ''\n \n return _compile(pattern,flags).search(string)\n \ndef sub(pattern,repl,string,count=0,flags=0):\n ''\n\n\n\n\n \n return _compile(pattern,flags).sub(repl,string,count)\n \ndef subn(pattern,repl,string,count=0,flags=0):\n ''\n\n\n\n\n\n\n \n return _compile(pattern,flags).subn(repl,string,count)\n \ndef split(pattern,string,maxsplit=0,flags=0):\n ''\n\n\n\n\n\n \n return _compile(pattern,flags).split(string,maxsplit)\n \ndef findall(pattern,string,flags=0):\n ''\n\n\n\n\n\n \n return _compile(pattern,flags).findall(string)\n \ndef finditer(pattern,string,flags=0):\n ''\n\n\n \n return _compile(pattern,flags).finditer(string)\n \ndef compile(pattern,flags=0):\n ''\n return _compile(pattern,flags)\n \ndef purge():\n ''\n _cache.clear()\n _compile_repl.cache_clear()\n \ndef template(pattern,flags=0):\n ''\n return _compile(pattern,flags |T)\n \n \n \n \n \n \n_special_chars_map={i:'\\\\'+chr(i)for i in b'()[]{}?*+-|^$\\\\.&~# \\t\\n\\r\\v\\f'}\n\ndef escape(pattern):\n ''\n\n \n if isinstance(pattern,str):\n  return pattern.translate(_special_chars_map)\n else :\n  pattern=str(pattern,'latin1')\n  return pattern.translate(_special_chars_map).encode('latin1')\n  \nPattern=type(sre_compile.compile('',0))\nMatch=type(sre_compile.compile('',0).match(''))\n\n\n\n\n_cache={}\n\n_MAXCACHE=512\ndef _compile(pattern,flags):\n\n if isinstance(flags,RegexFlag):\n  flags=flags.value\n try :\n  return _cache[type(pattern),pattern,flags]\n except KeyError:\n  pass\n if isinstance(pattern,Pattern):\n  if flags:\n   raise ValueError(\n   \"cannot process flags argument with a compiled pattern\")\n  return pattern\n if not sre_compile.isstring(pattern):\n  raise TypeError(\"first argument must be string or compiled pattern\")\n p=sre_compile.compile(pattern,flags)\n if not (flags&DEBUG):\n  if len(_cache)>=_MAXCACHE:\n  \n   try :\n    del _cache[next(iter(_cache))]\n   except (StopIteration,RuntimeError,KeyError):\n    pass\n  _cache[type(pattern),pattern,flags]=p\n return p\n \n@functools.lru_cache(_MAXCACHE)\ndef _compile_repl(repl,pattern):\n\n return sre_parse.parse_template(repl,pattern)\n \ndef _expand(pattern,match,template):\n\n template=sre_parse.parse_template(template,pattern)\n return sre_parse.expand_template(template,match)\n \ndef _subx(pattern,template):\n\n template=_compile_repl(template,pattern)\n if not template[0]and len(template[1])==1:\n \n  return template[1][0]\n def filter(match,template=template):\n  return sre_parse.expand_template(template,match)\n return filter\n \n \n \nimport copyreg\n\ndef _pickle(p):\n return _compile,(p.pattern,p.flags)\n \ncopyreg.pickle(Pattern,_pickle,_compile)\n\n\n\n\nclass Scanner:\n def __init__(self,lexicon,flags=0):\n  from sre_constants import BRANCH,SUBPATTERN\n  if isinstance(flags,RegexFlag):\n   flags=flags.value\n  self.lexicon=lexicon\n  \n  p=[]\n  s=sre_parse.State()\n  s.flags=flags\n  for phrase,action in lexicon:\n   gid=s.opengroup()\n   p.append(sre_parse.SubPattern(s,[\n   (SUBPATTERN,(gid,0,0,sre_parse.parse(phrase,flags))),\n   ]))\n   s.closegroup(gid,p[-1])\n  p=sre_parse.SubPattern(s,[(BRANCH,(None ,p))])\n  self.scanner=sre_compile.compile(p)\n def scan(self,string):\n  result=[]\n  append=result.append\n  match=self.scanner.scanner(string).match\n  i=0\n  while True :\n   m=match()\n   if not m:\n    break\n   j=m.end()\n   if i ==j:\n    break\n   action=self.lexicon[m.lastindex -1][1]\n   if callable(action):\n    self.match=m\n    action=action(self,m.group())\n   if action is not None :\n    append(action)\n   i=j\n  return result,string[i:]\n", ["_locale", "copyreg", "enum", "functools", "sre_compile", "sre_constants", "sre_parse"]], "quopri": [".py", "#! /usr/bin/env python3\n\n\"\"\"Conversions to/from quoted-printable transport encoding as per RFC 1521.\"\"\"\n\n\n\n__all__=[\"encode\",\"decode\",\"encodestring\",\"decodestring\"]\n\nESCAPE=b'='\nMAXLINESIZE=76\nHEX=b'0123456789ABCDEF'\nEMPTYSTRING=b''\n\ntry :\n from binascii import a2b_qp,b2a_qp\nexcept ImportError:\n a2b_qp=None\n b2a_qp=None\n \n \ndef needsquoting(c,quotetabs,header):\n ''\n\n\n\n\n \n assert isinstance(c,bytes)\n if c in b' \\t':\n  return quotetabs\n  \n if c ==b'_':\n  return header\n return c ==ESCAPE or not (b' '<=c <=b'~')\n \ndef quote(c):\n ''\n assert isinstance(c,bytes)and len(c)==1\n c=ord(c)\n return ESCAPE+bytes((HEX[c //16],HEX[c %16]))\n \n \n \ndef encode(input,output,quotetabs,header=False ):\n ''\n\n\n\n\n\n \n \n if b2a_qp is not None :\n  data=input.read()\n  odata=b2a_qp(data,quotetabs=quotetabs,header=header)\n  output.write(odata)\n  return\n  \n def write(s,output=output,lineEnd=b'\\n'):\n \n \n  if s and s[-1:]in b' \\t':\n   output.write(s[:-1]+quote(s[-1:])+lineEnd)\n  elif s ==b'.':\n   output.write(quote(s)+lineEnd)\n  else :\n   output.write(s+lineEnd)\n   \n prevline=None\n while 1:\n  line=input.readline()\n  if not line:\n   break\n  outline=[]\n  \n  stripped=b''\n  if line[-1:]==b'\\n':\n   line=line[:-1]\n   stripped=b'\\n'\n   \n  for c in line:\n   c=bytes((c,))\n   if needsquoting(c,quotetabs,header):\n    c=quote(c)\n   if header and c ==b' ':\n    outline.append(b'_')\n   else :\n    outline.append(c)\n    \n  if prevline is not None :\n   write(prevline)\n   \n   \n  thisline=EMPTYSTRING.join(outline)\n  while len(thisline)>MAXLINESIZE:\n  \n  \n   write(thisline[:MAXLINESIZE -1],lineEnd=b'=\\n')\n   thisline=thisline[MAXLINESIZE -1:]\n   \n  prevline=thisline\n  \n if prevline is not None :\n  write(prevline,lineEnd=stripped)\n  \ndef encodestring(s,quotetabs=False ,header=False ):\n if b2a_qp is not None :\n  return b2a_qp(s,quotetabs=quotetabs,header=header)\n from io import BytesIO\n infp=BytesIO(s)\n outfp=BytesIO()\n encode(infp,outfp,quotetabs,header)\n return outfp.getvalue()\n \n \n \ndef decode(input,output,header=False ):\n ''\n\n \n \n if a2b_qp is not None :\n  data=input.read()\n  odata=a2b_qp(data,header=header)\n  output.write(odata)\n  return\n  \n new=b''\n while 1:\n  line=input.readline()\n  if not line:break\n  i,n=0,len(line)\n  if n >0 and line[n -1:n]==b'\\n':\n   partial=0 ;n=n -1\n   \n   while n >0 and line[n -1:n]in b\" \\t\\r\":\n    n=n -1\n  else :\n   partial=1\n  while i <n:\n   c=line[i:i+1]\n   if c ==b'_'and header:\n    new=new+b' ';i=i+1\n   elif c !=ESCAPE:\n    new=new+c ;i=i+1\n   elif i+1 ==n and not partial:\n    partial=1 ;break\n   elif i+1 <n and line[i+1:i+2]==ESCAPE:\n    new=new+ESCAPE ;i=i+2\n   elif i+2 <n and ishex(line[i+1:i+2])and ishex(line[i+2:i+3]):\n    new=new+bytes((unhex(line[i+1:i+3]),));i=i+3\n   else :\n    new=new+c ;i=i+1\n  if not partial:\n   output.write(new+b'\\n')\n   new=b''\n if new:\n  output.write(new)\n  \ndef decodestring(s,header=False ):\n if a2b_qp is not None :\n  return a2b_qp(s,header=header)\n from io import BytesIO\n infp=BytesIO(s)\n outfp=BytesIO()\n decode(infp,outfp,header=header)\n return outfp.getvalue()\n \n \n \n \ndef ishex(c):\n ''\n assert isinstance(c,bytes)\n return b'0'<=c <=b'9'or b'a'<=c <=b'f'or b'A'<=c <=b'F'\n \ndef unhex(s):\n ''\n bits=0\n for c in s:\n  c=bytes((c,))\n  if b'0'<=c <=b'9':\n   i=ord('0')\n  elif b'a'<=c <=b'f':\n   i=ord('a')-10\n  elif b'A'<=c <=b'F':\n   i=ord(b'A')-10\n  else :\n   assert False ,\"non-hex digit \"+repr(c)\n  bits=bits *16+(ord(c)-i)\n return bits\n \n \n \ndef main():\n import sys\n import getopt\n try :\n  opts,args=getopt.getopt(sys.argv[1:],'td')\n except getopt.error as msg:\n  sys.stdout=sys.stderr\n  print(msg)\n  print(\"usage: quopri [-t | -d] [file] ...\")\n  print(\"-t: quote tabs\")\n  print(\"-d: decode; default encode\")\n  sys.exit(2)\n deco=0\n tabs=0\n for o,a in opts:\n  if o =='-t':tabs=1\n  if o =='-d':deco=1\n if tabs and deco:\n  sys.stdout=sys.stderr\n  print(\"-t and -d are mutually exclusive\")\n  sys.exit(2)\n if not args:args=['-']\n sts=0\n for file in args:\n  if file =='-':\n   fp=sys.stdin.buffer\n  else :\n   try :\n    fp=open(file,\"rb\")\n   except OSError as msg:\n    sys.stderr.write(\"%s: can't open (%s)\\n\"%(file,msg))\n    sts=1\n    continue\n  try :\n   if deco:\n    decode(fp,sys.stdout.buffer)\n   else :\n    encode(fp,sys.stdout.buffer,tabs)\n  finally :\n   if file !='-':\n    fp.close()\n if sts:\n  sys.exit(sts)\n  \n  \n  \nif __name__ =='__main__':\n main()\n", ["binascii", "getopt", "io", "sys"]], "sre_parse": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\"Internal support module for sre\"\"\"\n\n\n\nfrom sre_constants import *\n\nSPECIAL_CHARS=\".\\\\[{()*+?^$|\"\nREPEAT_CHARS=\"*+?{\"\n\nDIGITS=frozenset(\"0123456789\")\n\nOCTDIGITS=frozenset(\"01234567\")\nHEXDIGITS=frozenset(\"0123456789abcdefABCDEF\")\nASCIILETTERS=frozenset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\nWHITESPACE=frozenset(\" \\t\\n\\r\\v\\f\")\n\n_REPEATCODES=frozenset({MIN_REPEAT,MAX_REPEAT})\n_UNITCODES=frozenset({ANY,RANGE,IN,LITERAL,NOT_LITERAL,CATEGORY})\n\nESCAPES={\nr\"\\a\":(LITERAL,ord(\"\\a\")),\nr\"\\b\":(LITERAL,ord(\"\\b\")),\nr\"\\f\":(LITERAL,ord(\"\\f\")),\nr\"\\n\":(LITERAL,ord(\"\\n\")),\nr\"\\r\":(LITERAL,ord(\"\\r\")),\nr\"\\t\":(LITERAL,ord(\"\\t\")),\nr\"\\v\":(LITERAL,ord(\"\\v\")),\nr\"\\\\\":(LITERAL,ord(\"\\\\\"))\n}\n\nCATEGORIES={\nr\"\\A\":(AT,AT_BEGINNING_STRING),\nr\"\\b\":(AT,AT_BOUNDARY),\nr\"\\B\":(AT,AT_NON_BOUNDARY),\nr\"\\d\":(IN,[(CATEGORY,CATEGORY_DIGIT)]),\nr\"\\D\":(IN,[(CATEGORY,CATEGORY_NOT_DIGIT)]),\nr\"\\s\":(IN,[(CATEGORY,CATEGORY_SPACE)]),\nr\"\\S\":(IN,[(CATEGORY,CATEGORY_NOT_SPACE)]),\nr\"\\w\":(IN,[(CATEGORY,CATEGORY_WORD)]),\nr\"\\W\":(IN,[(CATEGORY,CATEGORY_NOT_WORD)]),\nr\"\\Z\":(AT,AT_END_STRING),\n}\n\nFLAGS={\n\n\"i\":SRE_FLAG_IGNORECASE,\n\"L\":SRE_FLAG_LOCALE,\n\"m\":SRE_FLAG_MULTILINE,\n\"s\":SRE_FLAG_DOTALL,\n\"x\":SRE_FLAG_VERBOSE,\n\n\"a\":SRE_FLAG_ASCII,\n\"t\":SRE_FLAG_TEMPLATE,\n\"u\":SRE_FLAG_UNICODE,\n}\n\nTYPE_FLAGS=SRE_FLAG_ASCII |SRE_FLAG_LOCALE |SRE_FLAG_UNICODE\nGLOBAL_FLAGS=SRE_FLAG_DEBUG |SRE_FLAG_TEMPLATE\n\nclass Verbose(Exception):\n pass\n \nclass State:\n\n def __init__(self):\n  self.flags=0\n  self.groupdict={}\n  self.groupwidths=[None ]\n  self.lookbehindgroups=None\n @property\n def groups(self):\n  return len(self.groupwidths)\n def opengroup(self,name=None ):\n  gid=self.groups\n  self.groupwidths.append(None )\n  if self.groups >MAXGROUPS:\n   raise error(\"too many groups\")\n  if name is not None :\n   ogid=self.groupdict.get(name,None )\n   if ogid is not None :\n    raise error(\"redefinition of group name %r as group %d; \"\n    \"was group %d\"%(name,gid,ogid))\n   self.groupdict[name]=gid\n  return gid\n def closegroup(self,gid,p):\n  self.groupwidths[gid]=p.getwidth()\n def checkgroup(self,gid):\n  return gid <self.groups and self.groupwidths[gid]is not None\n  \n def checklookbehindgroup(self,gid,source):\n  if self.lookbehindgroups is not None :\n   if not self.checkgroup(gid):\n    raise source.error('cannot refer to an open group')\n   if gid >=self.lookbehindgroups:\n    raise source.error('cannot refer to group defined in the same '\n    'lookbehind subpattern')\n    \nclass SubPattern:\n\n def __init__(self,state,data=None ):\n  self.state=state\n  if data is None :\n   data=[]\n  self.data=data\n  self.width=None\n  \n def dump(self,level=0):\n  nl=True\n  seqtypes=(tuple,list)\n  for op,av in self.data:\n   print(level *\"  \"+str(op),end='')\n   if op is IN:\n   \n    print()\n    for op,a in av:\n     print((level+1)*\"  \"+str(op),a)\n   elif op is BRANCH:\n    print()\n    for i,a in enumerate(av[1]):\n     if i:\n      print(level *\"  \"+\"OR\")\n     a.dump(level+1)\n   elif op is GROUPREF_EXISTS:\n    condgroup,item_yes,item_no=av\n    print('',condgroup)\n    item_yes.dump(level+1)\n    if item_no:\n     print(level *\"  \"+\"ELSE\")\n     item_no.dump(level+1)\n   elif isinstance(av,seqtypes):\n    nl=False\n    for a in av:\n     if isinstance(a,SubPattern):\n      if not nl:\n       print()\n      a.dump(level+1)\n      nl=True\n     else :\n      if not nl:\n       print(' ',end='')\n      print(a,end='')\n      nl=False\n    if not nl:\n     print()\n   else :\n    print('',av)\n def __repr__(self):\n  return repr(self.data)\n def __len__(self):\n  return len(self.data)\n def __delitem__(self,index):\n  del self.data[index]\n def __getitem__(self,index):\n  if isinstance(index,slice):\n   return SubPattern(self.state,self.data[index])\n  return self.data[index]\n def __setitem__(self,index,code):\n  self.data[index]=code\n def insert(self,index,code):\n  self.data.insert(index,code)\n def append(self,code):\n  self.data.append(code)\n def getwidth(self):\n \n  if self.width is not None :\n   return self.width\n  lo=hi=0\n  for op,av in self.data:\n   if op is BRANCH:\n    i=MAXREPEAT -1\n    j=0\n    for av in av[1]:\n     l,h=av.getwidth()\n     i=min(i,l)\n     j=max(j,h)\n    lo=lo+i\n    hi=hi+j\n   elif op is CALL:\n    i,j=av.getwidth()\n    lo=lo+i\n    hi=hi+j\n   elif op is SUBPATTERN:\n    i,j=av[-1].getwidth()\n    lo=lo+i\n    hi=hi+j\n   elif op in _REPEATCODES:\n    i,j=av[2].getwidth()\n    lo=lo+i *av[0]\n    hi=hi+j *av[1]\n   elif op in _UNITCODES:\n    lo=lo+1\n    hi=hi+1\n   elif op is GROUPREF:\n    i,j=self.state.groupwidths[av]\n    lo=lo+i\n    hi=hi+j\n   elif op is GROUPREF_EXISTS:\n    i,j=av[1].getwidth()\n    if av[2]is not None :\n     l,h=av[2].getwidth()\n     i=min(i,l)\n     j=max(j,h)\n    else :\n     i=0\n    lo=lo+i\n    hi=hi+j\n   elif op is SUCCESS:\n    break\n  self.width=min(lo,MAXREPEAT -1),min(hi,MAXREPEAT)\n  return self.width\n  \nclass Tokenizer:\n def __init__(self,string):\n  self.istext=isinstance(string,str)\n  self.string=string\n  if not self.istext:\n   string=str(string,'latin1')\n  self.decoded_string=string\n  self.index=0\n  self.next=None\n  self.__next()\n def __next(self):\n  index=self.index\n  try :\n   char=self.decoded_string[index]\n  except IndexError:\n   self.next=None\n   return\n  if char ==\"\\\\\":\n   index +=1\n   try :\n    char +=self.decoded_string[index]\n   except IndexError:\n    raise error(\"bad escape (end of pattern)\",\n    self.string,len(self.string)-1)from None\n  self.index=index+1\n  self.next=char\n def match(self,char):\n  if char ==self.next:\n   self.__next()\n   return True\n  return False\n def get(self):\n  this=self.next\n  self.__next()\n  return this\n def getwhile(self,n,charset):\n  result=''\n  for _ in range(n):\n   c=self.next\n   if c not in charset:\n    break\n   result +=c\n   self.__next()\n  return result\n def getuntil(self,terminator,name):\n  result=''\n  while True :\n   c=self.next\n   self.__next()\n   if c is None :\n    if not result:\n     raise self.error(\"missing \"+name)\n    raise self.error(\"missing %s, unterminated name\"%terminator,\n    len(result))\n   if c ==terminator:\n    if not result:\n     raise self.error(\"missing \"+name,1)\n    break\n   result +=c\n  return result\n @property\n def pos(self):\n  return self.index -len(self.next or '')\n def tell(self):\n  return self.index -len(self.next or '')\n def seek(self,index):\n  self.index=index\n  self.__next()\n  \n def error(self,msg,offset=0):\n  return error(msg,self.string,self.tell()-offset)\n  \ndef _class_escape(source,escape):\n\n code=ESCAPES.get(escape)\n if code:\n  return code\n code=CATEGORIES.get(escape)\n if code and code[0]is IN:\n  return code\n try :\n  c=escape[1:2]\n  if c ==\"x\":\n  \n   escape +=source.getwhile(2,HEXDIGITS)\n   if len(escape)!=4:\n    raise source.error(\"incomplete escape %s\"%escape,len(escape))\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"u\"and source.istext:\n  \n   escape +=source.getwhile(4,HEXDIGITS)\n   if len(escape)!=6:\n    raise source.error(\"incomplete escape %s\"%escape,len(escape))\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"U\"and source.istext:\n  \n   escape +=source.getwhile(8,HEXDIGITS)\n   if len(escape)!=10:\n    raise source.error(\"incomplete escape %s\"%escape,len(escape))\n   c=int(escape[2:],16)\n   chr(c)\n   return LITERAL,c\n  elif c ==\"N\"and source.istext:\n   import unicodedata\n   \n   if not source.match('{'):\n    raise source.error(\"missing {\")\n   charname=source.getuntil('}','character name')\n   try :\n    c=ord(unicodedata.lookup(charname))\n   except KeyError:\n    raise source.error(\"undefined character name %r\"%charname,\n    len(charname)+len(r'\\N{}'))\n   return LITERAL,c\n  elif c in OCTDIGITS:\n  \n   escape +=source.getwhile(2,OCTDIGITS)\n   c=int(escape[1:],8)\n   if c >0o377:\n    raise source.error('octal escape value %s outside of '\n    'range 0-0o377'%escape,len(escape))\n   return LITERAL,c\n  elif c in DIGITS:\n   raise ValueError\n  if len(escape)==2:\n   if c in ASCIILETTERS:\n    raise source.error('bad escape %s'%escape,len(escape))\n   return LITERAL,ord(escape[1])\n except ValueError:\n  pass\n raise source.error(\"bad escape %s\"%escape,len(escape))\n \ndef _escape(source,escape,state):\n\n code=CATEGORIES.get(escape)\n if code:\n  return code\n code=ESCAPES.get(escape)\n if code:\n  return code\n try :\n  c=escape[1:2]\n  if c ==\"x\":\n  \n   escape +=source.getwhile(2,HEXDIGITS)\n   if len(escape)!=4:\n    raise source.error(\"incomplete escape %s\"%escape,len(escape))\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"u\"and source.istext:\n  \n   escape +=source.getwhile(4,HEXDIGITS)\n   if len(escape)!=6:\n    raise source.error(\"incomplete escape %s\"%escape,len(escape))\n   return LITERAL,int(escape[2:],16)\n  elif c ==\"U\"and source.istext:\n  \n   escape +=source.getwhile(8,HEXDIGITS)\n   if len(escape)!=10:\n    raise source.error(\"incomplete escape %s\"%escape,len(escape))\n   c=int(escape[2:],16)\n   chr(c)\n   return LITERAL,c\n  elif c ==\"N\"and source.istext:\n   import unicodedata\n   \n   if not source.match('{'):\n    raise source.error(\"missing {\")\n   charname=source.getuntil('}','character name')\n   try :\n    c=ord(unicodedata.lookup(charname))\n   except KeyError:\n    raise source.error(\"undefined character name %r\"%charname,\n    len(charname)+len(r'\\N{}'))\n   return LITERAL,c\n  elif c ==\"0\":\n  \n   escape +=source.getwhile(2,OCTDIGITS)\n   return LITERAL,int(escape[1:],8)\n  elif c in DIGITS:\n  \n   if source.next in DIGITS:\n    escape +=source.get()\n    if (escape[1]in OCTDIGITS and escape[2]in OCTDIGITS and\n    source.next in OCTDIGITS):\n    \n     escape +=source.get()\n     c=int(escape[1:],8)\n     if c >0o377:\n      raise source.error('octal escape value %s outside of '\n      'range 0-0o377'%escape,\n      len(escape))\n     return LITERAL,c\n     \n   group=int(escape[1:])\n   if group <state.groups:\n    if not state.checkgroup(group):\n     raise source.error(\"cannot refer to an open group\",\n     len(escape))\n    state.checklookbehindgroup(group,source)\n    return GROUPREF,group\n   raise source.error(\"invalid group reference %d\"%group,len(escape)-1)\n  if len(escape)==2:\n   if c in ASCIILETTERS:\n    raise source.error(\"bad escape %s\"%escape,len(escape))\n   return LITERAL,ord(escape[1])\n except ValueError:\n  pass\n raise source.error(\"bad escape %s\"%escape,len(escape))\n \ndef _uniq(items):\n return list(dict.fromkeys(items))\n \ndef _parse_sub(source,state,verbose,nested):\n\n\n items=[]\n itemsappend=items.append\n sourcematch=source.match\n start=source.tell()\n while True :\n  itemsappend(_parse(source,state,verbose,nested+1,\n  not nested and not items))\n  if not sourcematch(\"|\"):\n   break\n   \n if len(items)==1:\n  return items[0]\n  \n subpattern=SubPattern(state)\n \n \n while True :\n  prefix=None\n  for item in items:\n   if not item:\n    break\n   if prefix is None :\n    prefix=item[0]\n   elif item[0]!=prefix:\n    break\n  else :\n  \n  \n   for item in items:\n    del item[0]\n   subpattern.append(prefix)\n   continue\n  break\n  \n  \n set=[]\n for item in items:\n  if len(item)!=1:\n   break\n  op,av=item[0]\n  if op is LITERAL:\n   set.append((op,av))\n  elif op is IN and av[0][0]is not NEGATE:\n   set.extend(av)\n  else :\n   break\n else :\n \n \n  subpattern.append((IN,_uniq(set)))\n  return subpattern\n  \n subpattern.append((BRANCH,(None ,items)))\n return subpattern\n \ndef _parse(source,state,verbose,nested,first=False ):\n\n subpattern=SubPattern(state)\n \n \n subpatternappend=subpattern.append\n sourceget=source.get\n sourcematch=source.match\n _len=len\n _ord=ord\n \n while True :\n \n  this=source.next\n  if this is None :\n   break\n  if this in \"|)\":\n   break\n  sourceget()\n  \n  if verbose:\n  \n   if this in WHITESPACE:\n    continue\n   if this ==\"#\":\n    while True :\n     this=sourceget()\n     if this is None or this ==\"\\n\":\n      break\n    continue\n    \n  if this[0]==\"\\\\\":\n   code=_escape(source,this,state)\n   subpatternappend(code)\n   \n  elif this not in SPECIAL_CHARS:\n   subpatternappend((LITERAL,_ord(this)))\n   \n  elif this ==\"[\":\n   here=source.tell()-1\n   \n   set=[]\n   setappend=set.append\n   \n   \n   if source.next =='[':\n    import warnings\n    warnings.warn(\n    'Possible nested set at position %d'%source.tell(),\n    FutureWarning,stacklevel=nested+6\n    )\n   negate=sourcematch(\"^\")\n   \n   while True :\n    this=sourceget()\n    if this is None :\n     raise source.error(\"unterminated character set\",\n     source.tell()-here)\n    if this ==\"]\"and set:\n     break\n    elif this[0]==\"\\\\\":\n     code1=_class_escape(source,this)\n    else :\n     if set and this in '-&~|'and source.next ==this:\n      import warnings\n      warnings.warn(\n      'Possible set %s at position %d'%(\n      'difference'if this =='-'else\n      'intersection'if this =='&'else\n      'symmetric difference'if this =='~'else\n      'union',\n      source.tell()-1),\n      FutureWarning,stacklevel=nested+6\n      )\n     code1=LITERAL,_ord(this)\n    if sourcematch(\"-\"):\n    \n     that=sourceget()\n     if that is None :\n      raise source.error(\"unterminated character set\",\n      source.tell()-here)\n     if that ==\"]\":\n      if code1[0]is IN:\n       code1=code1[1][0]\n      setappend(code1)\n      setappend((LITERAL,_ord(\"-\")))\n      break\n     if that[0]==\"\\\\\":\n      code2=_class_escape(source,that)\n     else :\n      if that =='-':\n       import warnings\n       warnings.warn(\n       'Possible set difference at position %d'%(\n       source.tell()-2),\n       FutureWarning,stacklevel=nested+6\n       )\n      code2=LITERAL,_ord(that)\n     if code1[0]!=LITERAL or code2[0]!=LITERAL:\n      msg=\"bad character range %s-%s\"%(this,that)\n      raise source.error(msg,len(this)+1+len(that))\n     lo=code1[1]\n     hi=code2[1]\n     if hi <lo:\n      msg=\"bad character range %s-%s\"%(this,that)\n      raise source.error(msg,len(this)+1+len(that))\n     setappend((RANGE,(lo,hi)))\n    else :\n     if code1[0]is IN:\n      code1=code1[1][0]\n     setappend(code1)\n     \n   set=_uniq(set)\n   \n   if _len(set)==1 and set[0][0]is LITERAL:\n   \n    if negate:\n     subpatternappend((NOT_LITERAL,set[0][1]))\n    else :\n     subpatternappend(set[0])\n   else :\n    if negate:\n     set.insert(0,(NEGATE,None ))\n     \n     \n    subpatternappend((IN,set))\n    \n  elif this in REPEAT_CHARS:\n  \n   here=source.tell()\n   if this ==\"?\":\n    min,max=0,1\n   elif this ==\"*\":\n    min,max=0,MAXREPEAT\n    \n   elif this ==\"+\":\n    min,max=1,MAXREPEAT\n   elif this ==\"{\":\n    if source.next ==\"}\":\n     subpatternappend((LITERAL,_ord(this)))\n     continue\n     \n    min,max=0,MAXREPEAT\n    lo=hi=\"\"\n    while source.next in DIGITS:\n     lo +=sourceget()\n    if sourcematch(\",\"):\n     while source.next in DIGITS:\n      hi +=sourceget()\n    else :\n     hi=lo\n    if not sourcematch(\"}\"):\n     subpatternappend((LITERAL,_ord(this)))\n     source.seek(here)\n     continue\n     \n    if lo:\n     min=int(lo)\n     if min >=MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n    if hi:\n     max=int(hi)\n     if max >=MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n     if max <min:\n      raise source.error(\"min repeat greater than max repeat\",\n      source.tell()-here)\n   else :\n    raise AssertionError(\"unsupported quantifier %r\"%(char,))\n    \n   if subpattern:\n    item=subpattern[-1:]\n   else :\n    item=None\n   if not item or item[0][0]is AT:\n    raise source.error(\"nothing to repeat\",\n    source.tell()-here+len(this))\n   if item[0][0]in _REPEATCODES:\n    raise source.error(\"multiple repeat\",\n    source.tell()-here+len(this))\n   if item[0][0]is SUBPATTERN:\n    group,add_flags,del_flags,p=item[0][1]\n    if group is None and not add_flags and not del_flags:\n     item=p\n   if sourcematch(\"?\"):\n    subpattern[-1]=(MIN_REPEAT,(min,max,item))\n   else :\n    subpattern[-1]=(MAX_REPEAT,(min,max,item))\n    \n  elif this ==\".\":\n   subpatternappend((ANY,None ))\n   \n  elif this ==\"(\":\n   start=source.tell()-1\n   group=True\n   name=None\n   add_flags=0\n   del_flags=0\n   if sourcematch(\"?\"):\n   \n    char=sourceget()\n    if char is None :\n     raise source.error(\"unexpected end of pattern\")\n    if char ==\"P\":\n    \n     if sourcematch(\"<\"):\n     \n      name=source.getuntil(\">\",\"group name\")\n      if not name.isidentifier():\n       msg=\"bad character in group name %r\"%name\n       raise source.error(msg,len(name)+1)\n     elif sourcematch(\"=\"):\n     \n      name=source.getuntil(\")\",\"group name\")\n      if not name.isidentifier():\n       msg=\"bad character in group name %r\"%name\n       raise source.error(msg,len(name)+1)\n      gid=state.groupdict.get(name)\n      if gid is None :\n       msg=\"unknown group name %r\"%name\n       raise source.error(msg,len(name)+1)\n      if not state.checkgroup(gid):\n       raise source.error(\"cannot refer to an open group\",\n       len(name)+1)\n      state.checklookbehindgroup(gid,source)\n      subpatternappend((GROUPREF,gid))\n      continue\n      \n     else :\n      char=sourceget()\n      if char is None :\n       raise source.error(\"unexpected end of pattern\")\n      raise source.error(\"unknown extension ?P\"+char,\n      len(char)+2)\n    elif char ==\":\":\n    \n     group=None\n    elif char ==\"#\":\n    \n     while True :\n      if source.next is None :\n       raise source.error(\"missing ), unterminated comment\",\n       source.tell()-start)\n      if sourceget()==\")\":\n       break\n     continue\n     \n    elif char in \"=!<\":\n    \n     dir=1\n     if char ==\"<\":\n      char=sourceget()\n      if char is None :\n       raise source.error(\"unexpected end of pattern\")\n      if char not in \"=!\":\n       raise source.error(\"unknown extension ?<\"+char,\n       len(char)+2)\n      dir=-1\n      lookbehindgroups=state.lookbehindgroups\n      if lookbehindgroups is None :\n       state.lookbehindgroups=state.groups\n     p=_parse_sub(source,state,verbose,nested+1)\n     if dir <0:\n      if lookbehindgroups is None :\n       state.lookbehindgroups=None\n     if not sourcematch(\")\"):\n      raise source.error(\"missing ), unterminated subpattern\",\n      source.tell()-start)\n     if char ==\"=\":\n      subpatternappend((ASSERT,(dir,p)))\n     else :\n      subpatternappend((ASSERT_NOT,(dir,p)))\n     continue\n     \n    elif char ==\"(\":\n    \n     condname=source.getuntil(\")\",\"group name\")\n     if condname.isidentifier():\n      condgroup=state.groupdict.get(condname)\n      if condgroup is None :\n       msg=\"unknown group name %r\"%condname\n       raise source.error(msg,len(condname)+1)\n     else :\n      try :\n       condgroup=int(condname)\n       if condgroup <0:\n        raise ValueError\n      except ValueError:\n       msg=\"bad character in group name %r\"%condname\n       raise source.error(msg,len(condname)+1)from None\n      if not condgroup:\n       raise source.error(\"bad group number\",\n       len(condname)+1)\n      if condgroup >=MAXGROUPS:\n       msg=\"invalid group reference %d\"%condgroup\n       raise source.error(msg,len(condname)+1)\n     state.checklookbehindgroup(condgroup,source)\n     item_yes=_parse(source,state,verbose,nested+1)\n     if source.match(\"|\"):\n      item_no=_parse(source,state,verbose,nested+1)\n      if source.next ==\"|\":\n       raise source.error(\"conditional backref with more than two branches\")\n     else :\n      item_no=None\n     if not source.match(\")\"):\n      raise source.error(\"missing ), unterminated subpattern\",\n      source.tell()-start)\n     subpatternappend((GROUPREF_EXISTS,(condgroup,item_yes,item_no)))\n     continue\n     \n    elif char in FLAGS or char ==\"-\":\n    \n     flags=_parse_flags(source,state,char)\n     if flags is None :\n      if not first or subpattern:\n       import warnings\n       warnings.warn(\n       'Flags not at the start of the expression %r%s'%(\n       source.string[:20],\n       ' (truncated)'if len(source.string)>20 else '',\n       ),\n       DeprecationWarning,stacklevel=nested+6\n       )\n      if (state.flags&SRE_FLAG_VERBOSE)and not verbose:\n       raise Verbose\n      continue\n      \n     add_flags,del_flags=flags\n     group=None\n    else :\n     raise source.error(\"unknown extension ?\"+char,\n     len(char)+1)\n     \n     \n   if group is not None :\n    try :\n     group=state.opengroup(name)\n    except error as err:\n     raise source.error(err.msg,len(name)+1)from None\n   sub_verbose=((verbose or (add_flags&SRE_FLAG_VERBOSE))and\n   not (del_flags&SRE_FLAG_VERBOSE))\n   p=_parse_sub(source,state,sub_verbose,nested+1)\n   if not source.match(\")\"):\n    raise source.error(\"missing ), unterminated subpattern\",\n    source.tell()-start)\n   if group is not None :\n    state.closegroup(group,p)\n   subpatternappend((SUBPATTERN,(group,add_flags,del_flags,p)))\n   \n  elif this ==\"^\":\n   subpatternappend((AT,AT_BEGINNING))\n   \n  elif this ==\"$\":\n   subpatternappend((AT,AT_END))\n   \n  else :\n   raise AssertionError(\"unsupported special character %r\"%(char,))\n   \n   \n for i in range(len(subpattern))[::-1]:\n  op,av=subpattern[i]\n  if op is SUBPATTERN:\n   group,add_flags,del_flags,p=av\n   if group is None and not add_flags and not del_flags:\n    subpattern[i:i+1]=p\n    \n return subpattern\n \ndef _parse_flags(source,state,char):\n sourceget=source.get\n add_flags=0\n del_flags=0\n if char !=\"-\":\n  while True :\n   flag=FLAGS[char]\n   if source.istext:\n    if char =='L':\n     msg=\"bad inline flags: cannot use 'L' flag with a str pattern\"\n     raise source.error(msg)\n   else :\n    if char =='u':\n     msg=\"bad inline flags: cannot use 'u' flag with a bytes pattern\"\n     raise source.error(msg)\n   add_flags |=flag\n   if (flag&TYPE_FLAGS)and (add_flags&TYPE_FLAGS)!=flag:\n    msg=\"bad inline flags: flags 'a', 'u' and 'L' are incompatible\"\n    raise source.error(msg)\n   char=sourceget()\n   if char is None :\n    raise source.error(\"missing -, : or )\")\n   if char in \")-:\":\n    break\n   if char not in FLAGS:\n    msg=\"unknown flag\"if char.isalpha()else \"missing -, : or )\"\n    raise source.error(msg,len(char))\n if char ==\")\":\n  state.flags |=add_flags\n  return None\n if add_flags&GLOBAL_FLAGS:\n  raise source.error(\"bad inline flags: cannot turn on global flag\",1)\n if char ==\"-\":\n  char=sourceget()\n  if char is None :\n   raise source.error(\"missing flag\")\n  if char not in FLAGS:\n   msg=\"unknown flag\"if char.isalpha()else \"missing flag\"\n   raise source.error(msg,len(char))\n  while True :\n   flag=FLAGS[char]\n   if flag&TYPE_FLAGS:\n    msg=\"bad inline flags: cannot turn off flags 'a', 'u' and 'L'\"\n    raise source.error(msg)\n   del_flags |=flag\n   char=sourceget()\n   if char is None :\n    raise source.error(\"missing :\")\n   if char ==\":\":\n    break\n   if char not in FLAGS:\n    msg=\"unknown flag\"if char.isalpha()else \"missing :\"\n    raise source.error(msg,len(char))\n assert char ==\":\"\n if del_flags&GLOBAL_FLAGS:\n  raise source.error(\"bad inline flags: cannot turn off global flag\",1)\n if add_flags&del_flags:\n  raise source.error(\"bad inline flags: flag turned on and off\",1)\n return add_flags,del_flags\n \ndef fix_flags(src,flags):\n\n if isinstance(src,str):\n  if flags&SRE_FLAG_LOCALE:\n   raise ValueError(\"cannot use LOCALE flag with a str pattern\")\n  if not flags&SRE_FLAG_ASCII:\n   flags |=SRE_FLAG_UNICODE\n  elif flags&SRE_FLAG_UNICODE:\n   raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n else :\n  if flags&SRE_FLAG_UNICODE:\n   raise ValueError(\"cannot use UNICODE flag with a bytes pattern\")\n  if flags&SRE_FLAG_LOCALE and flags&SRE_FLAG_ASCII:\n   raise ValueError(\"ASCII and LOCALE flags are incompatible\")\n return flags\n \ndef parse(str,flags=0,state=None ):\n\n\n source=Tokenizer(str)\n \n if state is None :\n  state=State()\n state.flags=flags\n state.str=str\n \n try :\n  p=_parse_sub(source,state,flags&SRE_FLAG_VERBOSE,0)\n except Verbose:\n \n \n  state=State()\n  state.flags=flags |SRE_FLAG_VERBOSE\n  state.str=str\n  source.seek(0)\n  p=_parse_sub(source,state,True ,0)\n  \n p.state.flags=fix_flags(str,p.state.flags)\n \n if source.next is not None :\n  assert source.next ==\")\"\n  raise source.error(\"unbalanced parenthesis\")\n  \n if flags&SRE_FLAG_DEBUG:\n  p.dump()\n  \n return p\n \ndef parse_template(source,state):\n\n\n s=Tokenizer(source)\n sget=s.get\n groups=[]\n literals=[]\n literal=[]\n lappend=literal.append\n def addgroup(index,pos):\n  if index >state.groups:\n   raise s.error(\"invalid group reference %d\"%index,pos)\n  if literal:\n   literals.append(''.join(literal))\n   del literal[:]\n  groups.append((len(literals),index))\n  literals.append(None )\n groupindex=state.groupindex\n while True :\n  this=sget()\n  if this is None :\n   break\n  if this[0]==\"\\\\\":\n  \n   c=this[1]\n   if c ==\"g\":\n    name=\"\"\n    if not s.match(\"<\"):\n     raise s.error(\"missing <\")\n    name=s.getuntil(\">\",\"group name\")\n    if name.isidentifier():\n     try :\n      index=groupindex[name]\n     except KeyError:\n      raise IndexError(\"unknown group name %r\"%name)\n    else :\n     try :\n      index=int(name)\n      if index <0:\n       raise ValueError\n     except ValueError:\n      raise s.error(\"bad character in group name %r\"%name,\n      len(name)+1)from None\n     if index >=MAXGROUPS:\n      raise s.error(\"invalid group reference %d\"%index,\n      len(name)+1)\n    addgroup(index,len(name)+1)\n   elif c ==\"0\":\n    if s.next in OCTDIGITS:\n     this +=sget()\n     if s.next in OCTDIGITS:\n      this +=sget()\n    lappend(chr(int(this[1:],8)&0xff))\n   elif c in DIGITS:\n    isoctal=False\n    if s.next in DIGITS:\n     this +=sget()\n     if (c in OCTDIGITS and this[2]in OCTDIGITS and\n     s.next in OCTDIGITS):\n      this +=sget()\n      isoctal=True\n      c=int(this[1:],8)\n      if c >0o377:\n       raise s.error('octal escape value %s outside of '\n       'range 0-0o377'%this,len(this))\n      lappend(chr(c))\n    if not isoctal:\n     addgroup(int(this[1:]),len(this)-1)\n   else :\n    try :\n     this=chr(ESCAPES[this][1])\n    except KeyError:\n     if c in ASCIILETTERS:\n      raise s.error('bad escape %s'%this,len(this))\n    lappend(this)\n  else :\n   lappend(this)\n if literal:\n  literals.append(''.join(literal))\n if not isinstance(source,str):\n \n \n  literals=[None if s is None else s.encode('latin-1')for s in literals]\n return groups,literals\n \ndef expand_template(template,match):\n g=match.group\n empty=match.string[:0]\n groups,literals=template\n literals=literals[:]\n try :\n  for index,group in groups:\n   literals[index]=g(group)or empty\n except IndexError:\n  raise error(\"invalid group reference %d\"%index)\n return empty.join(literals)\n", ["sre_constants", "unicodedata", "warnings"]], "_imp": [".py", "''\nimport sys\n\ndef _fix_co_filename(*args,**kw):\n ''\n\n\n\n \n pass\n \ndef acquire_lock(*args,**kw):\n ''\n\n \n pass\n \ncheck_hash_based_pycs=\"\"\"default\"\"\"\n\ndef create_builtin(spec):\n ''\n return __import__(spec.name)\n \ndef create_dynamic(*args,**kw):\n ''\n pass\n \ndef exec_builtin(*args,**kw):\n ''\n pass\n \ndef exec_dynamic(*args,**kw):\n ''\n pass\n \ndef extension_suffixes(*args,**kw):\n ''\n return []\n \ndef get_frozen_object(*args,**kw):\n ''\n pass\n \ndef init_frozen(*args,**kw):\n ''\n pass\n \ndef is_builtin(module_name):\n\n return module_name in __BRYTHON__.builtin_module_names\n \ndef is_frozen(*args,**kw):\n ''\n return False\n \ndef is_frozen_package(*args,**kw):\n ''\n pass\n \ndef lock_held(*args,**kw):\n ''\n \n return False\n \ndef release_lock(*args,**kw):\n ''\n \n pass\n \ndef source_hash(*args,**kw):\n pass\n", ["sys"]], "browser": [".py", "", [], 1], "browser.webcomponent": [".py", "from _webcomponent import *\n", ["_webcomponent"]], "browser.template": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport tb as traceback\nfrom browser import document,html\n\n\n\nvoid_elements=[\"AREA\",\"BASE\",\"BR\",\"COL\",\"EMBED\",\"HR\",\"IMG\",\"INPUT\",\n\"LINK\",\"META\",\"PARAM\",\"SOURCE\",\"TRACK\",\"WBR\"]\n\ndef copy(obj):\n if isinstance(obj,dict):\n  res={}\n  for key,value in obj.items():\n   res[key]=copy(value)\n  return res\n elif isinstance(obj,(list,tuple)):\n  return obj[:]\n elif isinstance(obj,set):\n  return {x for x in obj}\n else :\n  return obj\n  \n  \nclass ElementData:\n ''\n \n \n def __init__(self,**kw):\n  ''\n\n\n  \n  self.__keys__=set()\n  for key,value in kw.items():\n   object.__setattr__(self,key,value)\n   self.__keys__.add(key)\n   \n def __setattr__(self,attr,value):\n  ''\n\n\n  \n  object.__setattr__(self,attr,value)\n  if attr !=\"__keys__\":\n   self.__keys__.add(attr)\n   \n def to_dict(self):\n  ''\n  return {k:getattr(self,k)for k in self.__keys__}\n  \n def clone(self):\n  ''\n\n\n  \n  return copy(self.to_dict())\n  \n  \nclass TemplateError(Exception):\n pass\n \n \nclass Template:\n\n def __init__(self,element,callbacks=[]):\n  if isinstance(element,str):\n   element=document[element]\n  self.element=element\n  self.line_mapping={}\n  self.line_num=1\n  self.indent=0\n  self.python=\"\"\n  self.parse(element)\n  self.callbacks=callbacks\n  \n def add(self,content,elt):\n  self.python +=content\n  self.line_mapping[self.line_num]=elt\n  if content.endswith(\"\\n\"):\n   self.line_num +=1\n   \n def add_indent(self,content,elt):\n  self.add(\"    \"*self.indent+content,elt)\n  \n def write(self,content):\n  self.html +=str(content)+\"\\n\"\n  \n def parse(self,elt):\n  ''\n\n  \n  \n  \n  is_block=False\n  \n  if elt.nodeType ==3:\n  \n   if elt.text.strip():\n    text=elt.text.replace('\"',\"&quot;\")\n    text=text.replace(\"\\n\",\"\\\\n\")\n    text='\"'+text+'\"'\n    \n    nb_braces=elt.text.count(\"{\")\n    if nb_braces:\n     nb_double_braces=elt.text.count(\"{{\")\n     if nb_double_braces !=nb_braces:\n      lines=[line for line in elt.text.split(\"\\n\")\n      if line.strip()]\n      text='f\"\"\"'+\" \".join(lines)+'\"\"\"'\n    self.add_indent(\"__write__(\"+text+\")\\n\",elt)\n    \n  elif hasattr(elt,\"tagName\"):\n   start_tag=\"__write__('<\"+elt.tagName\n   block=None\n   \n   \n   static_attrs=[]\n   dynamic_attrs=[]\n   for item in elt.attributes:\n    if item.name ==\"b-code\":\n    \n     block=item.value.rstrip(\":\")+\":\"\n    elif item.name ==\"b-include\":\n    \n     elt.html=open(item.value).read()\n    else :\n     value=item.value.replace(\"\\n\",\"\")\n     if \"{\"in value:\n      dynamic_attrs.append(\"'\"+item.name+\"', f'\"+\n      value.replace(\"'\",\"\\\\'\")+\"'\")\n     else :\n      static_attrs.append(item.name+'=\"'+value+'\"')\n      \n   if block:\n    self.add_indent(block+\"\\n\",elt)\n    self.indent +=1\n    is_block=True\n    \n   self.add_indent(start_tag,elt)\n   \n   if static_attrs or dynamic_attrs:\n    self.add(\" \",elt)\n    \n   for attr in static_attrs:\n    self.add_indent(attr+\" \",elt)\n    \n   if dynamic_attrs:\n    self.add(\"')\\n\",elt)\n    for attr in dynamic_attrs:\n     self.add_indent(\"__render_attr__(\"+attr+\")\\n\",elt)\n    self.add_indent(\"__write__('>')\\n\",elt)\n   else :\n    self.add_indent(\">')\\n\",elt)\n    \n  for child in elt.childNodes:\n   self.parse(child)\n   \n  if hasattr(elt,\"tagName\")and elt.tagName not in void_elements:\n   self.add_indent(\"__write__('</\"+elt.tagName+\">')\\n\",elt)\n   \n  if is_block:\n   self.indent -=1\n   \n def on(self,element,event,callback):\n  def func(evt):\n   cache=self.data.clone()\n   callback(evt,self)\n   new_data=self.data.to_dict()\n   if new_data !=cache:\n    self.render(**new_data)\n  element.bind(event,func)\n  \n def render_attr(self,name,value):\n  ''\n\n\n\n\n\n  \n  if value ==\"False\":\n   return\n  elif value ==\"True\":\n   self.html +=\" \"+name\n  else :\n   self.html +=\" \"+name+'=\"'+str(value)+'\"'\n   \n def render(self,**ns):\n  ''\n\n  \n  \n  self.data=ElementData(**ns)\n  \n  \n  ns.update({\"__write__\":self.write,\n  \"__render_attr__\":self.render_attr})\n  \n  self.html=\"\"\n  \n  \n  try :\n   exec(self.python,ns)\n  except Exception as exc:\n   msg=traceback.format_exc()\n   if isinstance(exc,SyntaxError):\n    line_no=exc.args[2]\n   else :\n    tb=exc.traceback\n    while tb is not None :\n     line_no=tb.tb_lineno\n     tb=tb.tb_next\n   elt=self.line_mapping[line_no]\n   print(\"Error rendering the element:\",elt.nodeType)\n   if elt.nodeType ==3:\n    print(elt.textContent)\n   else :\n    try :\n     print(elt.outerHTML)\n    except AttributeError:\n     print('no outerHTML for',elt)\n     print(elt.html)\n   print(f\"{exc.__class__.__name__}:  {exc}\")\n   return\n   \n   \n   \n   \n   \n   \n   \n  if self.element.nodeType !=9:\n   rank=self.element.index()\n   parent=self.element.parent\n   self.element.outerHTML=self.html\n   self.element=parent.childNodes[rank]\n   \n  else :\n  \n   self.element.html=self.html\n   \n   \n  self.element.unbind()\n  callbacks={}\n  for callback in self.callbacks:\n   callbacks[callback.__name__]=callback\n   \n   \n   \n  for element in self.element.select(\"*[b-on]\"):\n   bindings=element.getAttribute(\"b-on\")\n   bindings=bindings.split(\";\")\n   for binding in bindings:\n    parts=binding.split(\":\")\n    if not len(parts)==2:\n     raise TemplateError(f\"wrong binding: {binding}\")\n    event,func_name=[x.strip()for x in parts]\n    if not func_name in callbacks:\n     print(element.outerHTML)\n     raise TemplateError(f\"unknown callback: {func_name}\")\n    self.on(element,event,callbacks[func_name])\n", ["browser", "browser.html", "tb"]], "browser.timer": [".py", "from browser import console,window\n\ndef wrap(func):\n\n\n def f(*args,**kw):\n  try :\n   return func(*args,**kw)\n  except Exception as exc:\n   msg=''\n   try :\n    if exc.args:\n     msg='{0.info}\\n{0.__class__.__name__}: {0.args[0]}'.format(exc)\n    else :\n     msg=str(exc)\n    import sys\n    sys.stderr.write(msg)\n   except Exception as exc2:\n    console.log(\"Error printing exception traceback\",exc2,func,\n    args,kw)\n return f\n \nclear_interval=window.clearInterval\n\nclear_timeout=window.clearTimeout\n\ndef set_interval(func,interval):\n return window.setInterval(wrap(func),interval)\n \ndef set_timeout(func,interval,*args):\n return int(window.setTimeout(wrap(func),interval,*args))\n \ndef request_animation_frame(func):\n return int(window.requestAnimationFrame(func))\n \ndef cancel_animation_frame(int_id):\n window.cancelAnimationFrame(int_id)\n \ndef set_loop_timeout(x):\n\n assert isinstance(x,int)\n __BRYTHON__.loop_timeout=x\n", ["browser", "sys"]], "browser.highlight": [".py", "import _jsre as re\n\nfrom browser import html\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'_'\ndigits='0123456789'\n\nbuiltin_funcs=\"\"\"abs|dict|help|min|setattr|\nall|dir|hex|next|slice|\nany|divmod|id|object|sorted|\nascii|enumerate|input|oct|staticmethod|\nbin|eval|int|open|str|\nbool|exec|isinstance|ord|sum|\nbytearray|filter|issubclass|pow|super|\nbytes|float|iter|print|tuple|\ncallable|format|len|property|type|\nchr|frozenset|list|range|vars|\nclassmethod|getattr|locals|repr|zip|\ncompile|globals|map|reversed|__import__|\ncomplex|hasattr|max|round|\ndelattr|hash|memoryview|set|\n\"\"\"\n\nkeywords=[\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'async',\n'await',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n]\nkw_pattern='^('+'|'.join(keywords)+')$'\nbf_pattern='^('+builtin_funcs.replace(\"\\n\",\"\")+')$'\n\ndef escape(txt):\n txt=txt.replace('<','&lt;')\n txt=txt.replace('>','&gt;')\n return txt\n \ndef highlight(txt):\n res=html.PRE()\n i=0\n name=''\n while i <len(txt):\n  car=txt[i]\n  if car in [\"'\",'\"']:\n   mul_car=txt[i:i+3]\n   if mul_car in [\"'''\",'\"\"\"']:\n    car=mul_car\n   found_match=False\n   k=i+len(car)\n   while k <len(txt):\n    k=txt.find(car,k)\n    if k !=-1:\n     nb_as,j=0,k -1\n     while txt[j]=='\\\\':\n      nb_as +=1\n      j -=1\n     if nb_as %2 ==0:\n      res <=name+html.SPAN(escape(txt[i:k+len(car)]),\n      Class=\"python-string\")\n      i=k+len(car)-1\n      name=''\n      found_match=True\n      break\n    else :\n     break\n    k +=len(car)\n   if not found_match:\n    name +=car\n  elif car =='#':\n   end=txt.find('\\n',i)\n   if end ==-1:\n    res <=html.SPAN(escape(txt[i:]),Class=\"python-comment\")\n    break\n   else :\n    res <=html.SPAN(escape(txt[i:end]),Class=\"python-comment\")\n    i=end -1\n  elif car in letters:\n   name +=car\n  elif car in digits and name:\n   name +=car\n  else :\n   if name:\n    if re.search(kw_pattern,name):\n     res <=html.SPAN(name,Class=\"python-keyword\")\n    elif re.search(bf_pattern,name):\n     res <=html.SPAN(name,Class=\"python-builtin\")\n    else :\n     res <=name\n    name=''\n   res <=car\n  i +=1\n res <=name\n return res\n", ["_jsre", "browser", "browser.html"]], "browser.html": [".py", "from _html import *\n", ["_html"]], "importlib._bootstrap": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_bootstrap_external=None\n_thread=None\nimport _weakref\n\ndef _wrap(new,old):\n ''\n for replace in ['__module__','__name__','__qualname__','__doc__']:\n  if hasattr(old,replace):\n   setattr(new,replace,getattr(old,replace))\n new.__dict__.update(old.__dict__)\n \n \ndef _new_module(name):\n return type(sys)(name)\n \n \n \n \n \n \n_module_locks={}\n\n_blocking_on={}\n\n\nclass _DeadlockError(RuntimeError):\n pass\n \n \nclass _ModuleLock:\n ''\n\n\n \n \n def __init__(self,name):\n  self.lock=_thread.allocate_lock()\n  self.wakeup=_thread.allocate_lock()\n  self.name=name\n  self.owner=None\n  self.count=0\n  self.waiters=0\n  \n def has_deadlock(self):\n \n  me=_thread.get_ident()\n  tid=self.owner\n  while True :\n   lock=_blocking_on.get(tid)\n   if lock is None :\n    return False\n   tid=lock.owner\n   if tid ==me:\n    return True\n    \n def acquire(self):\n  ''\n\n\n\n  \n  tid=_thread.get_ident()\n  _blocking_on[tid]=self\n  try :\n   while True :\n    with self.lock:\n     if self.count ==0 or self.owner ==tid:\n      self.owner=tid\n      self.count +=1\n      return True\n     if self.has_deadlock():\n      raise _DeadlockError('deadlock detected by %r'%self)\n     if self.wakeup.acquire(False ):\n      self.waiters +=1\n      \n    self.wakeup.acquire()\n    self.wakeup.release()\n  finally :\n   del _blocking_on[tid]\n   \n def release(self):\n  tid=_thread.get_ident()\n  with self.lock:\n   if self.owner !=tid:\n    raise RuntimeError('cannot release un-acquired lock')\n   assert self.count >0\n   self.count -=1\n   if self.count ==0:\n    self.owner=None\n    if self.waiters:\n     self.waiters -=1\n     self.wakeup.release()\n     \n def __repr__(self):\n  return '_ModuleLock({!r}) at {}'.format(self.name,id(self))\n  \n  \nclass _DummyModuleLock:\n ''\n \n \n def __init__(self,name):\n  self.name=name\n  self.count=0\n  \n def acquire(self):\n  self.count +=1\n  return True\n  \n def release(self):\n  if self.count ==0:\n   raise RuntimeError('cannot release un-acquired lock')\n  self.count -=1\n  \n def __repr__(self):\n  return '_DummyModuleLock({!r}) at {}'.format(self.name,id(self))\n  \n  \nclass _ModuleLockManager:\n\n def __init__(self,name):\n  self._name=name\n  self._lock=None\n  \n def __enter__(self):\n  self._lock=_get_module_lock(self._name)\n  self._lock.acquire()\n  \n def __exit__(self,*args,**kwargs):\n  self._lock.release()\n  \n  \n  \n  \ndef _get_module_lock(name):\n ''\n\n\n \n \n _imp.acquire_lock()\n try :\n  try :\n   lock=_module_locks[name]()\n  except KeyError:\n   lock=None\n   \n  if lock is None :\n   if _thread is None :\n    lock=_DummyModuleLock(name)\n   else :\n    lock=_ModuleLock(name)\n    \n   def cb(ref,name=name):\n    _imp.acquire_lock()\n    try :\n    \n    \n    \n     if _module_locks.get(name)is ref:\n      del _module_locks[name]\n    finally :\n     _imp.release_lock()\n     \n   _module_locks[name]=_weakref.ref(lock,cb)\n finally :\n  _imp.release_lock()\n  \n return lock\n \n \ndef _lock_unlock_module(name):\n ''\n\n\n\n \n lock=_get_module_lock(name)\n try :\n  lock.acquire()\n except _DeadlockError:\n \n \n  pass\n else :\n  lock.release()\n  \n  \ndef _call_with_frames_removed(f,*args,**kwds):\n ''\n\n\n\n\n\n \n return f(*args,**kwds)\n \n \ndef _verbose_message(message,*args,verbosity=1):\n ''\n if sys.flags.verbose >=verbosity:\n  if not message.startswith(('#','import ')):\n   message='# '+message\n  print(message.format(*args),file=sys.stderr)\n  \n  \ndef _requires_builtin(fxn):\n ''\n def _requires_builtin_wrapper(self,fullname):\n  if fullname not in sys.builtin_module_names:\n   raise ImportError('{!r} is not a built-in module'.format(fullname),\n   name=fullname)\n  return fxn(self,fullname)\n _wrap(_requires_builtin_wrapper,fxn)\n return _requires_builtin_wrapper\n \n \ndef _requires_frozen(fxn):\n ''\n def _requires_frozen_wrapper(self,fullname):\n  if not _imp.is_frozen(fullname):\n   raise ImportError('{!r} is not a frozen module'.format(fullname),\n   name=fullname)\n  return fxn(self,fullname)\n _wrap(_requires_frozen_wrapper,fxn)\n return _requires_frozen_wrapper\n \n \n \ndef _load_module_shim(self,fullname):\n ''\n\n\n\n \n spec=spec_from_loader(fullname,self)\n if fullname in sys.modules:\n  module=sys.modules[fullname]\n  _exec(spec,module)\n  return sys.modules[fullname]\n else :\n  return _load(spec)\n  \n  \n  \ndef _module_repr(module):\n\n loader=getattr(module,'__loader__',None )\n if hasattr(loader,'module_repr'):\n \n \n \n  try :\n   return loader.module_repr(module)\n  except Exception:\n   pass\n try :\n  spec=module.__spec__\n except AttributeError:\n  pass\n else :\n  if spec is not None :\n   return _module_repr_from_spec(spec)\n   \n   \n   \n try :\n  name=module.__name__\n except AttributeError:\n  name='?'\n try :\n  filename=module.__file__\n except AttributeError:\n  if loader is None :\n   return '<module {!r}>'.format(name)\n  else :\n   return '<module {!r} ({!r})>'.format(name,loader)\n else :\n  return '<module {!r} from {!r}>'.format(name,filename)\n  \n  \nclass _installed_safely:\n\n def __init__(self,module):\n  self._module=module\n  self._spec=module.__spec__\n  \n def __enter__(self):\n \n \n \n  self._spec._initializing=True\n  sys.modules[self._spec.name]=self._module\n  \n def __exit__(self,*args):\n  try :\n   spec=self._spec\n   if any(arg is not None for arg in args):\n    try :\n     del sys.modules[spec.name]\n    except KeyError:\n     pass\n   else :\n    _verbose_message('import {!r} # {!r}',spec.name,spec.loader)\n  finally :\n   self._spec._initializing=False\n   \n   \nclass ModuleSpec:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,name,loader,*,origin=None ,loader_state=None ,\n is_package=None ):\n  self.name=name\n  self.loader=loader\n  self.origin=origin\n  self.loader_state=loader_state\n  self.submodule_search_locations=[]if is_package else None\n  \n  \n  self._set_fileattr=False\n  self._cached=None\n  \n def __repr__(self):\n  args=['name={!r}'.format(self.name),\n  'loader={!r}'.format(self.loader)]\n  if self.origin is not None :\n   args.append('origin={!r}'.format(self.origin))\n  if self.submodule_search_locations is not None :\n   args.append('submodule_search_locations={}'\n   .format(self.submodule_search_locations))\n  return '{}({})'.format(self.__class__.__name__,', '.join(args))\n  \n def __eq__(self,other):\n  smsl=self.submodule_search_locations\n  try :\n   return (self.name ==other.name and\n   self.loader ==other.loader and\n   self.origin ==other.origin and\n   smsl ==other.submodule_search_locations and\n   self.cached ==other.cached and\n   self.has_location ==other.has_location)\n  except AttributeError:\n   return False\n   \n @property\n def cached(self):\n  if self._cached is None :\n   if self.origin is not None and self._set_fileattr:\n    if _bootstrap_external is None :\n     raise NotImplementedError\n    self._cached=_bootstrap_external._get_cached(self.origin)\n  return self._cached\n  \n @cached.setter\n def cached(self,cached):\n  self._cached=cached\n  \n @property\n def parent(self):\n  ''\n  if self.submodule_search_locations is None :\n   return self.name.rpartition('.')[0]\n  else :\n   return self.name\n   \n @property\n def has_location(self):\n  return self._set_fileattr\n  \n @has_location.setter\n def has_location(self,value):\n  self._set_fileattr=bool(value)\n  \n  \ndef spec_from_loader(name,loader,*,origin=None ,is_package=None ):\n ''\n if hasattr(loader,'get_filename'):\n  if _bootstrap_external is None :\n   raise NotImplementedError\n  spec_from_file_location=_bootstrap_external.spec_from_file_location\n  \n  if is_package is None :\n   return spec_from_file_location(name,loader=loader)\n  search=[]if is_package else None\n  return spec_from_file_location(name,loader=loader,\n  submodule_search_locations=search)\n  \n if is_package is None :\n  if hasattr(loader,'is_package'):\n   try :\n    is_package=loader.is_package(name)\n   except ImportError:\n    is_package=None\n  else :\n  \n   is_package=False\n   \n return ModuleSpec(name,loader,origin=origin,is_package=is_package)\n \n \ndef _spec_from_module(module,loader=None ,origin=None ):\n\n try :\n  spec=module.__spec__\n except AttributeError:\n  pass\n else :\n  if spec is not None :\n   return spec\n   \n name=module.__name__\n if loader is None :\n  try :\n   loader=module.__loader__\n  except AttributeError:\n  \n   pass\n try :\n  location=module.__file__\n except AttributeError:\n  location=None\n if origin is None :\n  if location is None :\n   try :\n    origin=loader._ORIGIN\n   except AttributeError:\n    origin=None\n  else :\n   origin=location\n try :\n  cached=module.__cached__\n except AttributeError:\n  cached=None\n try :\n  submodule_search_locations=list(module.__path__)\n except AttributeError:\n  submodule_search_locations=None\n  \n spec=ModuleSpec(name,loader,origin=origin)\n spec._set_fileattr=False if location is None else True\n spec.cached=cached\n spec.submodule_search_locations=submodule_search_locations\n return spec\n \n \ndef _init_module_attrs(spec,module,*,override=False ):\n\n\n\n if (override or getattr(module,'__name__',None )is None ):\n  try :\n   module.__name__=spec.name\n  except AttributeError:\n   pass\n   \n if override or getattr(module,'__loader__',None )is None :\n  loader=spec.loader\n  if loader is None :\n  \n   if spec.submodule_search_locations is not None :\n    if _bootstrap_external is None :\n     raise NotImplementedError\n    _NamespaceLoader=_bootstrap_external._NamespaceLoader\n    \n    loader=_NamespaceLoader.__new__(_NamespaceLoader)\n    loader._path=spec.submodule_search_locations\n    spec.loader=loader\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    module.__file__=None\n  try :\n   module.__loader__=loader\n  except AttributeError:\n   pass\n   \n if override or getattr(module,'__package__',None )is None :\n  try :\n   module.__package__=spec.parent\n  except AttributeError:\n   pass\n   \n try :\n  module.__spec__=spec\n except AttributeError:\n  pass\n  \n if override or getattr(module,'__path__',None )is None :\n  if spec.submodule_search_locations is not None :\n   try :\n    module.__path__=spec.submodule_search_locations\n   except AttributeError:\n    pass\n    \n if spec.has_location:\n  if override or getattr(module,'__file__',None )is None :\n   try :\n    module.__file__=spec.origin\n   except AttributeError:\n    pass\n    \n  if override or getattr(module,'__cached__',None )is None :\n   if spec.cached is not None :\n    try :\n     module.__cached__=spec.cached\n    except AttributeError:\n     pass\n return module\n \n \ndef module_from_spec(spec):\n ''\n \n module=None\n if hasattr(spec.loader,'create_module'):\n \n \n  module=spec.loader.create_module(spec)\n elif hasattr(spec.loader,'exec_module'):\n  raise ImportError('loaders that define exec_module() '\n  'must also define create_module()')\n if module is None :\n  module=_new_module(spec.name)\n _init_module_attrs(spec,module)\n return module\n \n \ndef _module_repr_from_spec(spec):\n ''\n \n name='?'if spec.name is None else spec.name\n if spec.origin is None :\n  if spec.loader is None :\n   return '<module {!r}>'.format(name)\n  else :\n   return '<module {!r} ({!r})>'.format(name,spec.loader)\n else :\n  if spec.has_location:\n   return '<module {!r} from {!r}>'.format(name,spec.origin)\n  else :\n   return '<module {!r} ({})>'.format(spec.name,spec.origin)\n   \n   \n   \ndef _exec(spec,module):\n ''\n name=spec.name\n with _ModuleLockManager(name):\n  if sys.modules.get(name)is not module:\n   msg='module {!r} not in sys.modules'.format(name)\n   raise ImportError(msg,name=name)\n  if spec.loader is None :\n   if spec.submodule_search_locations is None :\n    raise ImportError('missing loader',name=spec.name)\n    \n   _init_module_attrs(spec,module,override=True )\n   return module\n  _init_module_attrs(spec,module,override=True )\n  if not hasattr(spec.loader,'exec_module'):\n  \n  \n  \n   spec.loader.load_module(name)\n  else :\n   spec.loader.exec_module(module)\n return sys.modules[name]\n \n \ndef _load_backward_compatible(spec):\n\n\n\n spec.loader.load_module(spec.name)\n \n module=sys.modules[spec.name]\n if getattr(module,'__loader__',None )is None :\n  try :\n   module.__loader__=spec.loader\n  except AttributeError:\n   pass\n if getattr(module,'__package__',None )is None :\n  try :\n  \n  \n  \n   module.__package__=module.__name__\n   if not hasattr(module,'__path__'):\n    module.__package__=spec.name.rpartition('.')[0]\n  except AttributeError:\n   pass\n if getattr(module,'__spec__',None )is None :\n  try :\n   module.__spec__=spec\n  except AttributeError:\n   pass\n return module\n \ndef _load_unlocked(spec):\n\n if spec.loader is not None :\n \n  if not hasattr(spec.loader,'exec_module'):\n   return _load_backward_compatible(spec)\n   \n module=module_from_spec(spec)\n with _installed_safely(module):\n  if spec.loader is None :\n   if spec.submodule_search_locations is None :\n    raise ImportError('missing loader',name=spec.name)\n    \n  else :\n   spec.loader.exec_module(module)\n   \n   \n   \n   \n return sys.modules[spec.name]\n \n \n \ndef _load(spec):\n ''\n\n\n\n\n\n\n \n with _ModuleLockManager(spec.name):\n  return _load_unlocked(spec)\n  \n  \n  \n  \nclass BuiltinImporter:\n\n ''\n\n\n\n\n \n \n @staticmethod\n def module_repr(module):\n  ''\n\n\n\n  \n  return '<module {!r} (built-in)>'.format(module.__name__)\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  if path is not None :\n   return None\n  if _imp.is_builtin(fullname):\n   return spec_from_loader(fullname,cls,origin='built-in')\n  else :\n   return None\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n\n\n  \n  spec=cls.find_spec(fullname,path)\n  return spec.loader if spec is not None else None\n  \n @classmethod\n def create_module(self,spec):\n  ''\n  if spec.name not in sys.builtin_module_names:\n   raise ImportError('{!r} is not a built-in module'.format(spec.name),\n   name=spec.name)\n  return _call_with_frames_removed(_imp.create_builtin,spec)\n  \n @classmethod\n def exec_module(self,module):\n  ''\n  _call_with_frames_removed(_imp.exec_builtin,module)\n  \n @classmethod\n @_requires_builtin\n def get_code(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_builtin\n def get_source(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_builtin\n def is_package(cls,fullname):\n  ''\n  return False\n  \n load_module=classmethod(_load_module_shim)\n \n \nclass FrozenImporter:\n\n ''\n\n\n\n\n \n \n @staticmethod\n def module_repr(m):\n  ''\n\n\n\n  \n  return '<module {!r} (frozen)>'.format(m.__name__)\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  if _imp.is_frozen(fullname):\n   return spec_from_loader(fullname,cls,origin='frozen')\n  else :\n   return None\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n  \n  return cls if _imp.is_frozen(fullname)else None\n  \n @classmethod\n def create_module(cls,spec):\n  ''\n  \n @staticmethod\n def exec_module(module):\n  name=module.__spec__.name\n  if not _imp.is_frozen(name):\n   raise ImportError('{!r} is not a frozen module'.format(name),\n   name=name)\n  code=_call_with_frames_removed(_imp.get_frozen_object,name)\n  exec(code,module.__dict__)\n  \n @classmethod\n def load_module(cls,fullname):\n  ''\n\n\n\n  \n  return _load_module_shim(cls,fullname)\n  \n @classmethod\n @_requires_frozen\n def get_code(cls,fullname):\n  ''\n  return _imp.get_frozen_object(fullname)\n  \n @classmethod\n @_requires_frozen\n def get_source(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_frozen\n def is_package(cls,fullname):\n  ''\n  return _imp.is_frozen_package(fullname)\n  \n  \n  \n  \nclass _ImportLockContext:\n\n ''\n \n def __enter__(self):\n  ''\n  _imp.acquire_lock()\n  \n def __exit__(self,exc_type,exc_value,exc_traceback):\n  ''\n  _imp.release_lock()\n  \n  \ndef _resolve_name(name,package,level):\n ''\n bits=package.rsplit('.',level -1)\n if len(bits)<level:\n  raise ValueError('attempted relative import beyond top-level package')\n base=bits[0]\n return '{}.{}'.format(base,name)if name else base\n \n \ndef _find_spec_legacy(finder,name,path):\n\n\n loader=finder.find_module(name,path)\n if loader is None :\n  return None\n return spec_from_loader(name,loader)\n \n \ndef _find_spec(name,path,target=None ):\n ''\n meta_path=sys.meta_path\n if meta_path is None :\n \n  raise ImportError(\"sys.meta_path is None, Python is likely \"\n  \"shutting down\")\n  \n if not meta_path:\n  _warnings.warn('sys.meta_path is empty',ImportWarning)\n  \n  \n  \n  \n is_reload=name in sys.modules\n for finder in meta_path:\n  with _ImportLockContext():\n   try :\n    find_spec=finder.find_spec\n   except AttributeError:\n    spec=_find_spec_legacy(finder,name,path)\n    if spec is None :\n     continue\n   else :\n    spec=find_spec(name,path,target)\n  if spec is not None :\n  \n   if not is_reload and name in sys.modules:\n    module=sys.modules[name]\n    try :\n     __spec__=module.__spec__\n    except AttributeError:\n    \n    \n    \n     return spec\n    else :\n     if __spec__ is None :\n      return spec\n     else :\n      return __spec__\n   else :\n    return spec\n else :\n  return None\n  \n  \ndef _sanity_check(name,package,level):\n ''\n if not isinstance(name,str):\n  raise TypeError('module name must be str, not {}'.format(type(name)))\n if level <0:\n  raise ValueError('level must be >= 0')\n if level >0:\n  if not isinstance(package,str):\n   raise TypeError('__package__ not set to a string')\n  elif not package:\n   raise ImportError('attempted relative import with no known parent '\n   'package')\n if not name and level ==0:\n  raise ValueError('Empty module name')\n  \n  \n_ERR_MSG_PREFIX='No module named '\n_ERR_MSG=_ERR_MSG_PREFIX+'{!r}'\n\ndef _find_and_load_unlocked(name,import_):\n path=None\n parent=name.rpartition('.')[0]\n if parent:\n  if parent not in sys.modules:\n   _call_with_frames_removed(import_,parent)\n   \n  if name in sys.modules:\n   return sys.modules[name]\n  parent_module=sys.modules[parent]\n  try :\n   path=parent_module.__path__\n  except AttributeError:\n   msg=(_ERR_MSG+'; {!r} is not a package').format(name,parent)\n   raise ModuleNotFoundError(msg,name=name)from None\n spec=_find_spec(name,path)\n if spec is None :\n  raise ModuleNotFoundError(_ERR_MSG.format(name),name=name)\n else :\n  module=_load_unlocked(spec)\n if parent:\n \n  parent_module=sys.modules[parent]\n  setattr(parent_module,name.rpartition('.')[2],module)\n return module\n \n \n_NEEDS_LOADING=object()\n\n\ndef _find_and_load(name,import_):\n ''\n with _ModuleLockManager(name):\n  module=sys.modules.get(name,_NEEDS_LOADING)\n  if module is _NEEDS_LOADING:\n   return _find_and_load_unlocked(name,import_)\n   \n if module is None :\n  message=('import of {} halted; '\n  'None in sys.modules'.format(name))\n  raise ModuleNotFoundError(message,name=name)\n  \n _lock_unlock_module(name)\n return module\n \n \ndef _gcd_import(name,package=None ,level=0):\n ''\n\n\n\n\n\n\n \n _sanity_check(name,package,level)\n if level >0:\n  name=_resolve_name(name,package,level)\n return _find_and_load(name,_gcd_import)\n \n \ndef _handle_fromlist(module,fromlist,import_,*,recursive=False ):\n ''\n\n\n\n\n\n \n \n \n if hasattr(module,'__path__'):\n  for x in fromlist:\n   if not isinstance(x,str):\n    if recursive:\n     where=module.__name__+'.__all__'\n    else :\n     where=\"``from list''\"\n    raise TypeError(f\"Item in {where} must be str, \"\n    f\"not {type(x).__name__}\")\n   elif x =='*':\n    if not recursive and hasattr(module,'__all__'):\n     _handle_fromlist(module,module.__all__,import_,\n     recursive=True )\n   elif not hasattr(module,x):\n    from_name='{}.{}'.format(module.__name__,x)\n    try :\n     _call_with_frames_removed(import_,from_name)\n    except ModuleNotFoundError as exc:\n    \n    \n    \n     if (exc.name ==from_name and\n     sys.modules.get(from_name,_NEEDS_LOADING)is not None ):\n      continue\n     raise\n return module\n \n \ndef _calc___package__(globals):\n ''\n\n\n\n\n \n package=globals.get('__package__')\n spec=globals.get('__spec__')\n if package is not None :\n  if spec is not None and package !=spec.parent:\n   _warnings.warn(\"__package__ != __spec__.parent \"\n   f\"({package!r} != {spec.parent!r})\",\n   ImportWarning,stacklevel=3)\n  return package\n elif spec is not None :\n  return spec.parent\n else :\n  _warnings.warn(\"can't resolve package from __spec__ or __package__, \"\n  \"falling back on __name__ and __path__\",\n  ImportWarning,stacklevel=3)\n  package=globals['__name__']\n  if '__path__'not in globals:\n   package=package.rpartition('.')[0]\n return package\n \n \ndef __import__(name,globals=None ,locals=None ,fromlist=(),level=0):\n ''\n\n\n\n\n\n\n\n\n \n if level ==0:\n  module=_gcd_import(name)\n else :\n  globals_=globals if globals is not None else {}\n  package=_calc___package__(globals_)\n  module=_gcd_import(name,package,level)\n if not fromlist:\n \n \n  if level ==0:\n   return _gcd_import(name.partition('.')[0])\n  elif not name:\n   return module\n  else :\n  \n  \n   cut_off=len(name)-len(name.partition('.')[0])\n   \n   \n   return sys.modules[module.__name__[:len(module.__name__)-cut_off]]\n else :\n  return _handle_fromlist(module,fromlist,_gcd_import)\n  \n  \ndef _builtin_from_name(name):\n spec=BuiltinImporter.find_spec(name)\n if spec is None :\n  raise ImportError('no built-in module named '+name)\n return _load_unlocked(spec)\n \n \ndef _setup(sys_module,_imp_module):\n ''\n\n\n\n\n\n \n global _imp,sys\n _imp=_imp_module\n sys=sys_module\n \n \n module_type=type(sys)\n for name,module in sys.modules.items():\n  if isinstance(module,module_type):\n   if name in sys.builtin_module_names:\n    loader=BuiltinImporter\n   elif _imp.is_frozen(name):\n    loader=FrozenImporter\n   else :\n    continue\n   spec=_spec_from_module(module,loader)\n   _init_module_attrs(spec,module)\n   \n   \n self_module=sys.modules[__name__]\n \n \n for builtin_name in ('_warnings',):\n  if builtin_name not in sys.modules:\n   builtin_module=_builtin_from_name(builtin_name)\n  else :\n   builtin_module=sys.modules[builtin_name]\n  setattr(self_module,builtin_name,builtin_module)\n  \n  \ndef _install(sys_module,_imp_module):\n ''\n _setup(sys_module,_imp_module)\n \n sys.meta_path.append(BuiltinImporter)\n sys.meta_path.append(FrozenImporter)\n \n \ndef _install_external_importers():\n ''\n global _bootstrap_external\n import _frozen_importlib_external\n _bootstrap_external=_frozen_importlib_external\n _frozen_importlib_external._install(sys.modules[__name__])\n", ["_frozen_importlib_external", "_weakref"]], "importlib.machinery": [".py", "''\n\nimport _imp\n\nfrom ._bootstrap import ModuleSpec\nfrom ._bootstrap import BuiltinImporter\nfrom ._bootstrap import FrozenImporter\nfrom ._bootstrap_external import (SOURCE_SUFFIXES,DEBUG_BYTECODE_SUFFIXES,\nOPTIMIZED_BYTECODE_SUFFIXES,BYTECODE_SUFFIXES,\nEXTENSION_SUFFIXES)\nfrom ._bootstrap_external import WindowsRegistryFinder\nfrom ._bootstrap_external import PathFinder\nfrom ._bootstrap_external import FileFinder\nfrom ._bootstrap_external import SourceFileLoader\nfrom ._bootstrap_external import SourcelessFileLoader\nfrom ._bootstrap_external import ExtensionFileLoader\n\n\ndef all_suffixes():\n ''\n return SOURCE_SUFFIXES+BYTECODE_SUFFIXES+EXTENSION_SUFFIXES\n", ["_imp", "importlib._bootstrap", "importlib._bootstrap_external"]], "importlib.basehook": [".py", "from javascript import JSObject\nfrom browser import window\nimport urllib.request\n\nclass TempMod:\n def __init__(self,name):\n  self.name=name\n  \n  \nclass BaseHook:\n def __init__(self,fullname=None ,path=None ):\n  self._fullname=fullname\n  self._path=path\n  self._modpath=''\n  self._module=''\n  \n def find_module(self,name=None ,path=None ):\n  if name is None :\n   name=self._fullname\n   \n  for _i in ('libs/%s.js'%name,'Lib/%s.py'%name,\n  'Lib/%s/__init__.py'%name):\n   _path=\"%s%s\"%(__BRYTHON__.brython_path,_i)\n   try :\n    _fp,_,_headers=urllib.request.urlopen(_path)\n    if _headers['status']!=200:\n     continue\n    self._module=_fp.read()\n    self._modpath=_path\n    return self\n   except urllib.error.HTTPError as e:\n    self._modpath=''\n    self._module=''\n    \n  raise ImportError\n  \n def is_package(self):\n  return '.'in self._fullname\n  \n def load_module(self,name):\n  if name is None :\n   name=self._fullname\n  window.eval('__BRYTHON__.imported[\"%s\"] = {}'%name)\n  return JSObject(__BRYTHON__.run_py)(self._module,\n  self._modpath,TempMod(name))\n", ["browser", "javascript", "urllib.request"]], "importlib.resources": [".py", "import os\nimport tempfile\n\nfrom . import abc as resources_abc\nfrom contextlib import contextmanager,suppress\nfrom importlib import import_module\nfrom importlib.abc import ResourceLoader\nfrom io import BytesIO,TextIOWrapper\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Iterable,Iterator,Optional,Set,Union\nfrom typing import cast\nfrom typing.io import BinaryIO,TextIO\nfrom zipimport import ZipImportError\n\n\n__all__=[\n'Package',\n'Resource',\n'contents',\n'is_resource',\n'open_binary',\n'open_text',\n'path',\n'read_binary',\n'read_text',\n]\n\n\nPackage=Union[str,ModuleType]\nResource=Union[str,os.PathLike]\n\n\ndef _get_package(package)->ModuleType:\n ''\n\n\n\n \n if hasattr(package,'__spec__'):\n  if package.__spec__.submodule_search_locations is None :\n   raise TypeError('{!r} is not a package'.format(\n   package.__spec__.name))\n  else :\n   return package\n else :\n  module=import_module(package)\n  if module.__spec__.submodule_search_locations is None :\n   raise TypeError('{!r} is not a package'.format(package))\n  else :\n   return module\n   \n   \ndef _normalize_path(path)->str:\n ''\n\n\n \n parent,file_name=os.path.split(path)\n if parent:\n  raise ValueError('{!r} must be only a file name'.format(path))\n else :\n  return file_name\n  \n  \ndef _get_resource_reader(\npackage:ModuleType)->Optional[resources_abc.ResourceReader]:\n\n\n\n\n\n spec=package.__spec__\n if hasattr(spec.loader,'get_resource_reader'):\n  return cast(resources_abc.ResourceReader,\n  spec.loader.get_resource_reader(spec.name))\n return None\n \n \ndef _check_location(package):\n if package.__spec__.origin is None or not package.__spec__.has_location:\n  raise FileNotFoundError(f'Package has no location {package!r}')\n  \n  \ndef open_binary(package:Package,resource:Resource)->BinaryIO:\n ''\n resource=_normalize_path(resource)\n package=_get_package(package)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return reader.open_resource(resource)\n _check_location(package)\n absolute_package_path=os.path.abspath(package.__spec__.origin)\n package_path=os.path.dirname(absolute_package_path)\n full_path=os.path.join(package_path,resource)\n try :\n  return open(full_path,mode='rb')\n except OSError:\n \n \n \n  loader=cast(ResourceLoader,package.__spec__.loader)\n  data=None\n  if hasattr(package.__spec__.loader,'get_data'):\n   with suppress(OSError):\n    data=loader.get_data(full_path)\n  if data is None :\n   package_name=package.__spec__.name\n   message='{!r} resource not found in {!r}'.format(\n   resource,package_name)\n   raise FileNotFoundError(message)\n  else :\n   return BytesIO(data)\n   \n   \ndef open_text(package:Package,\nresource:Resource,\nencoding:str='utf-8',\nerrors:str='strict')->TextIO:\n ''\n resource=_normalize_path(resource)\n package=_get_package(package)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return TextIOWrapper(reader.open_resource(resource),encoding,errors)\n _check_location(package)\n absolute_package_path=os.path.abspath(package.__spec__.origin)\n package_path=os.path.dirname(absolute_package_path)\n full_path=os.path.join(package_path,resource)\n try :\n  return open(full_path,mode='r',encoding=encoding,errors=errors)\n except OSError:\n \n \n \n  loader=cast(ResourceLoader,package.__spec__.loader)\n  data=None\n  if hasattr(package.__spec__.loader,'get_data'):\n   with suppress(OSError):\n    data=loader.get_data(full_path)\n  if data is None :\n   package_name=package.__spec__.name\n   message='{!r} resource not found in {!r}'.format(\n   resource,package_name)\n   raise FileNotFoundError(message)\n  else :\n   return TextIOWrapper(BytesIO(data),encoding,errors)\n   \n   \ndef read_binary(package:Package,resource:Resource)->bytes:\n ''\n resource=_normalize_path(resource)\n package=_get_package(package)\n with open_binary(package,resource)as fp:\n  return fp.read()\n  \n  \ndef read_text(package:Package,\nresource:Resource,\nencoding:str='utf-8',\nerrors:str='strict')->str:\n ''\n\n\n\n \n resource=_normalize_path(resource)\n package=_get_package(package)\n with open_text(package,resource,encoding,errors)as fp:\n  return fp.read()\n  \n  \n@contextmanager\ndef path(package:Package,resource:Resource)->Iterator[Path]:\n ''\n\n\n\n\n\n\n \n resource=_normalize_path(resource)\n package=_get_package(package)\n reader=_get_resource_reader(package)\n if reader is not None :\n  try :\n   yield Path(reader.resource_path(resource))\n   return\n  except FileNotFoundError:\n   pass\n else :\n  _check_location(package)\n  \n  \n package_directory=Path(package.__spec__.origin).parent\n file_path=package_directory /resource\n if file_path.exists():\n  yield file_path\n else :\n  with open_binary(package,resource)as fp:\n   data=fp.read()\n   \n   \n   \n  fd,raw_path=tempfile.mkstemp()\n  try :\n   os.write(fd,data)\n   os.close(fd)\n   yield Path(raw_path)\n  finally :\n   try :\n    os.remove(raw_path)\n   except FileNotFoundError:\n    pass\n    \n    \ndef is_resource(package:Package,name:str)->bool:\n ''\n\n\n \n package=_get_package(package)\n _normalize_path(name)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return reader.is_resource(name)\n try :\n  package_contents=set(contents(package))\n except (NotADirectoryError,FileNotFoundError):\n  return False\n if name not in package_contents:\n  return False\n  \n  \n  \n path=Path(package.__spec__.origin).parent /name\n return path.is_file()\n \n \ndef contents(package:Package)->Iterable[str]:\n ''\n\n\n\n\n \n package=_get_package(package)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return reader.contents()\n  \n  \n  \n elif package.__spec__.origin is None or not package.__spec__.has_location:\n  return ()\n else :\n  package_directory=Path(package.__spec__.origin).parent\n  return os.listdir(package_directory)\n", ["contextlib", "importlib", "importlib.abc", "io", "os", "pathlib", "tempfile", "types", "typing", "typing.io", "zipimport"]], "importlib.util": [".py", "''\nfrom . import abc\nfrom ._bootstrap import module_from_spec\nfrom ._bootstrap import _resolve_name\nfrom ._bootstrap import spec_from_loader\nfrom ._bootstrap import _find_spec\nfrom ._bootstrap_external import MAGIC_NUMBER\nfrom ._bootstrap_external import _RAW_MAGIC_NUMBER\nfrom ._bootstrap_external import cache_from_source\nfrom ._bootstrap_external import decode_source\nfrom ._bootstrap_external import source_from_cache\nfrom ._bootstrap_external import spec_from_file_location\n\nfrom contextlib import contextmanager\nimport _imp\nimport functools\nimport sys\nimport types\nimport warnings\n\n\ndef source_hash(source_bytes):\n ''\n return _imp.source_hash(_RAW_MAGIC_NUMBER,source_bytes)\n \n \ndef resolve_name(name,package):\n ''\n if not name.startswith('.'):\n  return name\n elif not package:\n  raise ValueError(f'no package specified for {repr(name)} '\n  '(required for relative module names)')\n level=0\n for character in name:\n  if character !='.':\n   break\n  level +=1\n return _resolve_name(name[level:],package,level)\n \n \ndef _find_spec_from_path(name,path=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n if name not in sys.modules:\n  return _find_spec(name,path)\n else :\n  module=sys.modules[name]\n  if module is None :\n   return None\n  try :\n   spec=module.__spec__\n  except AttributeError:\n   raise ValueError('{}.__spec__ is not set'.format(name))from None\n  else :\n   if spec is None :\n    raise ValueError('{}.__spec__ is None'.format(name))\n   return spec\n   \n   \ndef find_spec(name,package=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n fullname=resolve_name(name,package)if name.startswith('.')else name\n if fullname not in sys.modules:\n  parent_name=fullname.rpartition('.')[0]\n  if parent_name:\n   parent=__import__(parent_name,fromlist=['__path__'])\n   try :\n    parent_path=parent.__path__\n   except AttributeError as e:\n    raise ModuleNotFoundError(\n    f\"__path__ attribute not found on {parent_name!r} \"\n    f\"while trying to find {fullname!r}\",name=fullname)from e\n  else :\n   parent_path=None\n  return _find_spec(fullname,parent_path)\n else :\n  module=sys.modules[fullname]\n  if module is None :\n   return None\n  try :\n   spec=module.__spec__\n  except AttributeError:\n   raise ValueError('{}.__spec__ is not set'.format(name))from None\n  else :\n   if spec is None :\n    raise ValueError('{}.__spec__ is None'.format(name))\n   return spec\n   \n   \n@contextmanager\ndef _module_to_load(name):\n is_reload=name in sys.modules\n \n module=sys.modules.get(name)\n if not is_reload:\n \n \n \n  module=type(sys)(name)\n  \n  \n  module.__initializing__=True\n  sys.modules[name]=module\n try :\n  yield module\n except Exception:\n  if not is_reload:\n   try :\n    del sys.modules[name]\n   except KeyError:\n    pass\n finally :\n  module.__initializing__=False\n  \n  \ndef set_package(fxn):\n ''\n\n\n\n \n @functools.wraps(fxn)\n def set_package_wrapper(*args,**kwargs):\n  warnings.warn('The import system now takes care of this automatically.',\n  DeprecationWarning,stacklevel=2)\n  module=fxn(*args,**kwargs)\n  if getattr(module,'__package__',None )is None :\n   module.__package__=module.__name__\n   if not hasattr(module,'__path__'):\n    module.__package__=module.__package__.rpartition('.')[0]\n  return module\n return set_package_wrapper\n \n \ndef set_loader(fxn):\n ''\n\n\n\n \n @functools.wraps(fxn)\n def set_loader_wrapper(self,*args,**kwargs):\n  warnings.warn('The import system now takes care of this automatically.',\n  DeprecationWarning,stacklevel=2)\n  module=fxn(self,*args,**kwargs)\n  if getattr(module,'__loader__',None )is None :\n   module.__loader__=self\n  return module\n return set_loader_wrapper\n \n \ndef module_for_loader(fxn):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n warnings.warn('The import system now takes care of this automatically.',\n DeprecationWarning,stacklevel=2)\n @functools.wraps(fxn)\n def module_for_loader_wrapper(self,fullname,*args,**kwargs):\n  with _module_to_load(fullname)as module:\n   module.__loader__=self\n   try :\n    is_package=self.is_package(fullname)\n   except (ImportError,AttributeError):\n    pass\n   else :\n    if is_package:\n     module.__package__=fullname\n    else :\n     module.__package__=fullname.rpartition('.')[0]\n     \n   return fxn(self,module,*args,**kwargs)\n   \n return module_for_loader_wrapper\n \n \nclass _LazyModule(types.ModuleType):\n\n ''\n \n def __getattribute__(self,attr):\n  ''\n  \n  \n  \n  self.__class__=types.ModuleType\n  \n  \n  original_name=self.__spec__.name\n  \n  \n  attrs_then=self.__spec__.loader_state['__dict__']\n  original_type=self.__spec__.loader_state['__class__']\n  attrs_now=self.__dict__\n  attrs_updated={}\n  for key,value in attrs_now.items():\n  \n  \n   if key not in attrs_then:\n    attrs_updated[key]=value\n   elif id(attrs_now[key])!=id(attrs_then[key]):\n    attrs_updated[key]=value\n  self.__spec__.loader.exec_module(self)\n  \n  \n  if original_name in sys.modules:\n   if id(self)!=id(sys.modules[original_name]):\n    raise ValueError(f\"module object for {original_name!r} \"\n    \"substituted in sys.modules during a lazy \"\n    \"load\")\n    \n    \n  self.__dict__.update(attrs_updated)\n  return getattr(self,attr)\n  \n def __delattr__(self,attr):\n  ''\n  \n  \n  self.__getattribute__(attr)\n  delattr(self,attr)\n  \n  \nclass LazyLoader(abc.Loader):\n\n ''\n \n @staticmethod\n def __check_eager_loader(loader):\n  if not hasattr(loader,'exec_module'):\n   raise TypeError('loader must define exec_module()')\n   \n @classmethod\n def factory(cls,loader):\n  ''\n  cls.__check_eager_loader(loader)\n  return lambda *args,**kwargs:cls(loader(*args,**kwargs))\n  \n def __init__(self,loader):\n  self.__check_eager_loader(loader)\n  self.loader=loader\n  \n def create_module(self,spec):\n  return self.loader.create_module(spec)\n  \n def exec_module(self,module):\n  ''\n  module.__spec__.loader=self.loader\n  module.__loader__=self.loader\n  \n  \n  \n  \n  loader_state={}\n  loader_state['__dict__']=module.__dict__.copy()\n  loader_state['__class__']=module.__class__\n  module.__spec__.loader_state=loader_state\n  module.__class__=_LazyModule\n", ["_imp", "contextlib", "functools", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "importlib.abc", "sys", "types", "warnings"]], "importlib": [".py", "''\n__all__=['__import__','import_module','invalidate_caches','reload']\n\n\n\n\n\n\n\n\n\nimport _imp\nimport sys\n\ntry :\n import _frozen_importlib as _bootstrap\nexcept ImportError:\n from . import _bootstrap\n _bootstrap._setup(sys,_imp)\nelse :\n\n\n _bootstrap.__name__='importlib._bootstrap'\n _bootstrap.__package__='importlib'\n try :\n  _bootstrap.__file__=__file__.replace('__init__.py','_bootstrap.py')\n except NameError:\n \n \n  pass\n sys.modules['importlib._bootstrap']=_bootstrap\n \ntry :\n import _frozen_importlib_external as _bootstrap_external\nexcept ImportError:\n from . import _bootstrap_external\n _bootstrap_external._setup(_bootstrap)\n _bootstrap._bootstrap_external=_bootstrap_external\nelse :\n _bootstrap_external.__name__='importlib._bootstrap_external'\n _bootstrap_external.__package__='importlib'\n try :\n  _bootstrap_external.__file__=__file__.replace('__init__.py','_bootstrap_external.py')\n except NameError:\n \n \n  pass\n sys.modules['importlib._bootstrap_external']=_bootstrap_external\n \n \n_pack_uint32=_bootstrap_external._pack_uint32\n_unpack_uint32=_bootstrap_external._unpack_uint32\n\n\n\n\nimport types\nimport warnings\n\n\n\n\nfrom ._bootstrap import __import__\n\n\ndef invalidate_caches():\n ''\n \n for finder in sys.meta_path:\n  if hasattr(finder,'invalidate_caches'):\n   finder.invalidate_caches()\n   \n   \ndef find_loader(name,path=None ):\n ''\n\n\n\n\n\n \n warnings.warn('Deprecated since Python 3.4. '\n 'Use importlib.util.find_spec() instead.',\n DeprecationWarning,stacklevel=2)\n try :\n  loader=sys.modules[name].__loader__\n  if loader is None :\n   raise ValueError('{}.__loader__ is None'.format(name))\n  else :\n   return loader\n except KeyError:\n  pass\n except AttributeError:\n  raise ValueError('{}.__loader__ is not set'.format(name))from None\n  \n spec=_bootstrap._find_spec(name,path)\n \n if spec is None :\n  return None\n if spec.loader is None :\n  if spec.submodule_search_locations is None :\n   raise ImportError('spec for {} missing loader'.format(name),\n   name=name)\n  raise ImportError('namespace packages do not have loaders',\n  name=name)\n return spec.loader\n \n \ndef import_module(name,package=None ):\n ''\n\n\n\n\n\n \n level=0\n if name.startswith('.'):\n  if not package:\n   msg=(\"the 'package' argument is required to perform a relative \"\n   \"import for {!r}\")\n   raise TypeError(msg.format(name))\n  for character in name:\n   if character !='.':\n    break\n   level +=1\n return _bootstrap._gcd_import(name[level:],package,level)\n \n \n_RELOADING={}\n\n\ndef reload(module):\n ''\n\n\n\n \n if not module or not isinstance(module,types.ModuleType):\n  raise TypeError(\"reload() argument must be a module\")\n try :\n  name=module.__spec__.name\n except AttributeError:\n  name=module.__name__\n  \n if sys.modules.get(name)is not module:\n  msg=\"module {} not in sys.modules\"\n  raise ImportError(msg.format(name),name=name)\n if name in _RELOADING:\n  return _RELOADING[name]\n _RELOADING[name]=module\n try :\n  parent_name=name.rpartition('.')[0]\n  if parent_name:\n   try :\n    parent=sys.modules[parent_name]\n   except KeyError:\n    msg=\"parent {!r} not in sys.modules\"\n    raise ImportError(msg.format(parent_name),\n    name=parent_name)from None\n   else :\n    pkgpath=parent.__path__\n  else :\n   pkgpath=None\n  target=module\n  spec=module.__spec__=_bootstrap._find_spec(name,pkgpath,target)\n  if spec is None :\n   raise ModuleNotFoundError(f\"spec not found for the module {name!r}\",name=name)\n  _bootstrap._exec(spec,module)\n  \n  return sys.modules[name]\n finally :\n  try :\n   del _RELOADING[name]\n  except KeyError:\n   pass\n", ["_frozen_importlib", "_frozen_importlib_external", "_imp", "importlib", "importlib._bootstrap", "sys", "types", "warnings"], 1], "importlib.abc": [".py", "''\nfrom . import _bootstrap\nfrom . import _bootstrap_external\nfrom . import machinery\ntry :\n import _frozen_importlib\nexcept ImportError as exc:\n if exc.name !='_frozen_importlib':\n  raise\n _frozen_importlib=None\ntry :\n import _frozen_importlib_external\nexcept ImportError as exc:\n _frozen_importlib_external=_bootstrap_external\nimport abc\nimport warnings\n\n\ndef _register(abstract_cls,*classes):\n for cls in classes:\n  abstract_cls.register(cls)\n  if _frozen_importlib is not None :\n   try :\n    frozen_cls=getattr(_frozen_importlib,cls.__name__)\n   except AttributeError:\n    frozen_cls=getattr(_frozen_importlib_external,cls.__name__)\n   abstract_cls.register(frozen_cls)\n   \n   \nclass Finder(metaclass=abc.ABCMeta):\n\n ''\n\n\n\n\n\n\n\n \n \n @abc.abstractmethod\n def find_module(self,fullname,path=None ):\n  ''\n\n\n  \n  \n  \nclass MetaPathFinder(Finder):\n\n ''\n \n \n \n \n def find_module(self,fullname,path):\n  ''\n\n\n\n\n\n\n\n\n  \n  warnings.warn(\"MetaPathFinder.find_module() is deprecated since Python \"\n  \"3.4 in favor of MetaPathFinder.find_spec() \"\n  \"(available since 3.4)\",\n  DeprecationWarning,\n  stacklevel=2)\n  if not hasattr(self,'find_spec'):\n   return None\n  found=self.find_spec(fullname,path)\n  return found.loader if found is not None else None\n  \n def invalidate_caches(self):\n  ''\n\n  \n  \n_register(MetaPathFinder,machinery.BuiltinImporter,machinery.FrozenImporter,\nmachinery.PathFinder,machinery.WindowsRegistryFinder)\n\n\nclass PathEntryFinder(Finder):\n\n ''\n \n \n \n \n def find_loader(self,fullname):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  warnings.warn(\"PathEntryFinder.find_loader() is deprecated since Python \"\n  \"3.4 in favor of PathEntryFinder.find_spec() \"\n  \"(available since 3.4)\",\n  DeprecationWarning,\n  stacklevel=2)\n  if not hasattr(self,'find_spec'):\n   return None ,[]\n  found=self.find_spec(fullname)\n  if found is not None :\n   if not found.submodule_search_locations:\n    portions=[]\n   else :\n    portions=found.submodule_search_locations\n   return found.loader,portions\n  else :\n   return None ,[]\n   \n find_module=_bootstrap_external._find_module_shim\n \n def invalidate_caches(self):\n  ''\n\n  \n  \n_register(PathEntryFinder,machinery.FileFinder)\n\n\nclass Loader(metaclass=abc.ABCMeta):\n\n ''\n \n def create_module(self,spec):\n  ''\n\n\n\n\n  \n  \n  return None\n  \n  \n  \n  \n def load_module(self,fullname):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not hasattr(self,'exec_module'):\n   raise ImportError\n  return _bootstrap._load_module_shim(self,fullname)\n  \n def module_repr(self,module):\n  ''\n\n\n\n\n\n\n  \n  \n  raise NotImplementedError\n  \n  \nclass ResourceLoader(Loader):\n\n ''\n\n\n\n\n \n \n @abc.abstractmethod\n def get_data(self,path):\n  ''\n  \n  raise OSError\n  \n  \nclass InspectLoader(Loader):\n\n ''\n\n\n\n\n \n \n def is_package(self,fullname):\n  ''\n\n\n\n  \n  raise ImportError\n  \n def get_code(self,fullname):\n  ''\n\n\n\n\n\n  \n  source=self.get_source(fullname)\n  if source is None :\n   return None\n  return self.source_to_code(source)\n  \n @abc.abstractmethod\n def get_source(self,fullname):\n  ''\n\n\n\n  \n  raise ImportError\n  \n @staticmethod\n def source_to_code(data,path='<string>'):\n  ''\n\n\n  \n  return compile(data,path,'exec',dont_inherit=True )\n  \n exec_module=_bootstrap_external._LoaderBasics.exec_module\n load_module=_bootstrap_external._LoaderBasics.load_module\n \n_register(InspectLoader,machinery.BuiltinImporter,machinery.FrozenImporter)\n\n\nclass ExecutionLoader(InspectLoader):\n\n ''\n\n\n\n\n \n \n @abc.abstractmethod\n def get_filename(self,fullname):\n  ''\n\n\n\n  \n  raise ImportError\n  \n def get_code(self,fullname):\n  ''\n\n\n\n  \n  source=self.get_source(fullname)\n  if source is None :\n   return None\n  try :\n   path=self.get_filename(fullname)\n  except ImportError:\n   return self.source_to_code(source)\n  else :\n   return self.source_to_code(source,path)\n   \n_register(ExecutionLoader,machinery.ExtensionFileLoader)\n\n\nclass FileLoader(_bootstrap_external.FileLoader,ResourceLoader,ExecutionLoader):\n\n ''\n \n \n_register(FileLoader,machinery.SourceFileLoader,\nmachinery.SourcelessFileLoader)\n\n\nclass SourceLoader(_bootstrap_external.SourceLoader,ResourceLoader,ExecutionLoader):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def path_mtime(self,path):\n  ''\n  if self.path_stats.__func__ is SourceLoader.path_stats:\n   raise OSError\n  return int(self.path_stats(path)['mtime'])\n  \n def path_stats(self,path):\n  ''\n\n\n\n\n  \n  if self.path_mtime.__func__ is SourceLoader.path_mtime:\n   raise OSError\n  return {'mtime':self.path_mtime(path)}\n  \n def set_data(self,path,data):\n  ''\n\n\n\n\n\n\n  \n  \n_register(SourceLoader,machinery.SourceFileLoader)\n\n\nclass ResourceReader(metaclass=abc.ABCMeta):\n\n ''\n\n\n\n\n \n \n @abc.abstractmethod\n def open_resource(self,resource):\n  ''\n\n\n\n\n\n  \n  raise FileNotFoundError\n  \n @abc.abstractmethod\n def resource_path(self,resource):\n  ''\n\n\n\n\n\n\n  \n  raise FileNotFoundError\n  \n @abc.abstractmethod\n def is_resource(self,name):\n  ''\n  raise FileNotFoundError\n  \n @abc.abstractmethod\n def contents(self):\n  ''\n  return []\n  \n  \n_register(ResourceReader,machinery.SourceFileLoader)\n", ["_frozen_importlib", "_frozen_importlib_external", "abc", "importlib", "importlib._bootstrap", "importlib.machinery", "warnings"]], "collections": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['deque','defaultdict','namedtuple','UserDict','UserList',\n'UserString','Counter','OrderedDict','ChainMap']\n\nimport _collections_abc\nfrom operator import itemgetter as _itemgetter,eq as _eq\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\nimport heapq as _heapq\nfrom _weakref import proxy as _proxy\nfrom itertools import repeat as _repeat,chain as _chain,starmap as _starmap\nfrom reprlib import recursive_repr as _recursive_repr\n\ntry :\n from _collections import deque\nexcept ImportError:\n pass\nelse :\n _collections_abc.MutableSequence.register(deque)\n \ntry :\n from _collections import defaultdict\nexcept ImportError:\n pass\n \n \ndef __getattr__(name):\n\n\n\n if name in _collections_abc.__all__:\n  obj=getattr(_collections_abc,name)\n  import warnings\n  warnings.warn(\"Using or importing the ABCs from 'collections' instead \"\n  \"of from 'collections.abc' is deprecated since Python 3.3, \"\n  \"and in 3.9 it will stop working\",\n  DeprecationWarning,stacklevel=2)\n  globals()[name]=obj\n  return obj\n raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\n \n \n \n \n \nclass _OrderedDictKeysView(_collections_abc.KeysView):\n\n def __reversed__(self):\n  yield from reversed(self._mapping)\n  \nclass _OrderedDictItemsView(_collections_abc.ItemsView):\n\n def __reversed__(self):\n  for key in reversed(self._mapping):\n   yield (key,self._mapping[key])\n   \nclass _OrderedDictValuesView(_collections_abc.ValuesView):\n\n def __reversed__(self):\n  for key in reversed(self._mapping):\n   yield self._mapping[key]\n   \nclass _Link(object):\n __slots__='prev','next','key','__weakref__'\n \nclass OrderedDict(dict):\n ''\n \n \n \n \n \n \n \n \n \n \n \n \n \n def __init__(self,other=(),/,**kwds):\n  ''\n\n  \n  try :\n   self.__root\n  except AttributeError:\n   self.__hardroot=_Link()\n   self.__root=root=_proxy(self.__hardroot)\n   root.prev=root.next=root\n   self.__map={}\n  self.__update(other,**kwds)\n  \n def __setitem__(self,key,value,\n dict_setitem=dict.__setitem__,proxy=_proxy,Link=_Link):\n  ''\n  \n  \n  if key not in self:\n   self.__map[key]=link=Link()\n   root=self.__root\n   last=root.prev\n   link.prev,link.next,link.key=last,root,key\n   last.next=link\n   root.prev=proxy(link)\n  dict_setitem(self,key,value)\n  \n def __delitem__(self,key,dict_delitem=dict.__delitem__):\n  ''\n  \n  \n  dict_delitem(self,key)\n  link=self.__map.pop(key)\n  link_prev=link.prev\n  link_next=link.next\n  link_prev.next=link_next\n  link_next.prev=link_prev\n  link.prev=None\n  link.next=None\n  \n def __iter__(self):\n  ''\n  \n  root=self.__root\n  curr=root.next\n  while curr is not root:\n   yield curr.key\n   curr=curr.next\n   \n def __reversed__(self):\n  ''\n  \n  root=self.__root\n  curr=root.prev\n  while curr is not root:\n   yield curr.key\n   curr=curr.prev\n   \n def clear(self):\n  ''\n  root=self.__root\n  root.prev=root.next=root\n  self.__map.clear()\n  dict.clear(self)\n  \n def popitem(self,last=True ):\n  ''\n\n\n  \n  if not self:\n   raise KeyError('dictionary is empty')\n  root=self.__root\n  if last:\n   link=root.prev\n   link_prev=link.prev\n   link_prev.next=root\n   root.prev=link_prev\n  else :\n   link=root.next\n   link_next=link.next\n   root.next=link_next\n   link_next.prev=root\n  key=link.key\n  del self.__map[key]\n  value=dict.pop(self,key)\n  return key,value\n  \n def move_to_end(self,key,last=True ):\n  ''\n\n\n  \n  link=self.__map[key]\n  link_prev=link.prev\n  link_next=link.next\n  soft_link=link_next.prev\n  link_prev.next=link_next\n  link_next.prev=link_prev\n  root=self.__root\n  if last:\n   last=root.prev\n   link.prev=last\n   link.next=root\n   root.prev=soft_link\n   last.next=link\n  else :\n   first=root.next\n   link.prev=root\n   link.next=first\n   first.prev=soft_link\n   root.next=link\n   \n def __sizeof__(self):\n  sizeof=_sys.getsizeof\n  n=len(self)+1\n  size=sizeof(self.__dict__)\n  size +=sizeof(self.__map)*2\n  size +=sizeof(self.__hardroot)*n\n  size +=sizeof(self.__root)*n\n  return size\n  \n update=__update=_collections_abc.MutableMapping.update\n \n def keys(self):\n  ''\n  return _OrderedDictKeysView(self)\n  \n def items(self):\n  ''\n  return _OrderedDictItemsView(self)\n  \n def values(self):\n  ''\n  return _OrderedDictValuesView(self)\n  \n __ne__=_collections_abc.MutableMapping.__ne__\n \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n\n\n  \n  if key in self:\n   result=self[key]\n   del self[key]\n   return result\n  if default is self.__marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self,key,default=None ):\n  ''\n\n\n  \n  if key in self:\n   return self[key]\n  self[key]=default\n  return default\n  \n @_recursive_repr()\n def __repr__(self):\n  ''\n  if not self:\n   return '%s()'%(self.__class__.__name__,)\n  return '%s(%r)'%(self.__class__.__name__,list(self.items()))\n  \n def __reduce__(self):\n  ''\n  inst_dict=vars(self).copy()\n  for k in vars(OrderedDict()):\n   inst_dict.pop(k,None )\n  return self.__class__,(),inst_dict or None ,None ,iter(self.items())\n  \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  ''\n  \n  self=cls()\n  for key in iterable:\n   self[key]=value\n  return self\n  \n def __eq__(self,other):\n  ''\n\n\n  \n  if isinstance(other,OrderedDict):\n   return dict.__eq__(self,other)and all(map(_eq,self,other))\n  return dict.__eq__(self,other)\n  \n  \ntry :\n from _collections import OrderedDict\nexcept ImportError:\n\n pass\n \n \n \n \n \n \ntry :\n from _collections import _tuplegetter\nexcept ImportError:\n _tuplegetter=lambda index,doc:property(_itemgetter(index),doc=doc)\n \ndef namedtuple(typename,field_names,*,rename=False ,defaults=None ,module=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n if isinstance(field_names,str):\n  field_names=field_names.replace(',',' ').split()\n field_names=list(map(str,field_names))\n typename=_sys.intern(str(typename))\n \n if rename:\n  seen=set()\n  for index,name in enumerate(field_names):\n   if (not name.isidentifier()\n   or _iskeyword(name)\n   or name.startswith('_')\n   or name in seen):\n    field_names[index]=f'_{index}'\n   seen.add(name)\n   \n for name in [typename]+field_names:\n  if type(name)is not str:\n   raise TypeError('Type names and field names must be strings')\n  if not name.isidentifier():\n   raise ValueError('Type names and field names must be valid '\n   f'identifiers: {name!r}')\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a '\n   f'keyword: {name!r}')\n   \n seen=set()\n for name in field_names:\n  if name.startswith('_')and not rename:\n   raise ValueError('Field names cannot start with an underscore: '\n   f'{name!r}')\n  if name in seen:\n   raise ValueError(f'Encountered duplicate field name: {name!r}')\n  seen.add(name)\n  \n field_defaults={}\n if defaults is not None :\n  defaults=tuple(defaults)\n  if len(defaults)>len(field_names):\n   raise TypeError('Got more default values than field names')\n  field_defaults=dict(reversed(list(zip(reversed(field_names),\n  reversed(defaults)))))\n  \n  \n field_names=tuple(map(_sys.intern,field_names))\n num_fields=len(field_names)\n arg_list=repr(field_names).replace(\"'\",\"\")[1:-1]\n repr_fmt='('+', '.join(f'{name}=%r'for name in field_names)+')'\n tuple_new=tuple.__new__\n _dict,_tuple,_len,_map,_zip=dict,tuple,len,map,zip\n \n \n \n s=f'def __new__(_cls, {arg_list}): return _tuple_new(_cls, ({arg_list}))'\n namespace={'_tuple_new':tuple_new,'__name__':f'namedtuple_{typename}'}\n \n exec(s,namespace)\n __new__=namespace['__new__']\n __new__.__doc__=f'Create new instance of {typename}({arg_list})'\n if defaults is not None :\n  __new__.__defaults__=defaults\n  \n @classmethod\n def _make(cls,iterable):\n  result=tuple_new(cls,iterable)\n  if _len(result)!=num_fields:\n   raise TypeError(f'Expected {num_fields} arguments, got {len(result)}')\n  return result\n  \n _make.__func__.__doc__=(f'Make a new {typename} object from a sequence '\n 'or iterable')\n \n def _replace(self,/,**kwds):\n  result=self._make(_map(kwds.pop,field_names,self))\n  if kwds:\n   raise ValueError(f'Got unexpected field names: {list(kwds)!r}')\n  return result\n  \n _replace.__doc__=(f'Return a new {typename} object replacing specified '\n 'fields with new values')\n \n def __repr__(self):\n  ''\n  return self.__class__.__name__+repr_fmt %self\n  \n def _asdict(self):\n  ''\n  return _dict(_zip(self._fields,self))\n  \n def __getnewargs__(self):\n  ''\n  return _tuple(self)\n  \n  \n for method in (__new__,_make.__func__,_replace,\n __repr__,_asdict,__getnewargs__):\n  method.__qualname__=f'{typename}.{method.__name__}'\n  \n  \n  \n class_namespace={\n '__doc__':f'{typename}({arg_list})',\n '__slots__':(),\n '_fields':field_names,\n '_field_defaults':field_defaults,\n \n '_fields_defaults':field_defaults,\n '__new__':__new__,\n '_make':_make,\n '_replace':_replace,\n '__repr__':__repr__,\n '_asdict':_asdict,\n '__getnewargs__':__getnewargs__,\n }\n for index,name in enumerate(field_names):\n  doc=_sys.intern(f'Alias for field number {index}')\n  class_namespace[name]=_tuplegetter(index,doc)\n  \n result=type(typename,(tuple,),class_namespace)\n \n \n \n \n \n \n if module is None :\n  try :\n   module=_sys._getframe(1).f_globals.get('__name__','__main__')\n  except (AttributeError,ValueError):\n   pass\n if module is not None :\n  result.__module__=module\n  \n return result\n \n \n \n \n \n \ndef _count_elements(mapping,iterable):\n ''\n mapping_get=mapping.get\n for elem in iterable:\n  mapping[elem]=mapping_get(elem,0)+1\n  \ntry :\n from _collections import _count_elements\nexcept ImportError:\n pass\n \nclass Counter(dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n def __init__(self,iterable=None ,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n  \n  super(Counter,self).__init__()\n  self.update(iterable,**kwds)\n  \n def __missing__(self,key):\n  ''\n  \n  return 0\n  \n def most_common(self,n=None ):\n  ''\n\n\n\n\n\n  \n  \n  if n is None :\n   return sorted(self.items(),key=_itemgetter(1),reverse=True )\n  return _heapq.nlargest(n,self.items(),key=_itemgetter(1))\n  \n def elements(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return _chain.from_iterable(_starmap(_repeat,self.items()))\n  \n  \n  \n @classmethod\n def fromkeys(cls,iterable,v=None ):\n \n \n \n \n \n \n \n  raise NotImplementedError(\n  'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n  \n def update(self,iterable=None ,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  if iterable is not None :\n   if isinstance(iterable,_collections_abc.Mapping):\n    if self:\n     self_get=self.get\n     for elem,count in iterable.items():\n      self[elem]=count+self_get(elem,0)\n    else :\n     super(Counter,self).update(iterable)\n   else :\n    _count_elements(self,iterable)\n  if kwds:\n   self.update(kwds)\n   \n def subtract(self,iterable=None ,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if iterable is not None :\n   self_get=self.get\n   if isinstance(iterable,_collections_abc.Mapping):\n    for elem,count in iterable.items():\n     self[elem]=self_get(elem,0)-count\n   else :\n    for elem in iterable:\n     self[elem]=self_get(elem,0)-1\n  if kwds:\n   self.subtract(kwds)\n   \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n def __reduce__(self):\n  return self.__class__,(dict(self),)\n  \n def __delitem__(self,elem):\n  ''\n  if elem in self:\n   super().__delitem__(elem)\n   \n def __repr__(self):\n  if not self:\n   return '%s()'%self.__class__.__name__\n  try :\n   items=', '.join(map('%r: %r'.__mod__,self.most_common()))\n   return '%s({%s})'%(self.__class__.__name__,items)\n  except TypeError:\n  \n   return '{0}({1!r})'.format(self.__class__.__name__,dict(self))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def __add__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   newcount=count+other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __sub__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   newcount=count -other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count <0:\n    result[elem]=0 -count\n  return result\n  \n def __or__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   other_count=other[elem]\n   newcount=other_count if count <other_count else count\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __and__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   other_count=other[elem]\n   newcount=count if count <other_count else other_count\n   if newcount >0:\n    result[elem]=newcount\n  return result\n  \n def __pos__(self):\n  ''\n  result=Counter()\n  for elem,count in self.items():\n   if count >0:\n    result[elem]=count\n  return result\n  \n def __neg__(self):\n  ''\n\n\n  \n  result=Counter()\n  for elem,count in self.items():\n   if count <0:\n    result[elem]=0 -count\n  return result\n  \n def _keep_positive(self):\n  ''\n  nonpositive=[elem for elem,count in self.items()if not count >0]\n  for elem in nonpositive:\n   del self[elem]\n  return self\n  \n def __iadd__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in other.items():\n   self[elem]+=count\n  return self._keep_positive()\n  \n def __isub__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in other.items():\n   self[elem]-=count\n  return self._keep_positive()\n  \n def __ior__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,other_count in other.items():\n   count=self[elem]\n   if other_count >count:\n    self[elem]=other_count\n  return self._keep_positive()\n  \n def __iand__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in self.items():\n   other_count=other[elem]\n   if other_count <count:\n    self[elem]=other_count\n  return self._keep_positive()\n  \n  \n  \n  \n  \n  \nclass ChainMap(_collections_abc.MutableMapping):\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*maps):\n  ''\n\n\n  \n  self.maps=list(maps)or [{}]\n  \n def __missing__(self,key):\n  raise KeyError(key)\n  \n def __getitem__(self,key):\n  for mapping in self.maps:\n   try :\n    return mapping[key]\n   except KeyError:\n    pass\n  return self.__missing__(key)\n  \n def get(self,key,default=None ):\n  return self[key]if key in self else default\n  \n def __len__(self):\n  return len(set().union(*self.maps))\n  \n def __iter__(self):\n  d={}\n  for mapping in reversed(self.maps):\n   d.update(mapping)\n  return iter(d)\n  \n def __contains__(self,key):\n  return any(key in m for m in self.maps)\n  \n def __bool__(self):\n  return any(self.maps)\n  \n @_recursive_repr()\n def __repr__(self):\n  return f'{self.__class__.__name__}({\", \".join(map(repr, self.maps))})'\n  \n @classmethod\n def fromkeys(cls,iterable,*args):\n  ''\n  return cls(dict.fromkeys(iterable,*args))\n  \n def copy(self):\n  ''\n  return self.__class__(self.maps[0].copy(),*self.maps[1:])\n  \n __copy__=copy\n \n def new_child(self,m=None ):\n  ''\n\n  \n  if m is None :\n   m={}\n  return self.__class__(m,*self.maps)\n  \n @property\n def parents(self):\n  ''\n  return self.__class__(*self.maps[1:])\n  \n def __setitem__(self,key,value):\n  self.maps[0][key]=value\n  \n def __delitem__(self,key):\n  try :\n   del self.maps[0][key]\n  except KeyError:\n   raise KeyError('Key not found in the first mapping: {!r}'.format(key))\n   \n def popitem(self):\n  ''\n  try :\n   return self.maps[0].popitem()\n  except KeyError:\n   raise KeyError('No keys found in the first mapping.')\n   \n def pop(self,key,*args):\n  ''\n  try :\n   return self.maps[0].pop(key,*args)\n  except KeyError:\n   raise KeyError('Key not found in the first mapping: {!r}'.format(key))\n   \n def clear(self):\n  ''\n  self.maps[0].clear()\n  \n  \n  \n  \n  \n  \nclass UserDict(_collections_abc.MutableMapping):\n\n\n def __init__(*args,**kwargs):\n  if not args:\n   raise TypeError(\"descriptor '__init__' of 'UserDict' object \"\n   \"needs an argument\")\n  self,*args=args\n  if len(args)>1:\n   raise TypeError('expected at most 1 arguments, got %d'%len(args))\n  if args:\n   dict=args[0]\n  elif 'dict'in kwargs:\n   dict=kwargs.pop('dict')\n   import warnings\n   warnings.warn(\"Passing 'dict' as keyword argument is deprecated\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   dict=None\n  self.data={}\n  if dict is not None :\n   self.update(dict)\n  if kwargs:\n   self.update(kwargs)\n __init__.__text_signature__='($self, dict=None, /, **kwargs)'\n \n def __len__(self):return len(self.data)\n def __getitem__(self,key):\n  if key in self.data:\n   return self.data[key]\n  if hasattr(self.__class__,\"__missing__\"):\n   return self.__class__.__missing__(self,key)\n  raise KeyError(key)\n def __setitem__(self,key,item):self.data[key]=item\n def __delitem__(self,key):del self.data[key]\n def __iter__(self):\n  return iter(self.data)\n  \n  \n def __contains__(self,key):\n  return key in self.data\n  \n  \n def __repr__(self):return repr(self.data)\n def __copy__(self):\n  inst=self.__class__.__new__(self.__class__)\n  inst.__dict__.update(self.__dict__)\n  \n  inst.__dict__[\"data\"]=self.__dict__[\"data\"].copy()\n  return inst\n  \n def copy(self):\n  if self.__class__ is UserDict:\n   return UserDict(self.data.copy())\n  import copy\n  data=self.data\n  try :\n   self.data={}\n   c=copy.copy(self)\n  finally :\n   self.data=data\n  c.update(self)\n  return c\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  d=cls()\n  for key in iterable:\n   d[key]=value\n  return d\n  \n  \n  \n  \n  \n  \n  \nclass UserList(_collections_abc.MutableSequence):\n ''\n def __init__(self,initlist=None ):\n  self.data=[]\n  if initlist is not None :\n  \n   if type(initlist)==type(self.data):\n    self.data[:]=initlist\n   elif isinstance(initlist,UserList):\n    self.data[:]=initlist.data[:]\n   else :\n    self.data=list(initlist)\n def __repr__(self):return repr(self.data)\n def __lt__(self,other):return self.data <self.__cast(other)\n def __le__(self,other):return self.data <=self.__cast(other)\n def __eq__(self,other):return self.data ==self.__cast(other)\n def __gt__(self,other):return self.data >self.__cast(other)\n def __ge__(self,other):return self.data >=self.__cast(other)\n def __cast(self,other):\n  return other.data if isinstance(other,UserList)else other\n def __contains__(self,item):return item in self.data\n def __len__(self):return len(self.data)\n def __getitem__(self,i):\n  if isinstance(i,slice):\n   return self.__class__(self.data[i])\n  else :\n   return self.data[i]\n def __setitem__(self,i,item):self.data[i]=item\n def __delitem__(self,i):del self.data[i]\n def __add__(self,other):\n  if isinstance(other,UserList):\n   return self.__class__(self.data+other.data)\n  elif isinstance(other,type(self.data)):\n   return self.__class__(self.data+other)\n  return self.__class__(self.data+list(other))\n def __radd__(self,other):\n  if isinstance(other,UserList):\n   return self.__class__(other.data+self.data)\n  elif isinstance(other,type(self.data)):\n   return self.__class__(other+self.data)\n  return self.__class__(list(other)+self.data)\n def __iadd__(self,other):\n  if isinstance(other,UserList):\n   self.data +=other.data\n  elif isinstance(other,type(self.data)):\n   self.data +=other\n  else :\n   self.data +=list(other)\n  return self\n def __mul__(self,n):\n  return self.__class__(self.data *n)\n __rmul__=__mul__\n def __imul__(self,n):\n  self.data *=n\n  return self\n def __copy__(self):\n  inst=self.__class__.__new__(self.__class__)\n  inst.__dict__.update(self.__dict__)\n  \n  inst.__dict__[\"data\"]=self.__dict__[\"data\"][:]\n  return inst\n def append(self,item):self.data.append(item)\n def insert(self,i,item):self.data.insert(i,item)\n def pop(self,i=-1):return self.data.pop(i)\n def remove(self,item):self.data.remove(item)\n def clear(self):self.data.clear()\n def copy(self):return self.__class__(self)\n def count(self,item):return self.data.count(item)\n def index(self,item,*args):return self.data.index(item,*args)\n def reverse(self):self.data.reverse()\n def sort(self,/,*args,**kwds):self.data.sort(*args,**kwds)\n def extend(self,other):\n  if isinstance(other,UserList):\n   self.data.extend(other.data)\n  else :\n   self.data.extend(other)\n   \n   \n   \n   \n   \n   \n   \nclass UserString(_collections_abc.Sequence):\n def __init__(self,seq):\n  if isinstance(seq,str):\n   self.data=seq\n  elif isinstance(seq,UserString):\n   self.data=seq.data[:]\n  else :\n   self.data=str(seq)\n def __str__(self):return str(self.data)\n def __repr__(self):return repr(self.data)\n def __int__(self):return int(self.data)\n def __float__(self):return float(self.data)\n def __complex__(self):return complex(self.data)\n def __hash__(self):return hash(self.data)\n def __getnewargs__(self):\n  return (self.data[:],)\n  \n def __eq__(self,string):\n  if isinstance(string,UserString):\n   return self.data ==string.data\n  return self.data ==string\n def __lt__(self,string):\n  if isinstance(string,UserString):\n   return self.data <string.data\n  return self.data <string\n def __le__(self,string):\n  if isinstance(string,UserString):\n   return self.data <=string.data\n  return self.data <=string\n def __gt__(self,string):\n  if isinstance(string,UserString):\n   return self.data >string.data\n  return self.data >string\n def __ge__(self,string):\n  if isinstance(string,UserString):\n   return self.data >=string.data\n  return self.data >=string\n  \n def __contains__(self,char):\n  if isinstance(char,UserString):\n   char=char.data\n  return char in self.data\n  \n def __len__(self):return len(self.data)\n def __getitem__(self,index):return self.__class__(self.data[index])\n def __add__(self,other):\n  if isinstance(other,UserString):\n   return self.__class__(self.data+other.data)\n  elif isinstance(other,str):\n   return self.__class__(self.data+other)\n  return self.__class__(self.data+str(other))\n def __radd__(self,other):\n  if isinstance(other,str):\n   return self.__class__(other+self.data)\n  return self.__class__(str(other)+self.data)\n def __mul__(self,n):\n  return self.__class__(self.data *n)\n __rmul__=__mul__\n def __mod__(self,args):\n  return self.__class__(self.data %args)\n def __rmod__(self,template):\n  return self.__class__(str(template)%self)\n  \n def capitalize(self):return self.__class__(self.data.capitalize())\n def casefold(self):\n  return self.__class__(self.data.casefold())\n def center(self,width,*args):\n  return self.__class__(self.data.center(width,*args))\n def count(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.count(sub,start,end)\n def encode(self,encoding='utf-8',errors='strict'):\n  encoding='utf-8'if encoding is None else encoding\n  errors='strict'if errors is None else errors\n  return self.data.encode(encoding,errors)\n def endswith(self,suffix,start=0,end=_sys.maxsize):\n  return self.data.endswith(suffix,start,end)\n def expandtabs(self,tabsize=8):\n  return self.__class__(self.data.expandtabs(tabsize))\n def find(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.find(sub,start,end)\n def format(self,/,*args,**kwds):\n  return self.data.format(*args,**kwds)\n def format_map(self,mapping):\n  return self.data.format_map(mapping)\n def index(self,sub,start=0,end=_sys.maxsize):\n  return self.data.index(sub,start,end)\n def isalpha(self):return self.data.isalpha()\n def isalnum(self):return self.data.isalnum()\n def isascii(self):return self.data.isascii()\n def isdecimal(self):return self.data.isdecimal()\n def isdigit(self):return self.data.isdigit()\n def isidentifier(self):return self.data.isidentifier()\n def islower(self):return self.data.islower()\n def isnumeric(self):return self.data.isnumeric()\n def isprintable(self):return self.data.isprintable()\n def isspace(self):return self.data.isspace()\n def istitle(self):return self.data.istitle()\n def isupper(self):return self.data.isupper()\n def join(self,seq):return self.data.join(seq)\n def ljust(self,width,*args):\n  return self.__class__(self.data.ljust(width,*args))\n def lower(self):return self.__class__(self.data.lower())\n def lstrip(self,chars=None ):return self.__class__(self.data.lstrip(chars))\n maketrans=str.maketrans\n def partition(self,sep):\n  return self.data.partition(sep)\n def replace(self,old,new,maxsplit=-1):\n  if isinstance(old,UserString):\n   old=old.data\n  if isinstance(new,UserString):\n   new=new.data\n  return self.__class__(self.data.replace(old,new,maxsplit))\n def rfind(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.rfind(sub,start,end)\n def rindex(self,sub,start=0,end=_sys.maxsize):\n  return self.data.rindex(sub,start,end)\n def rjust(self,width,*args):\n  return self.__class__(self.data.rjust(width,*args))\n def rpartition(self,sep):\n  return self.data.rpartition(sep)\n def rstrip(self,chars=None ):\n  return self.__class__(self.data.rstrip(chars))\n def split(self,sep=None ,maxsplit=-1):\n  return self.data.split(sep,maxsplit)\n def rsplit(self,sep=None ,maxsplit=-1):\n  return self.data.rsplit(sep,maxsplit)\n def splitlines(self,keepends=False ):return self.data.splitlines(keepends)\n def startswith(self,prefix,start=0,end=_sys.maxsize):\n  return self.data.startswith(prefix,start,end)\n def strip(self,chars=None ):return self.__class__(self.data.strip(chars))\n def swapcase(self):return self.__class__(self.data.swapcase())\n def title(self):return self.__class__(self.data.title())\n def translate(self,*args):\n  return self.__class__(self.data.translate(*args))\n def upper(self):return self.__class__(self.data.upper())\n def zfill(self,width):return self.__class__(self.data.zfill(width))\n", ["_collections", "_collections_abc", "_weakref", "copy", "heapq", "itertools", "keyword", "operator", "reprlib", "sys", "warnings"], 1], "collections.abc": [".py", "from _collections_abc import *\nfrom _collections_abc import __all__\n", ["_collections_abc"]]}
__BRYTHON__.update_VFS(scripts)
